#27a147  greeen for the grass
#0000FF  blue for the buildings
#dfeaeb,  for the paths 

="[" & A1 & ", " & B1 & "],"
edit for me this, and give me the code with the following variables onlly

 {
      "type": "Feature",
      "geometry": {
        "type": "",
        "coordinates": [
          
          
          
        ]
      },
      "properties": {
        "name": "",
        "fillColor": "#0000FF",
        "borderColor": "#0000FF",
        "zIndex": 2
      },
      "id": ""
    }
   

so keep Line string or polygon, and just keep these attributes, so edit the file so i can download it with the changes, i have attached the file which needs to be changed


EDIT THE geojson file attached on this chat, and do the following, 

i want it to have the following format
{
      "type": "Feature",
      "geometry": {
        "type": "",
        "coordinates": [
          
          
          
        ]
      },
      "properties": {
        "name": "",
        "fillColor": ,
        "borderColor": ,
        "zIndex": 2
      },
      "id": ""
    }


so only the usiu border should have zindex 1 while all other features will have zindex 2

and all the polygons should have the following fill and border color
#0000FF

except the following polygons which will have the following fill and border color #dfeaeb 
SIRONI PARKING-GREY COLOR INSIDE, THE WHOLE BORDER
BORDER OF GATE B PARKIBG NEEDS COLOR INSIDE
NEEDS COLOR PARKING AREA NEAR OLD HOSTELS
STUDENT CENTRE OUTSIDE PARAKINH NEEDS BORDER COLOR
PATH OUTSIDE SCIENCE COMPLEX NEEDS COLOR
SCIENCE COMPLEX PARKING BORDER NEEDS COLOR
STUDENT CENTRE PARKING 1 BORDER NEEDS COLOR
AUDITORIUM PARKING BORDER NEEDS COLOR
PATH 27 OUTSIDE AUDITORIUM
PATH NEEDS COLOR OUTSIDE AUDITORIUM
NEEDS COLOR NEAR BUS PARKING
NEEDS COLORING INSIDE THE TRANSPORT OFFICE
PARKING NEAR HOSTELS
ADMIN PARKING OUTSIDE NEEDS COLOR
LIBRARY PARKING BEHIND
SITTING AREA BEHIND ADMIN
CAFELLATTA SITTING AREA
WORKING SPACE BEHIND PAULS CAFFE NEEDS COLOR


and the following polgygons should have fill and border color #27a147
GARDEN OUTSIDE PAULS
garden outsdie pauls caffe
GARDEN OUTSIDE USIU STORE NEEDS COLOR
ROUNDABOUT IN CAFFELATTA NEEDS GREEN COLOR
GARDEN NEAR BUS PARKING
GARDEN 1 OUTSIDE BASKETBALL COURT
GARDEN OUTSIDE SCIENCE COMPLEX
CIRCLE ROUNDABOUT GATE B
GARDEN BETWEEN JAPANESE CLASS

PATH AROUND AUDITORIUM should have the fill and border color of #dfeaeb 

and all other lines string should have the following fill and border color
#dfeaeb 

the fill color and border color for usiu border should be
#27a147


so edit for me the attached file and give me the new file so i can download it, and dont lose my format, it should be vertical

remeber the format i gave you, only keep those, and only the usiu map border should have a different color with zindex 1 

so see the attached file on this chat



INDEX FILE USED TO EDIT coordinates
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leaflet GeoJSON with Multiple Polygon Colors</title>
    <link rel="stylesheet" href="leaflet.css">
    <style>
        #map {
            height: 1000px;
            width: 100%;
            background-color: white;
        }

        /* Custom alert modal */
        #custom-alert {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border: 1px solid #ccc;
            z-index: 1000;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
        }

        #custom-alert button {
            margin: 5px;
        }

        /* Modal overlay */
        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
    </style>
</head>
<body>

    <h2>Polygons with Different Colors</h2>
    <div id="map"></div>

    <!-- Custom Alert Modal -->
    <div id="overlay"></div>
    <div id="custom-alert">
        <p id="alert-text">Coordinates: </p>
        <button id="copy-coord">Copy Coordinates</button>
        <button id="edit-coord">Edit Coordinates</button>
        <button id="done-coord">Done</button> <!-- New Done Button -->
        <button id="cancel">Cancel</button>
    </div>

    <script src="leaflet.js"></script>
    <script>
        var map;
        var selectedLayer;
        var currentFeature;
        var currentCoordIndex;
        var currentLng;
        var currentLat;
        var currentMarker;
        var geojsonData;

        // Restore map position from localStorage if available
        function loadMapPosition() {
            var savedCenter = localStorage.getItem('mapCenter');
            var savedZoom = localStorage.getItem('mapZoom');
            if (savedCenter && savedZoom) {
                var center = JSON.parse(savedCenter);
                var zoom = JSON.parse(savedZoom);
                map.setView(center, zoom);
            } else {
                map.setView([-1.219737, 36.879385], 15); // Default view
            }
        }

        // Save map position to localStorage
        function saveMapPosition() {
            localStorage.setItem('mapCenter', JSON.stringify(map.getCenter()));
            localStorage.setItem('mapZoom', map.getZoom());
        }

        // Initialize the map
        document.addEventListener("DOMContentLoaded", function () {
            map = L.map('map');
            loadMapPosition(); // Load map position if available
            map.on('moveend', saveMapPosition); // Save map position on move

            fetch('14.geojson')
                .then(response => response.json())
                .then(data => {
                    geojsonData = data; // Store the GeoJSON data globally
                    L.geoJSON(data, {
                        style: function (feature) {
                            return {
                                fillColor: feature.properties.fillColor || "#7ab064",
                                color: feature.properties.borderColor || "#7ab064",
                                weight: feature.properties["stroke-width"] || 2,
                                fillOpacity: 0.7
                            };
                        },
                        onEachFeature: function (feature, layer) {
                            if (feature.geometry.type === 'LineString' || feature.geometry.type === 'Polygon') {

                                // Highlight polygon or path in red on click
                                layer.on('click', function () {
                                    if (selectedLayer) {
                                        // Reset the previous layer's style
                                        selectedLayer.setStyle({
                                            fillColor: selectedLayer.feature.properties.fillColor || "#7ab064",
                                            color: selectedLayer.feature.properties.borderColor || "#7ab064",
                                            weight: selectedLayer.feature.properties["stroke-width"] || 2,
                                            fillOpacity: 0.7
                                        });
                                    }

                                    // Highlight the current layer in red
                                    layer.setStyle({
                                        fillColor: "#FF0000",
                                        color: "#FF0000",
                                        weight: 3,
                                        fillOpacity: 0.7
                                    });

                                    selectedLayer = layer;
                                });

                                // Show the name of the feature on hover
                                layer.on('mouseover', function (e) {
                                    if (feature.properties && feature.properties.name) {
                                        var popup = L.popup()
                                            .setLatLng(e.latlng)
                                            .setContent(`<b>${feature.properties.name}</b>`)
                                            .openOn(map);
                                    }
                                });

                                // Remove the popup when mouse leaves the feature
                                layer.on('mouseout', function () {
                                    map.closePopup();
                                });
                            }

                            // Add markers for LineString start and end points
                            if (feature.geometry.type === 'LineString') {
                                var coordinates = feature.geometry.coordinates;
                                var start = coordinates[0];
                                var end = coordinates[coordinates.length - 1];

                                var markerIcon = L.icon({
                                    iconUrl: feature.properties.done ? 'redmarker.png' : 'marker-icon.png', // Use redmarker if marked as done
                                    iconSize: [25, 41],
                                    iconAnchor: [12, 41],
                                    popupAnchor: [1, -34]
                                });

                                // Start marker with alert for copy/edit/done
                                var startMarker = L.marker([start[1], start[0]], { icon: markerIcon }).addTo(map);
                                startMarker.on('click', function () {
                                    currentMarker = startMarker; // Store the current marker
                                    handleMarkerClick(start[0], start[1], 0, feature.id);
                                });

                                // End marker with alert for copy/edit/done
                                var endMarker = L.marker([end[1], end[0]], { icon: markerIcon }).addTo(map);
                                endMarker.on('click', function () {
                                    currentMarker = endMarker; // Store the current marker
                                    handleMarkerClick(end[0], end[1], coordinates.length - 1, feature.id);
                                });
                            }
                        }
                    }).addTo(map);
                })
                .catch(error => console.error('Error loading the GeoJSON file:', error));
        });

        // Function to handle marker click and show the alert options
        function handleMarkerClick(lng, lat, coordIndex, featureId) {
            currentLng = lng;
            currentLat = lat;
            currentCoordIndex = coordIndex;
            currentFeature = featureId;

            // Show the custom modal with copy/edit/done options
            document.getElementById('alert-text').innerText = `Coordinates: ${lng}, ${lat}`;
            document.getElementById('custom-alert').style.display = 'block';
            document.getElementById('overlay').style.display = 'block';
        }

        // Function to copy coordinates to the clipboard
        function copyToClipboard() {
            var text = `${currentLng}, ${currentLat}`;
            navigator.clipboard.writeText(text).then(function () {
                alert(text + ' copied to clipboard');
            }, function (err) {
                console.error('Could not copy text: ', err);
            });
            closeModal();
        }

        // Function to edit coordinates using a prompt
        function editCoordinates() {
            var newCoord = prompt(`Edit Coordinates\nCurrent: ${currentLng}, ${currentLat}\nEnter new coordinates in format "lng, lat":`, `${currentLng}, ${currentLat}`);
            if (newCoord) {
                var parsedCoord = newCoord.split(',').map(Number);
                if (parsedCoord.length === 2 && !isNaN(parsedCoord[0]) && !isNaN(parsedCoord[1])) {
                    // Update coordinates and send to server
                    saveCoordinates(parsedCoord, currentCoordIndex, currentFeature);
                } else {
                    alert('Invalid input. Coordinates must be in format "lng, lat".');
                }
            }
            closeModal();
        }

        // Function to mark as done (change marker icon and save state)
        function markAsDone() {
            var redMarkerIcon = L.icon({
                iconUrl: 'redmarker.png', // Path to the red marker image
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34]
            });

            currentMarker.setIcon(redMarkerIcon); // Change the marker's icon to red

            // Update the GeoJSON data to mark the feature as done
            geojsonData.features.forEach(feature => {
                if (feature.id === currentFeature) {
                    feature.properties.done = true; // Mark as done in GeoJSON
                }
            });

            // Send updated GeoJSON data to the server
            saveGeoJson(geojsonData);
            closeModal();
        }

        // Function to save the new coordinates via server
        function saveCoordinates(newCoord, coordIndex, featureId) {
            fetch('/update-coord', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ featureId: featureId, coordIndex: coordIndex, newCoord: newCoord })
            }).then(response => {
                if (response.ok) {
                    alert('Coordinates updated successfully!');
                    location.reload(); // This will preserve map position since we save it in localStorage
                } else {
                    alert('Failed to update coordinates.');
                }
            }).catch(error => console.error('Error updating coordinates:', error));
        }

        // Function to save updated GeoJSON to the server
        function saveGeoJson(geojsonData) {
            fetch('/save-geojson', { // Ensure you have a corresponding server route to save this data
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(geojsonData)
            }).then(response => {
                if (response.ok) {
                    alert('Marker status updated successfully!');
                    location.reload(); // This will preserve map position since we save it in localStorage
                } else {
                    alert('Failed to update marker status.');
                }
            }).catch(error => console.error('Error saving GeoJSON:', error));
        }

        // Function to close the modal
        function closeModal() {
            document.getElementById('custom-alert').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }

        // Event listeners for modal buttons
        document.getElementById('copy-coord').addEventListener('click', copyToClipboard);
        document.getElementById('edit-coord').addEventListener('click', editCoordinates);
        document.getElementById('done-coord').addEventListener('click', markAsDone); // Done button functionality
        document.getElementById('cancel').addEventListener('click', closeModal);
    </script>

</body>
</html>


the server file
const express = require('express');
const fs = require('fs');
const path = require('path');
const bodyParser = require('body-parser');

const app = express();
app.use(bodyParser.json());

const geojsonFilePath = path.join(__dirname, 'public/14.geojson');

// Route to handle updating coordinates in the GeoJSON file
app.post('/update-coord', (req, res) => {
    const { featureId, coordIndex, newCoord } = req.body;

    // Read the existing GeoJSON file
    fs.readFile(geojsonFilePath, 'utf8', (err, data) => {
        if (err) {
            console.error('Error reading the GeoJSON file:', err);
            return res.status(500).send('Error reading the GeoJSON file');
        }

        let geojson = JSON.parse(data);

        // Find and update the correct feature in the GeoJSON by feature ID
        let feature = geojson.features.find(f => f.id === featureId);
        if (feature && feature.geometry.type === 'LineString') {
            feature.geometry.coordinates[coordIndex] = newCoord;

            // Write the updated GeoJSON back to the file
            fs.writeFile(geojsonFilePath, JSON.stringify(geojson, null, 2), (err) => {
                if (err) {
                    console.error('Error writing to the GeoJSON file:', err);
                    return res.status(500).send('Error updating the GeoJSON file');
                }
                res.status(200).send('GeoJSON updated successfully');
            });
        } else {
            res.status(400).send('Feature not found or invalid geometry type');
        }
    });
});

app.use(express.static('public'));

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
 

 when changing a coordinates
 change point to another point
 remove the old point from geojson file
 edit the new distance of that path
 edit the graph






 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        // Load the GeoJSON file (14.geojson) and add the features to the map
        fetch('14.geojson')
            .then(response => response.json())
            .then(data => {
                var featureSelect = document.getElementById('featureSelect');
                L.geoJSON(data, {
                    pointToLayer: function (feature, latlng) {
                        var marker = L.marker(latlng);
                        marker.bindPopup(feature.properties.name);
                        featureLayers.push({
                            name: feature.properties.name,
                            layer: marker,
                            featureType: feature.geometry.type
                        });
                        return marker;
                    },
                    style: function (feature) {
                        var isUSIUBorder = feature.properties.name === 'usiu border';
                        return {
                            color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                            fillColor: isUSIUBorder ? '#fff' : (feature.properties.fillColor || '#ccc'),
                            fillOpacity: isUSIUBorder ? 1 : 0.7,
                            weight: isUSIUBorder ? 5 : 2,
                            zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                        };
                    },
                    onEachFeature: function (feature, layer) {
                        var option = document.createElement('option');
                        option.value = feature.properties.name;
                        option.text = feature.properties.name;
                        featureSelect.appendChild(option);

                        if (feature.geometry.type === "LineString") {
                            pathLayers.push({
                                name: feature.properties.name,
                                layer: layer
                            });
                        }

                        if (feature.properties.name === 'usiu border') {
                            usiuBorderLayer = layer;
                        }

                        if (feature.properties && feature.properties.name) {
                            layer.bindPopup(feature.properties.name);
                        }
                    }
                }).addTo(map);

                if (usiuBorderLayer) {
                    var maskBounds = usiuBorderLayer.getBounds();
                    L.polygon(usiuBorderLayer.getLatLngs(), {
                        color: '#000',
                        fillColor: '#fff',
                        fillOpacity: 1,
                        zIndex: 1000
                    }).addTo(map);
                }
            })
            .catch(error => console.error('Error loading the GeoJSON file:', error));

        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }

        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);
            });
        }

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

        // Function to highlight the paths in the shortest route
        function highlightPaths(paths) {
            // Reset all path colors to default
            pathLayers.forEach(layerObj => {
                layerObj.layer.setStyle({
                    color: layerObj.layer.feature.properties.borderColor || '#000',
                    fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
                });

                // Remove previous polylines (if any)
                if (layerObj.polyline) {
                    map.removeLayer(layerObj.polyline);
                }
            });

            // Highlight the paths that are part of the shortest route
            paths.forEach(({ path, from, to }) => {
                const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
                if (matchingLayer) {
                    // Set the color to red for the shortest route
                    matchingLayer.layer.setStyle({ color: 'red' });

                    // Extract the coordinates from the matching path layer and draw a polyline
                    const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

                    const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

                    // Store the polyline on the layer object for potential future cleanup
                    matchingLayer.polyline = polyline;
                }
            });
        }
    </script>
</body>
</html>










<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name);
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'usiu border';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#fff' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                if (feature.properties.name === 'usiu border') {
                    usiuBorderLayer = layer;
                }

                if (feature.properties && feature.properties.name) {
                    layer.bindPopup(feature.properties.name);

                    // Handle clicking on features to show name and also register coordinates
                    layer.on('click', function (e) {
                        var latlng = e.latlng;
                        document.getElementById('coordSource').value = `${latlng.lat}, ${latlng.lng}`;
                    });
                }
            }
        }).addTo(map);

        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));

// Listen for clicks on the map (anywhere) to get coordinates, even when interacting with features
map.on('click', function(e) {
    var latlng = e.latlng;
    document.getElementById('coordSource').value = `${latlng.lat}, ${latlng.lng}`;
});



        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }

        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        }

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

        // Function to highlight the paths in the shortest route
        function highlightPaths(paths) {
            // Reset all path colors to default
            pathLayers.forEach(layerObj => {
                layerObj.layer.setStyle({
                    color: layerObj.layer.feature.properties.borderColor || '#000',
                    fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
                });

                // Remove previous polylines (if any)
                if (layerObj.polyline) {
                    map.removeLayer(layerObj.polyline);
                }
            });

            // Highlight the paths that are part of the shortest route
            paths.forEach(({ path, from, to }) => {
                const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
                if (matchingLayer) {
                    // Set the color to red for the shortest route
                    matchingLayer.layer.setStyle({ color: 'red' });

                    // Extract the coordinates from the matching path layer and draw a polyline
                    const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

                    const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

                    // Store the polyline on the layer object for potential future cleanup
                    matchingLayer.polyline = polyline;
                }
            });
        }



// Handle search button click for coordSearchBtn
document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat, lng] = coordSource.split(',').map(Number);
    const userLatLng = L.latLng(lat, lng);

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});


// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}




    </script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name);
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'usiu border';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#fff' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });

                    layer.on('click', function (e) {
            var latlng = e.latlng; // Get the coordinates of the clicked point
            const lineCoords = layer.getLatLngs(); // Get the coordinates of the LineString

            // Find the closest endpoint of the clicked LineString
            const closestEndpoint = findNearestEndpoint(latlng, lineCoords);

            // Update the starting point field with the closest endpoint
            document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
        });
                }

                if (feature.properties.name === 'usiu border') {
                    usiuBorderLayer = layer;
                }

                if (feature.properties && feature.properties.name) {
        layer.bindPopup(feature.properties.name);
    }
            }
        }).addTo(map);

        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));

// Listen for clicks on the map (anywhere) to get coordinates, even when interacting with features
map.on('click', function(e) {
    var latlng = e.latlng;
    document.getElementById('coordSource').value = `${latlng.lat}, ${latlng.lng}`;
});



        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }

        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        }

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

        // Function to highlight the paths in the shortest route
        function highlightPaths(paths) {
            // Reset all path colors to default
            pathLayers.forEach(layerObj => {
                layerObj.layer.setStyle({
                    color: layerObj.layer.feature.properties.borderColor || '#000',
                    fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
                });

                // Remove previous polylines (if any)
                if (layerObj.polyline) {
                    map.removeLayer(layerObj.polyline);
                }
            });

            // Highlight the paths that are part of the shortest route
            paths.forEach(({ path, from, to }) => {
                const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
                if (matchingLayer) {
                    // Set the color to red for the shortest route
                    matchingLayer.layer.setStyle({ color: 'red' });

                    // Extract the coordinates from the matching path layer and draw a polyline
                    const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

                    const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

                    // Store the polyline on the layer object for potential future cleanup
                    matchingLayer.polyline = polyline;
                }
            });
        }



// Handle search button click for coordSearchBtn
document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat, lng] = coordSource.split(',').map(Number);
    const userLatLng = L.latLng(lat, lng);

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});


// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}



    </script>
</body>
</html>

now i also want to highlight the from the coordinate chosen to the nearest edn point , color it with red as well, so it will show that the path starts from that coordinate, so tell me what to change in the code, and this path to be highlighted should be within the line string and not a straigght line and the path should only appear when the search button is clicked, 



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource1" readonly />
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

       fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name); // Show the feature's name
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'usiu border';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#fff' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                // Capture the click event inside the feature and update coordSource1 and coordSource
                layer.on('click', function(e) {
                    var latlng = e.latlng;

                    // Update coordSource1 with the exact clicked coordinates inside the feature
                    document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

                    // Find the nearest endpoint and update coordSource if it's a LineString
                    if (feature.geometry.type === "LineString") {
                        const lineCoords = layer.getLatLngs();
                        const closestEndpoint = findNearestEndpoint(latlng, lineCoords);
                        if (closestEndpoint) {
                            document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                        }
                    } else {
                        document.getElementById('coordSource').value = ''; // Clear nearest endpoint for non-LineString
                    }

                    // Show the popup with the feature's name
                    layer.bindPopup(feature.properties.name).openPopup();
                });

                // Populate featureSelect with available feature names
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // If the feature is a LineString, add it to pathLayers for later use
                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                // Store the usiuBorder layer for later use
                if (feature.properties.name === 'usiu border') {
                    usiuBorderLayer = layer;
                }
            }
        }).addTo(map);

        // Handle the usiuBorderLayer for masking (if necessary)
        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));

// General map click event for areas outside features
map.on('click', function(e) {
    var latlng = e.latlng;

    // Update coordSource1 with the exact clicked coordinates (outside of features)
    document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

    // Find the nearest endpoint of the LineString and update coordSource
    var nearestEndpoint = findNearestPoint(latlng, featureLayers);
    if (nearestEndpoint && nearestEndpoint.latLng) {
        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
    } else {
        document.getElementById('coordSource').value = 'No nearest endpoint found';
    }
});
    



        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }

        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        }

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

        // Function to highlight the paths in the shortest route
        function highlightPaths(paths) {
            // Reset all path colors to default
            pathLayers.forEach(layerObj => {
                layerObj.layer.setStyle({
                    color: layerObj.layer.feature.properties.borderColor || '#000',
                    fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
                });

                // Remove previous polylines (if any)
                if (layerObj.polyline) {
                    map.removeLayer(layerObj.polyline);
                }
            });

            // Highlight the paths that are part of the shortest route
            paths.forEach(({ path, from, to }) => {
                const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
                if (matchingLayer) {
                    // Set the color to red for the shortest route
                    matchingLayer.layer.setStyle({ color: 'red' });

                    // Extract the coordinates from the matching path layer and draw a polyline
                    const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

                    const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

                    // Store the polyline on the layer object for potential future cleanup
                    matchingLayer.polyline = polyline;
                }
            });
        }


        document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                distanceCell.textContent = distanceBetweenCoords.toFixed(2) + ' meters'; // Show distance between coordSource1 and coordSource
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});


function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2);
}
// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}



    </script>
</body>
</html>




//this will draw the line between the two coordintae

var drawnLine; // To store the polyline and remove it if necessary

document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource1 || !coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Remove the previous line if it exists
    if (drawnLine) {
        map.removeLayer(drawnLine);
    }

    // Draw a red line between coordSource1 and coordSource
    drawnLine = L.polyline([[lat1, lng1], [lat2, lng2]], { color: 'red', weight: 3 }).addTo(map);

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                distanceCell.textContent = distanceBetweenCoords.toFixed(2) + ' meters'; // Show distance between coordSource1 and coordSource
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

// Function to calculate the distance between two points
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2);
}



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource1" readonly />
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

       fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name); // Show the feature's name
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'usiu border';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#fff' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
    // Capture the click event inside the feature and update coordSource1 and coordSource
    layer.on('click', function(e) {
        var latlng = e.latlng;

        // Check if the feature is a LineString, Point, or Polygon and is not 'USIU BORDER'
        if (
            (feature.geometry.type === "LineString" || feature.geometry.type === "Polygon" || feature.geometry.type === "Point") &&
            feature.properties.name !== "USIU BORDER"
        ) {
            // Update coordSource1 with the exact clicked coordinates inside the feature
            document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

            // Find the nearest endpoint and update coordSource if it's a LineString
            if (feature.geometry.type === "LineString") {
                const lineCoords = layer.getLatLngs();
                const closestEndpoint = findNearestEndpoint(latlng, lineCoords);
                if (closestEndpoint) {
                    document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                }
            } else {
                document.getElementById('coordSource').value = ''; // Clear nearest endpoint for non-LineString
            }

        } else {
            // If it's 'USIU BORDER' or not a valid feature, clear the fields
            document.getElementById('coordSource1').value = '';
            document.getElementById('coordSource').value = '';
        }

        // Show the popup with the feature's name
        layer.bindPopup(feature.properties.name).openPopup();
    });





                // Populate featureSelect with available feature names
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // If the feature is a LineString, add it to pathLayers for later use
                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                // Store the usiuBorder layer for later use
                if (feature.properties.name === 'usiu border') {
                    usiuBorderLayer = layer;
                }
            }
        }).addTo(map);

        // Handle the usiuBorderLayer for masking (if necessary)
        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));

// General map click event for areas outside features
map.on('click', function(e) {
    var latlng = e.latlng;

    // Update coordSource1 with the exact clicked coordinates (outside of features)
    document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

    // Find the nearest endpoint of the LineString and update coordSource
    var nearestEndpoint = findNearestPoint(latlng, featureLayers);
    if (nearestEndpoint && nearestEndpoint.latLng) {
        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
    } else {
        document.getElementById('coordSource').value = 'No nearest endpoint found';
    }
});
    



        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }

        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        }

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

        // Function to highlight the paths in the shortest route
        function highlightPaths(paths) {
            // Reset all path colors to default
            pathLayers.forEach(layerObj => {
                layerObj.layer.setStyle({
                    color: layerObj.layer.feature.properties.borderColor || '#000',
                    fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
                });

                // Remove previous polylines (if any)
                if (layerObj.polyline) {
                    map.removeLayer(layerObj.polyline);
                }
            });

            // Highlight the paths that are part of the shortest route
            paths.forEach(({ path, from, to }) => {
                const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
                if (matchingLayer) {
                    // Set the color to red for the shortest route
                    matchingLayer.layer.setStyle({ color: 'red' });

                    // Extract the coordinates from the matching path layer and draw a polyline
                    const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

                    const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

                    // Store the polyline on the layer object for potential future cleanup
                    matchingLayer.polyline = polyline;
                }
            });
        }


        document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                distanceCell.textContent = distanceBetweenCoords.toFixed(2) + ' meters'; // Show distance between coordSource1 and coordSource
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});


function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2);
}
// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}



    </script>
</body>
</html>




 onEachFeature: function (feature, layer) {
    // Capture the click event inside the feature and update coordSource1 and coordSource
    layer.on('click', function(e) {
        var latlng = e.latlng;

        // Check if the feature is a LineString, Point, or Polygon and is not 'USIU BORDER'
        if (
            (feature.geometry.type === "LineString" || feature.geometry.type === "Polygon" || feature.geometry.type === "Point") &&
            feature.properties.name !== "USIU BORDER"
        ) {
            // Update coordSource1 with the exact clicked coordinates inside the feature
            document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

            // Find the nearest endpoint and update coordSource if it's a LineString
            if (feature.geometry.type === "LineString") {
                const lineCoords = layer.getLatLngs();
                const closestEndpoint = findNearestEndpoint(latlng, lineCoords);
                if (closestEndpoint) {
                    document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                }
            } else {
                document.getElementById('coordSource').value = ''; // Clear nearest endpoint for non-LineString
            }

        } else {
            // If it's 'USIU BORDER' or not a valid feature, clear the fields
            document.getElementById('coordSource1').value = '';
            document.getElementById('coordSource').value = '';
        }

        // Show the popup with the feature's name
        layer.bindPopup(feature.properties.name).openPopup();
    });





                // Populate featureSelect with available feature names
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // If the feature is a LineString, add it to pathLayers for later use
                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                // Store the usiuBorder layer for later use
                if (feature.properties.name === 'usiu border') {
                    usiuBorderLayer = layer;
                }
            }
        }).addTo(map);

      





 onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });

                    layer.on('click', function (e) {
            var latlng = e.latlng; // Get the coordinates of the clicked point
            const lineCoords = layer.getLatLngs(); // Get the coordinates of the LineString

            // Find the closest endpoint of the clicked LineString
            const closestEndpoint = findNearestEndpoint(latlng, lineCoords);

            // Update the starting point field with the closest endpoint
            document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
        });
                }

                if (feature.properties.name === 'usiu border') {
                    usiuBorderLayer = layer;
                }

                if (feature.properties && feature.properties.name) {
        layer.bindPopup(feature.properties.name);
    }
            }
        }).addTo(map);

       


WORKING<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource1" readonly />
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name);
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'usiu border';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#fff' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // Register live coordinates for any clicked feature
                layer.on('click', function (e) {
                    var latlng = e.latlng; // Get the coordinates of the clicked point

                    // Update the first input with live coordinates of the clicked point
                    document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

                    // Handle LineString features for nearest endpoint
                    if (feature.geometry.type === "LineString") {
                        const lineCoords = layer.getLatLngs(); // Get the coordinates of the LineString

                        // Find the closest endpoint of the clicked LineString
                        const closestEndpoint = findNearestEndpoint(latlng, lineCoords);

                        // Update the second input with the closest endpoint of the LineString
                        document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                    }
                });

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                if (feature.properties.name === 'usiu border') {
                    usiuBorderLayer = layer;
                }

                if (feature.properties && feature.properties.name) {
                    layer.bindPopup(feature.properties.name);
                }
            }
        }).addTo(map);

        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));


// General map click event for areas outside features
map.on('click', function(e) {
    var latlng = e.latlng;

    // Update the first input with the live coordinates (regardless of feature)
    document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

    // Find the nearest endpoint of the LineString and update coordSource (second input)
    var nearestEndpoint = findNearestPoint(latlng, featureLayers);
    if (nearestEndpoint && nearestEndpoint.latLng) {
        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
    } else {
        document.getElementById('coordSource').value = 'No nearest endpoint found';
    }
});
  



        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }

        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        }

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

        // Function to highlight the paths in the shortest route
        function highlightPaths(paths) {
            // Reset all path colors to default
            pathLayers.forEach(layerObj => {
                layerObj.layer.setStyle({
                    color: layerObj.layer.feature.properties.borderColor || '#000',
                    fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
                });

                // Remove previous polylines (if any)
                if (layerObj.polyline) {
                    map.removeLayer(layerObj.polyline);
                }
            });

            // Highlight the paths that are part of the shortest route
            paths.forEach(({ path, from, to }) => {
                const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
                if (matchingLayer) {
                    // Set the color to red for the shortest route
                    matchingLayer.layer.setStyle({ color: 'red' });

                    // Extract the coordinates from the matching path layer and draw a polyline
                    const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

                    const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

                    // Store the polyline on the layer object for potential future cleanup
                    matchingLayer.polyline = polyline;
                }
            });
        }



        document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                distanceCell.textContent = distanceBetweenCoords.toFixed(2) + ' meters'; // Show distance between coordSource1 and coordSource
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}



    </script>
</body>
</html>



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource1" readonly />
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name);
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'USIU BORDER';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#27a147 ' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // Register live coordinates for any clicked feature except 'USIU BORDER'
                layer.on('click', function (e) {
                    var latlng = e.latlng; // Get the coordinates of the clicked point

                    // Handle 'USIU BORDER' clicks (clear inputs)
                    if (feature.properties.name === 'USIU BORDER') {
                        document.getElementById('coordSource1').value = '';
                        document.getElementById('coordSource').value = '';
                        return; // Exit, no further processing for USIU BORDER
                    }

                    // Handle LineString or Polygon features (excluding 'USIU BORDER')
                    if (feature.geometry.type === "LineString" || feature.geometry.type === "Polygon") {
                        // Update the first input with live coordinates of the clicked point
                        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

                        // Handle LineString features for nearest endpoint
                        if (feature.geometry.type === "LineString") {
                            const lineCoords = layer.getLatLngs(); // Get the coordinates of the LineString

                            // Find the closest endpoint of the clicked LineString
                            const closestEndpoint = findNearestEndpoint(latlng, lineCoords);

                            // Update the second input with the closest endpoint of the LineString
                            document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                        } else {
                            // Clear coordSource input for Polygons, as no nearest endpoint is needed
                            document.getElementById('coordSource').value = '';
                        }
                    }
                });

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                if (feature.properties && feature.properties.name) {
                    layer.bindPopup(feature.properties.name);
                }
            }
        }).addTo(map);

        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));


// General map click event to capture valid live coordinates within LineStrings or Polygons only
map.on('click', function(e) {
    var latlng = e.latlng;

    // Reset the validity flag
    var isValidFeature = false;

    // Loop through the featureLayers to check if clicked on LineString or Polygon (excluding 'USIU BORDER')
    featureLayers.forEach(function(featureLayer) {
        // Exclude "USIU BORDER" explicitly
        if (featureLayer.name === 'USIU BORDER') {
            return; // Skip processing for USIU BORDER
        }

        // Handle LineStrings
        if (featureLayer.featureType === 'LineString') {
            const lineCoords = featureLayer.layer.getLatLngs();
            const nearestEndpoint = findNearestEndpoint(latlng, lineCoords);
            const distanceToNearest = calculateDistance(latlng, nearestEndpoint);

            // Check if click is near the LineString (adjust distance threshold as needed)
            if (distanceToNearest < 10) {
                isValidFeature = true; // Valid LineString feature clicked
            }
        }
        // Handle Polygons
        else if (featureLayer.featureType === 'Polygon') {
            if (featureLayer.layer.getBounds().contains(latlng)) {
                isValidFeature = true; // Valid Polygon feature clicked
            }
        }
    });

    // If the click was on a valid LineString or Polygon (excluding USIU BORDER), update the coordSource1 with live coordinates
    if (isValidFeature) {
        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;
    } else {
        // If the click was outside valid features or on 'USIU BORDER', clear the input
        document.getElementById('coordSource1').value = '';
        document.getElementById('coordSource').value = '';
    }

    // Find the nearest endpoint of the LineString and update coordSource (second input)
    var nearestEndpoint = findNearestPoint(latlng, featureLayers);
    if (nearestEndpoint && nearestEndpoint.latLng) {
        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
    } else {
        document.getElementById('coordSource').value = 'No nearest endpoint found';
    }
});



        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }

        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        }

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

function highlightPaths(paths) {
    // Reset all path colors to default
    pathLayers.forEach(layerObj => {
        layerObj.layer.setStyle({
            color: layerObj.layer.feature.properties.borderColor || '#000',
            fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
        });

        // Remove previous polylines (if any)
        if (layerObj.polyline) {
            map.removeLayer(layerObj.polyline);
        }
    });

    // Highlight the paths that are part of the shortest route
    paths.forEach(({ path, from, to }) => {
        const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
        if (matchingLayer) {
            // Set the color to red for the shortest route
            matchingLayer.layer.setStyle({ color: 'red' });

            // Extract the coordinates from the matching path layer and draw a polyline
            const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

            const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

            // Store the polyline on the layer object for potential future cleanup
            matchingLayer.polyline = polyline;
        }
    });

    // Highlight the segment of the path from live coordinate to the nearest endpoint
    const liveCoord = document.getElementById('coordSource1').value.split(',').map(Number);
    const liveLatLng = L.latLng(liveCoord[0], liveCoord[1]);

    const nearestEndpoint = document.getElementById('coordSource').value.split(',').map(Number);
    const nearestLatLng = L.latLng(nearestEndpoint[0], nearestEndpoint[1]);

    // Loop through path layers to find the path that contains both live coordinate and nearest endpoint
    pathLayers.forEach(layerObj => {
        const lineCoords = layerObj.layer.getLatLngs();

        // Check if both live coordinate and nearest endpoint are on the same LineString
        const isLiveOnPath = lineCoords.some(coord => calculateDistance(liveLatLng, coord) < 10); // Adjust threshold as needed
        const isNearestOnPath = lineCoords.some(coord => calculateDistance(nearestLatLng, coord) < 10); // Adjust threshold as needed

        if (isLiveOnPath && isNearestOnPath) {
            // Find the closest point along the LineString to the live coordinate
            let startIdx = findClosestPointIndex(liveLatLng, lineCoords);

            // Find the closest point along the LineString to the nearest endpoint
            let endIdx = findClosestPointIndex(nearestLatLng, lineCoords);

            // Ensure that startIdx is less than endIdx (if not, swap them)
            if (startIdx > endIdx) {
                [startIdx, endIdx] = [endIdx, startIdx];
            }

            // Extract the segment from startIdx to endIdx
            const segmentCoords = lineCoords.slice(startIdx, endIdx + 1);

            // Draw the polyline for the segment in red
            const segmentPolyline = L.polyline(segmentCoords, { color: 'red', weight: 3 }).addTo(map);

            // Store the polyline on the layer object for potential future cleanup
            layerObj.polyline = segmentPolyline;
        }
    });
}

// Helper function to find the index of the closest point in a LineString
function findClosestPointIndex(latlng, lineCoords) {
    let closestIndex = 0;
    let shortestDistance = Infinity;

    lineCoords.forEach((coord, index) => {
        const distance = calculateDistance(latlng, coord);
        if (distance < shortestDistance) {
            shortestDistance = distance;
            closestIndex = index;
        }
    });

    return closestIndex;
}




        document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                distanceCell.textContent = distanceBetweenCoords.toFixed(2) + ' meters'; // Show distance between coordSource1 and coordSource
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}



    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource1" readonly />
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name);
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'USIU BORDER';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#27a147 ' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // Register live coordinates for any clicked feature except 'USIU BORDER'
                layer.on('click', function (e) {
                    var latlng = e.latlng; // Get the coordinates of the clicked point

                    // Handle 'USIU BORDER' clicks (clear inputs)
                    if (feature.properties.name === 'USIU BORDER') {
                        document.getElementById('coordSource1').value = '';
                        document.getElementById('coordSource').value = '';
                        return; // Exit, no further processing for USIU BORDER
                    }

                    // Handle LineString or Polygon features (excluding 'USIU BORDER')
                    if (feature.geometry.type === "LineString" || feature.geometry.type === "Polygon") {
                        // Update the first input with live coordinates of the clicked point
                        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

                        // Handle LineString features for nearest endpoint
                        if (feature.geometry.type === "LineString") {
                            const lineCoords = layer.getLatLngs(); // Get the coordinates of the LineString

                            // Find the closest endpoint of the clicked LineString
                            const closestEndpoint = findNearestEndpoint(latlng, lineCoords);

                            // Update the second input with the closest endpoint of the LineString
                            document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                        } else {
                            // Clear coordSource input for Polygons, as no nearest endpoint is needed
                            document.getElementById('coordSource').value = '';
                        }
                    }
                });

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                if (feature.properties && feature.properties.name) {
                    layer.bindPopup(feature.properties.name);
                }
            }
        }).addTo(map);

        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));


// General map click event to capture valid live coordinates within LineStrings or Polygons only
map.on('click', function(e) {
    var latlng = e.latlng;

    // Reset the validity flag
    var isValidFeature = false;

    // Loop through the featureLayers to check if clicked on LineString or Polygon (excluding 'USIU BORDER')
    featureLayers.forEach(function(featureLayer) {
        // Exclude "USIU BORDER" explicitly
        if (featureLayer.name === 'USIU BORDER') {
            return; // Skip processing for USIU BORDER
        }

        // Handle LineStrings
        if (featureLayer.featureType === 'LineString') {
            const lineCoords = featureLayer.layer.getLatLngs();
            const nearestEndpoint = findNearestEndpoint(latlng, lineCoords);
            const distanceToNearest = calculateDistance(latlng, nearestEndpoint);

            // Check if click is near the LineString (adjust distance threshold as needed)
            if (distanceToNearest < 10) {
                isValidFeature = true; // Valid LineString feature clicked
            }
        }
        // Handle Polygons
        else if (featureLayer.featureType === 'Polygon') {
            if (featureLayer.layer.getBounds().contains(latlng)) {
                isValidFeature = true; // Valid Polygon feature clicked
            }
        }
    });

    // If the click was on a valid LineString or Polygon (excluding USIU BORDER), update the coordSource1 with live coordinates
    if (isValidFeature) {
        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;
    } else {
        // If the click was outside valid features or on 'USIU BORDER', clear the input
        document.getElementById('coordSource1').value = '';
        document.getElementById('coordSource').value = '';
    }

    // Find the nearest endpoint of the LineString and update coordSource (second input)
    var nearestEndpoint = findNearestPoint(latlng, featureLayers);
    if (nearestEndpoint && nearestEndpoint.latLng) {
        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
    } else {
        document.getElementById('coordSource').value = 'No nearest endpoint found';
    }
});



        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }

        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        }

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

function highlightPaths(paths) {
    // Reset all path colors to default
    pathLayers.forEach(layerObj => {
        layerObj.layer.setStyle({
            color: layerObj.layer.feature.properties.borderColor || '#000',
            fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
        });

        // Remove previous polylines (if any)
        if (layerObj.polyline) {
            map.removeLayer(layerObj.polyline);
        }
    });

    // Highlight the paths that are part of the shortest route
    paths.forEach(({ path, from, to }) => {
        const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
        if (matchingLayer) {
            // Set the color to red for the shortest route
            matchingLayer.layer.setStyle({ color: 'red' });

            // Extract the coordinates from the matching path layer and draw a polyline
            const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

            const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

            // Store the polyline on the layer object for potential future cleanup
            matchingLayer.polyline = polyline;
        }
    });

    // Highlight the path where live coordinate lies
    const liveCoord = document.getElementById('coordSource1').value.split(',').map(Number);
    const liveLatLng = L.latLng(liveCoord[0], liveCoord[1]);

    const livePathLayer = findPathContainingLiveCoordinate(liveLatLng);
    if (livePathLayer) {
        livePathLayer.setStyle({ color: 'red' });  // Highlight the path where live coordinate lies in blue
    }
}
// Function to interpolate between two coordinates
function interpolateCoordinates(coord1, coord2, numPoints) {
    let interpolatedPoints = [];
    let latDiff = (coord2[1] - coord1[1]) / numPoints;
    let lngDiff = (coord2[0] - coord1[0]) / numPoints;

    for (let i = 0; i <= numPoints; i++) {
        let interpolatedLat = coord1[1] + (i * latDiff);
        let interpolatedLng = coord1[0] + (i * lngDiff);
        interpolatedPoints.push([interpolatedLng, interpolatedLat]); // Skip the 0 for simplicity here
    }

    return interpolatedPoints;
}

// Function to extract all coordinates including interpolated points
function extractCoordinates(lineCoords, numInterpolatedPoints) {
    let allCoordinates = [];

    for (let i = 0; i < lineCoords.length - 1; i++) {
        let coord1 = [lineCoords[i].lng, lineCoords[i].lat];
        let coord2 = [lineCoords[i + 1].lng, lineCoords[i + 1].lat];
        let segmentPoints = interpolateCoordinates(coord1, coord2, numInterpolatedPoints);
        allCoordinates = allCoordinates.concat(segmentPoints);
    }

    return allCoordinates;
}

// Function to calculate the distance between two coordinates
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Function to find the closest interpolated point to the live coordinate
function findClosestInterpolatedPoint(liveCoord, interpolatedPoints) {
    let closestPoint = null;
    let shortestDistance = Infinity;

    interpolatedPoints.forEach(point => {
        let pointLatLng = L.latLng(point[1], point[0]);
        let distance = calculateDistance(liveCoord, pointLatLng);
        if (distance < shortestDistance) {
            shortestDistance = distance;
            closestPoint = point;
        }
    });

    return closestPoint;
}

let liveCircle = null;
let closestCircle = null;

// Modified function to find the closest path and log the required information
function findPathContainingLiveCoordinate(liveLatLng) {
    let foundLayer = null;
    let closestPath = null;
    let shortestDistance = Infinity; // Start with an infinitely large distance

    // Clear any existing circles before drawing new ones
    if (liveCircle) {
        map.removeLayer(liveCircle);
    }
    if (closestCircle) {
        map.removeLayer(closestCircle);
    }

    pathLayers.forEach(layerObj => {
        const lineCoords = layerObj.layer.getLatLngs();

        // Loop through the coordinates of each path
        for (let i = 0; i < lineCoords.length; i++) {
            const distance = calculateDistance(liveLatLng, lineCoords[i]);

            // Check if the distance is smaller than our threshold and if it's the smallest so far
            if (distance < 5 && distance < shortestDistance) { // Adjust threshold as necessary
                foundLayer = layerObj.layer;
                shortestDistance = distance; // Update the shortest distance
                closestPath = layerObj; // Keep track of the closest path
            }
        }
    });

    // If a closest path was found, proceed with marking the points
    if (closestPath) {
        const lineCoords = closestPath.layer.getLatLngs();

        // Get all the coordinates (including interpolated) on this path
        const interpolatedPoints = extractCoordinates(lineCoords, 1000);

        // Find the closest interpolated point to the live coordinate
        const closestPoint = findClosestInterpolatedPoint(liveLatLng, interpolatedPoints);

        // Log the path name, live coordinate, and the closest interpolated point to the console
        console.log(`Path name: ${closestPath.name}`);
        console.log(`Live coordinate: ${liveLatLng.lat}, ${liveLatLng.lng}`);
        console.log(`Closest interpolated point: ${closestPoint[1]}, ${closestPoint[0]}`);

        // Draw the red circle for the live coordinate (small size)
        liveCircle = L.circle(liveLatLng, {
            color: 'red',
            fillColor: '#f03',
            fillOpacity: 0.5,
            radius: 0.1  // Small radius
        }).addTo(map);

        // Draw the blue circle for the closest interpolated point (small size)
        closestCircle = L.circle([closestPoint[1], closestPoint[0]], {
            color: 'blue',
            fillColor: '#03f',
            fillOpacity: 0.5,
            radius: 0.1  // Small radius
        }).addTo(map);
    }

    return foundLayer;
}


        document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                distanceCell.textContent = distanceBetweenCoords.toFixed(2) + ' meters'; // Show distance between coordSource1 and coordSource
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}



    </script>
</body>
</html>




<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource1" readonly />
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name);
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'USIU BORDER';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#27a147 ' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // Register live coordinates for any clicked feature except 'USIU BORDER'
                layer.on('click', function (e) {
                    var latlng = e.latlng; // Get the coordinates of the clicked point

                    // Handle 'USIU BORDER' clicks (clear inputs)
                    if (feature.properties.name === 'USIU BORDER') {
                        document.getElementById('coordSource1').value = '';
                        document.getElementById('coordSource').value = '';
                        return; // Exit, no further processing for USIU BORDER
                    }

                    // Handle LineString or Polygon features (excluding 'USIU BORDER')
                    if (feature.geometry.type === "LineString" || feature.geometry.type === "Polygon") {
                        // Update the first input with live coordinates of the clicked point
                        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

                        // Handle LineString features for nearest endpoint
                        if (feature.geometry.type === "LineString") {
                            const lineCoords = layer.getLatLngs(); // Get the coordinates of the LineString

                            // Find the closest endpoint of the clicked LineString
                            const closestEndpoint = findNearestEndpoint(latlng, lineCoords);

                            // Update the second input with the closest endpoint of the LineString
                            document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                        } else {
                            // Clear coordSource input for Polygons, as no nearest endpoint is needed
                            document.getElementById('coordSource').value = '';
                        }
                    }
                });

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                if (feature.properties && feature.properties.name) {
                    layer.bindPopup(feature.properties.name);
                }
            }
        }).addTo(map);

        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));


// General map click event to capture valid live coordinates within LineStrings or Polygons only
map.on('click', function(e) {
    var latlng = e.latlng;

    // Reset the validity flag
    var isValidFeature = false;

    // Loop through the featureLayers to check if clicked on LineString or Polygon (excluding 'USIU BORDER')
    featureLayers.forEach(function(featureLayer) {
        // Exclude "USIU BORDER" explicitly
        if (featureLayer.name === 'USIU BORDER') {
            return; // Skip processing for USIU BORDER
        }

        // Handle LineStrings
        if (featureLayer.featureType === 'LineString') {
            const lineCoords = featureLayer.layer.getLatLngs();
            const nearestEndpoint = findNearestEndpoint(latlng, lineCoords);
            const distanceToNearest = calculateDistance(latlng, nearestEndpoint);

            // Check if click is near the LineString (adjust distance threshold as needed)
            if (distanceToNearest < 10) {
                isValidFeature = true; // Valid LineString feature clicked
            }
        }
        // Handle Polygons
        else if (featureLayer.featureType === 'Polygon') {
            if (featureLayer.layer.getBounds().contains(latlng)) {
                isValidFeature = true; // Valid Polygon feature clicked
            }
        }
    });

    // If the click was on a valid LineString or Polygon (excluding USIU BORDER), update the coordSource1 with live coordinates
    if (isValidFeature) {
        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;
    } else {
        // If the click was outside valid features or on 'USIU BORDER', clear the input
        document.getElementById('coordSource1').value = '';
        document.getElementById('coordSource').value = '';
    }

    // Find the nearest endpoint of the LineString and update coordSource (second input)
    var nearestEndpoint = findNearestPoint(latlng, featureLayers);
    if (nearestEndpoint && nearestEndpoint.latLng) {
        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
    } else {
        document.getElementById('coordSource').value = 'No nearest endpoint found';
    }
});



        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }

        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        }

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

function highlightPaths(paths) {
    // Reset all path colors to default
    pathLayers.forEach(layerObj => {
        layerObj.layer.setStyle({
            color: layerObj.layer.feature.properties.borderColor || '#000',
            fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
        });

        // Remove previous polylines (if any)
        if (layerObj.polyline) {
            map.removeLayer(layerObj.polyline);
        }
    });

    // Highlight the paths that are part of the shortest route
    paths.forEach(({ path, from, to }) => {
        const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
        if (matchingLayer) {
            // Set the color to red for the shortest route
            matchingLayer.layer.setStyle({ color: 'red' });

            // Extract the coordinates from the matching path layer and draw a polyline
            const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

            const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

            // Store the polyline on the layer object for potential future cleanup
            matchingLayer.polyline = polyline;
        }
    });

    // Highlight the path where live coordinate lies
    const liveCoord = document.getElementById('coordSource1').value.split(',').map(Number);
    const liveLatLng = L.latLng(liveCoord[0], liveCoord[1]);

    const livePathLayer = findPathContainingLiveCoordinate(liveLatLng);
    if (livePathLayer) {
        livePathLayer.setStyle({ color: 'yellow' });  // Highlight the path where live coordinate lies in blue
    }
}
// Function to interpolate between two coordinates
function interpolateCoordinates(coord1, coord2, numPoints) {
    let interpolatedPoints = [];
    let latDiff = (coord2[1] - coord1[1]) / numPoints;
    let lngDiff = (coord2[0] - coord1[0]) / numPoints;

    for (let i = 0; i <= numPoints; i++) {
        let interpolatedLat = coord1[1] + (i * latDiff);
        let interpolatedLng = coord1[0] + (i * lngDiff);
        interpolatedPoints.push([interpolatedLng, interpolatedLat]); // Skip the 0 for simplicity here
    }

    return interpolatedPoints;
}

// Function to extract all coordinates including interpolated points
function extractCoordinates(lineCoords, numInterpolatedPoints) {
    let allCoordinates = [];

    for (let i = 0; i < lineCoords.length - 1; i++) {
        let coord1 = [lineCoords[i].lng, lineCoords[i].lat];
        let coord2 = [lineCoords[i + 1].lng, lineCoords[i + 1].lat];
        let segmentPoints = interpolateCoordinates(coord1, coord2, numInterpolatedPoints);
        allCoordinates = allCoordinates.concat(segmentPoints);
    }

    return allCoordinates;
}

// Function to calculate the distance between two coordinates
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Function to find the closest interpolated point to the live coordinate
function findClosestInterpolatedPoint(liveCoord, interpolatedPoints) {
    let closestPoint = null;
    let shortestDistance = Infinity;

    interpolatedPoints.forEach(point => {
        let pointLatLng = L.latLng(point[1], point[0]);
        let distance = calculateDistance(liveCoord, pointLatLng);
        if (distance < shortestDistance) {
            shortestDistance = distance;
            closestPoint = point;
        }
    });

    return closestPoint;
}

let liveCircle = null;
let closestCircle = null;
// Modified function to find the closest path and log the required information
function findPathContainingLiveCoordinate(liveLatLng) {
    let foundLayer = null;
    let closestPath = null;
    let shortestDistance = Infinity; // Start with an infinitely large distance

    // Clear any existing circles before drawing new ones
    if (liveCircle) {
        map.removeLayer(liveCircle);
    }
    if (closestCircle) {
        map.removeLayer(closestCircle);
    }

    pathLayers.forEach(layerObj => {
        const lineCoords = layerObj.layer.getLatLngs();

        // Loop through the coordinates of each path
        for (let i = 0; i < lineCoords.length; i++) {
            const distance = calculateDistance(liveLatLng, lineCoords[i]);

            // Check if the distance is smaller than our threshold and if it's the smallest so far
            if (distance < 5 && distance < shortestDistance) { // Adjust threshold as necessary
                foundLayer = layerObj.layer;
                shortestDistance = distance; // Update the shortest distance
                closestPath = layerObj; // Keep track of the closest path
            }
        }
    });

    // If a closest path was found, proceed with marking the points
    if (closestPath) {
        const lineCoords = closestPath.layer.getLatLngs();

        // Get all the coordinates (including interpolated) on this path
        const interpolatedPoints = extractCoordinates(lineCoords, 1000);

        // Find the closest interpolated point to the live coordinate
        const closestPoint = findClosestInterpolatedPoint(liveLatLng, interpolatedPoints);

        // Log the path name, live coordinate, and the closest interpolated point to the console
        console.log(`Path name: ${closestPath.name}`);
        console.log(`Live coordinate: ${liveLatLng.lat}, ${liveLatLng.lng}`);
        console.log(`Closest interpolated point: ${closestPoint[1]}, ${closestPoint[0]}`);

        // Draw the red circle for the live coordinate (small size)
        liveCircle = L.circle(liveLatLng, {
            color: 'red',
            fillColor: '#f03',
            fillOpacity: 0.5,
            radius: 0.1  // Small radius
        }).addTo(map);

        // Draw the blue circle for the closest interpolated point (small size)
        closestCircle = L.circle([closestPoint[1], closestPoint[0]], {
            color: 'blue',
            fillColor: '#03f',
            fillOpacity: 0.5,
            radius: 0.1  // Small radius
        }).addTo(map);

        // Highlight only the path segment between the live coordinate and the closest interpolated point
        const segmentToHighlight = [];
        let highlightSegment = false;

        // Collect the segment from the nearest interpolated point to the endpoint of the path
        for (let i = 0; i < interpolatedPoints.length; i++) {
            const pointLatLng = L.latLng(interpolatedPoints[i][1], interpolatedPoints[i][0]);
            
            // Start highlighting from the nearest interpolated point
            if (pointLatLng.equals(L.latLng(closestPoint[1], closestPoint[0]))) {
                highlightSegment = true;
            }

            if (highlightSegment) {
                segmentToHighlight.push([pointLatLng.lat, pointLatLng.lng]);
            }
        }

        // Draw a polyline for the highlighted segment (green for the new path)
        const polyline = L.polyline(segmentToHighlight, {
            color: 'green',  // Highlight the segment in green
            weight: 3
        }).addTo(map);
    }

    return foundLayer;
}

        document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                distanceCell.textContent = distanceBetweenCoords.toFixed(2) + ' meters'; // Show distance between coordSource1 and coordSource
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}



    </script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource1" readonly />
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name);
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'USIU BORDER';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#27a147 ' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // Register live coordinates for any clicked feature except 'USIU BORDER'
                layer.on('click', function (e) {
                    var latlng = e.latlng; // Get the coordinates of the clicked point

                    // Handle 'USIU BORDER' clicks (clear inputs)
                    if (feature.properties.name === 'USIU BORDER') {
                        document.getElementById('coordSource1').value = '';
                        document.getElementById('coordSource').value = '';
                        return; // Exit, no further processing for USIU BORDER
                    }

                    // Handle LineString or Polygon features (excluding 'USIU BORDER')
                    if (feature.geometry.type === "LineString" || feature.geometry.type === "Polygon") {
                        // Update the first input with live coordinates of the clicked point
                        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

                        // Handle LineString features for nearest endpoint
                        if (feature.geometry.type === "LineString") {
                            const lineCoords = layer.getLatLngs(); // Get the coordinates of the LineString

                            // Find the closest endpoint of the clicked LineString
                            const closestEndpoint = findNearestEndpoint(latlng, lineCoords);

                            // Update the second input with the closest endpoint of the LineString
                            document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                        } else {
                            // Clear coordSource input for Polygons, as no nearest endpoint is needed
                            document.getElementById('coordSource').value = '';
                        }
                    }
                });

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                if (feature.properties && feature.properties.name) {
                    layer.bindPopup(feature.properties.name);
                }
            }
        }).addTo(map);

        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));


// General map click event to capture valid live coordinates within LineStrings or Polygons only
map.on('click', function(e) {
    var latlng = e.latlng;

    // Reset the validity flag
    var isValidFeature = false;

    // Loop through the featureLayers to check if clicked on LineString or Polygon (excluding 'USIU BORDER')
    featureLayers.forEach(function(featureLayer) {
        // Exclude "USIU BORDER" explicitly
        if (featureLayer.name === 'USIU BORDER') {
            return; // Skip processing for USIU BORDER
        }

        // Handle LineStrings
        if (featureLayer.featureType === 'LineString') {
            const lineCoords = featureLayer.layer.getLatLngs();
            const nearestEndpoint = findNearestEndpoint(latlng, lineCoords);
            const distanceToNearest = calculateDistance(latlng, nearestEndpoint);

            // Check if click is near the LineString (adjust distance threshold as needed)
            if (distanceToNearest < 10) {
                isValidFeature = true; // Valid LineString feature clicked
            }
        }
        // Handle Polygons
        else if (featureLayer.featureType === 'Polygon') {
            if (featureLayer.layer.getBounds().contains(latlng)) {
                isValidFeature = true; // Valid Polygon feature clicked
            }
        }
    });

    // If the click was on a valid LineString or Polygon (excluding USIU BORDER), update the coordSource1 with live coordinates
    if (isValidFeature) {
        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;
    } else {
        // If the click was outside valid features or on 'USIU BORDER', clear the input
        document.getElementById('coordSource1').value = '';
        document.getElementById('coordSource').value = '';
    }

    // Find the nearest endpoint of the LineString and update coordSource (second input)
    var nearestEndpoint = findNearestPoint(latlng, featureLayers);
    if (nearestEndpoint && nearestEndpoint.latLng) {
        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
    } else {
        document.getElementById('coordSource').value = 'No nearest endpoint found';
    }
});



        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }

        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        }

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

function highlightPaths(paths) {
            // Reset all path colors to default
            pathLayers.forEach(layerObj => {
                layerObj.layer.setStyle({
                    color: layerObj.layer.feature.properties.borderColor || '#000',
                    fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
                });

                // Remove previous polylines (if any)
                if (layerObj.polyline) {
                    map.removeLayer(layerObj.polyline);
                }
            });

            // Highlight the paths that are part of the shortest route
            paths.forEach(({ path, from, to }) => {
                const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
                if (matchingLayer) {
                    // Set the color to red for the shortest route
                    matchingLayer.layer.setStyle({ color: 'red' });

                    // Extract the coordinates from the matching path layer and draw a polyline
                    const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

                    const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

                    // Store the polyline on the layer object for potential future cleanup
                    matchingLayer.polyline = polyline;
                }
            });
        }




        document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                distanceCell.textContent = distanceBetweenCoords.toFixed(2) + ' meters'; // Show distance between coordSource1 and coordSource
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}



    </script>
</body>
</html>


document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const liveLatLng = L.latLng(lat1, lng1);  // Live coordinate (coordSource1)

    // Find and log the path where live coordinate belongs
    const pathLayer = findPathContainingLiveCoordinate(liveLatLng); // Add this call to log the path

    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // If a valid pathLayer is found, proceed to extract coordinates and display them
    if (pathLayer) {
        const lineCoords = pathLayer.getLatLngs();
        
        // Extract all the coordinates from the path (with interpolation)
        const extractedCoords = extractCoordinates(lineCoords, 1000); // You can adjust the number of interpolated points
        
        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
        
        // Find the nearest endpoint to the live coordinate
        const nearestEndpoint = findNearestEndpoint(liveLatLng, lineCoords);

        // Find the index of the closest interpolated point and nearest endpoint in the extracted coordinates
        const closestIndex = extractedCoords.findIndex(coord =>
            coord[0] === closestInterpolatedPoint[0] && coord[1] === closestInterpolatedPoint[1]);
        const nearestIndex = extractedCoords.findIndex(coord =>
            coord[0] === nearestEndpoint.lng && coord[1] === nearestEndpoint.lat);

        // Ensure the indices are valid and log the range of coordinates between them
        if (closestIndex !== -1 && nearestIndex !== -1) {
            const startIndex = Math.min(closestIndex, nearestIndex);
            const endIndex = Math.max(closestIndex, nearestIndex);

            console.log('Coordinates between the closest interpolated point and the nearest endpoint:');
            
            // Store the coordinates to connect them with a polyline
            const coordsToConnect = [];
            for (let i = startIndex; i <= endIndex; i++) {
                console.log(`Latitude: ${extractedCoords[i][1]}, Longitude: ${extractedCoords[i][0]}`);
                coordsToConnect.push([extractedCoords[i][1], extractedCoords[i][0]]);  // Store the coordinate in [lat, lng] format
            }

            // Draw a black polyline connecting the coordinates (new polyline)
            L.polyline(coordsToConnect, { color: 'black', weight: 3 }).addTo(map);

        } else {
            console.log('Could not find valid indices for closest point or nearest endpoint.');
        }
    } else {
        console.log('No matching path found for the live coordinate.');
    }

    // Existing polyline functions that highlight paths
    fetch(`/shortest-path?source=${coordSource}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                distanceCell.textContent = distanceBetweenCoords.toFixed(2) + ' meters'; // Show distance between coordSource1 and coordSource
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    let directionCell = document.createElement('td');
                    directionCell.textContent = '';  // Leave directions blank for now
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // Highlight paths on the map (existing polyline function)
                highlightPaths(result.path);
                
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource1" readonly />
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name);
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'USIU BORDER';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#27a147 ' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // Register live coordinates for any clicked feature except 'USIU BORDER'
                layer.on('click', function (e) {
                    var latlng = e.latlng; // Get the coordinates of the clicked point

                    // Handle 'USIU BORDER' clicks (clear inputs)
                    if (feature.properties.name === 'USIU BORDER') {
                        document.getElementById('coordSource1').value = '';
                        document.getElementById('coordSource').value = '';
                        return; // Exit, no further processing for USIU BORDER
                    }

                    // Handle LineString or Polygon features (excluding 'USIU BORDER')
                    if (feature.geometry.type === "LineString" || feature.geometry.type === "Polygon") {
                        // Update the first input with live coordinates of the clicked point
                        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

                        // Handle LineString features for nearest endpoint
                        if (feature.geometry.type === "LineString") {
                            const lineCoords = layer.getLatLngs(); // Get the coordinates of the LineString

                            // Find the closest endpoint of the clicked LineString
                            const closestEndpoint = findNearestEndpoint(latlng, lineCoords);

                            // Update the second input with the closest endpoint of the LineString
                            document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                        } else {
                            // Clear coordSource input for Polygons, as no nearest endpoint is needed
                            document.getElementById('coordSource').value = '';
                        }
                    }
                });

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                if (feature.properties && feature.properties.name) {
                    layer.bindPopup(feature.properties.name);
                }
            }
        }).addTo(map);

        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));


    map.on('click', function(e) {
    var latlng = e.latlng;

    // Reset the validity flag
    var isValidFeature = false;
    var closestFeature = null;
    var shortestDistance = Infinity;

    // Loop through the featureLayers to check if clicked on LineString or Polygon (excluding 'USIU BORDER')
    featureLayers.forEach(function(featureLayer) {
        // Exclude "USIU BORDER" explicitly
        if (featureLayer.name === 'USIU BORDER') {
            return; // Skip processing for USIU BORDER
        }

        // Handle LineStrings
        if (featureLayer.featureType === 'LineString') {
            const lineCoords = featureLayer.layer.getLatLngs();
            const nearestEndpoint = findNearestEndpoint(latlng, lineCoords);
            const distanceToNearest = calculateDistance(latlng, nearestEndpoint);

            // Check if click is near the LineString (adjust distance threshold as needed)
            if (distanceToNearest < 10 && distanceToNearest < shortestDistance) {
                isValidFeature = true; // Valid LineString feature clicked
                shortestDistance = distanceToNearest; // Track the closest distance
                closestFeature = featureLayer; // Track the closest feature
            }
        }
        // Handle Polygons
        else if (featureLayer.featureType === 'Polygon') {
            if (featureLayer.layer.getBounds().contains(latlng)) {
                isValidFeature = true; // Valid Polygon feature clicked
            }
        }
    });

    // If the click was on a valid LineString or Polygon (excluding USIU BORDER), update the coordSource1 with live coordinates
    if (isValidFeature) {
        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

        // Log the closest LineString name to the console
        if (closestFeature && closestFeature.name) {
            console.log(`The closest LineString is: ${closestFeature.name}`);
        }
    } else {
        // If the click was outside valid features or on 'USIU BORDER', clear the input
        document.getElementById('coordSource1').value = '';
        document.getElementById('coordSource').value = '';
    }

    // Find the nearest endpoint of the LineString and update coordSource (second input)
    var nearestEndpoint = findNearestPoint(latlng, featureLayers);
    if (nearestEndpoint && nearestEndpoint.latLng) {
        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
    } else {
        document.getElementById('coordSource').value = 'No nearest endpoint found';
    }
});




        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }

        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        }

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

function highlightPaths(paths) {
            // Reset all path colors to default
            pathLayers.forEach(layerObj => {
                layerObj.layer.setStyle({
                    color: layerObj.layer.feature.properties.borderColor || '#000',
                    fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
                });

                // Remove previous polylines (if any)
                if (layerObj.polyline) {
                    map.removeLayer(layerObj.polyline);
                }
            });

            // Highlight the paths that are part of the shortest route
            paths.forEach(({ path, from, to }) => {
                const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
                if (matchingLayer) {
                    // Set the color to red for the shortest route
                    matchingLayer.layer.setStyle({ color: 'red' });

                    // Extract the coordinates from the matching path layer and draw a polyline
                    const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

                    const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

                    // Store the polyline on the layer object for potential future cleanup
                    matchingLayer.polyline = polyline;
                }
            });
        }




// Global variable to store the previously drawn polyline
let previousPolyline = null;

// New function to find the closest interpolated point, nearest endpoint, and draw the black polyline
function highlightInterpolatedPath(liveLatLng, coordSource) {
    // Clear the previous polyline if it exists
    if (previousPolyline) {
        map.removeLayer(previousPolyline); // Remove the previous polyline from the map
        previousPolyline = null; // Reset the variable
    }

    const pathLayer = findPathContainingLiveCoordinate(liveLatLng);

    if (pathLayer) {
        const lineCoords = pathLayer.getLatLngs();
        
        // Extract all the coordinates from the path (with interpolation)
        const extractedCoords = extractCoordinates(lineCoords, 1000); // You can adjust the number of interpolated points
        
        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
        
        // Find the nearest endpoint to the live coordinate
        const nearestEndpoint = findNearestEndpoint(liveLatLng, lineCoords);

        // Find the index of the closest interpolated point and nearest endpoint in the extracted coordinates
        const closestIndex = extractedCoords.findIndex(coord =>
            coord[0] === closestInterpolatedPoint[0] && coord[1] === closestInterpolatedPoint[1]);
        const nearestIndex = extractedCoords.findIndex(coord =>
            coord[0] === nearestEndpoint.lng && coord[1] === nearestEndpoint.lat);

        // Ensure the indices are valid and log the range of coordinates between them
        if (closestIndex !== -1 && nearestIndex !== -1) {
            const startIndex = Math.min(closestIndex, nearestIndex);
            const endIndex = Math.max(closestIndex, nearestIndex);

            console.log('Coordinates between the closest interpolated point and the nearest endpoint:');
            
            // Store the coordinates to connect them with a polyline
            const coordsToConnect = [];
            for (let i = startIndex; i <= endIndex; i++) {
                console.log(`Latitude: ${extractedCoords[i][1]}, Longitude: ${extractedCoords[i][0]}`);
                coordsToConnect.push([extractedCoords[i][1], extractedCoords[i][0]]);  // Store the coordinate in [lat, lng] format
            }

            // Draw a black polyline connecting the coordinates (new polyline)
            previousPolyline = L.polyline(coordsToConnect, { color: 'red', weight: 2 }).addTo(map);

        } else {
            console.log('Could not find valid indices for closest point or nearest endpoint.');
        }
    } else {
        console.log('No matching path found for the live coordinate.');
    }
}
document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const liveLatLng = L.latLng(lat1, lng1);  // Live coordinate (coordSource1)

    // Call the new function to highlight the interpolated path
    highlightInterpolatedPath(liveLatLng, coordSource);

    // Find and log the path where live coordinate belongs
    findPathContainingLiveCoordinate(liveLatLng); // Add this call to log the path

    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }
    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                distanceCell.textContent = distanceBetweenCoords.toFixed(2) + ' meters'; // Show distance between coordSource1 and coordSource
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

// Function to interpolate between two coordinates
function interpolateCoordinates(coord1, coord2, numPoints) {
    let interpolatedPoints = [];
    let latDiff = (coord2[1] - coord1[1]) / numPoints;
    let lngDiff = (coord2[0] - coord1[0]) / numPoints;

    for (let i = 0; i <= numPoints; i++) {
        let interpolatedLat = coord1[1] + (i * latDiff);
        let interpolatedLng = coord1[0] + (i * lngDiff);
        interpolatedPoints.push([interpolatedLng, interpolatedLat]);
    }

    return interpolatedPoints;
}

// Function to extract all coordinates including interpolated points along the LineString
function extractCoordinates(lineCoords, numInterpolatedPoints) {
    let allCoordinates = [];

    for (let i = 0; i < lineCoords.length - 1; i++) {
        let coord1 = [lineCoords[i].lng, lineCoords[i].lat];
        let coord2 = [lineCoords[i + 1].lng, lineCoords[i + 1].lat];
        let segmentPoints = interpolateCoordinates(coord1, coord2, numInterpolatedPoints);
        allCoordinates = allCoordinates.concat(segmentPoints);
    }

    return allCoordinates;
}

// Function to find the closest interpolated point to the live coordinate
function findClosestInterpolatedPoint(liveCoord, interpolatedPoints) {
    let closestPoint = null;
    let shortestDistance = Infinity;

    interpolatedPoints.forEach(point => {
        let pointLatLng = L.latLng(point[1], point[0]);
        let distance = calculateDistance(liveCoord, pointLatLng);
        if (distance < shortestDistance) {
            shortestDistance = distance;
            closestPoint = point;
        }
    });

    return closestPoint;
}

// Global variables to store the current polyline and circles
let currentPolyline = null;
let currentCircles = [];

// Function to remove the current polyline and circles from the map
function clearCurrentPolylineAndCircles() {
    if (currentPolyline) {
        map.removeLayer(currentPolyline);  // Remove the polyline from the map
        currentPolyline = null;  // Reset the reference
    }
    currentCircles.forEach(circle => {
        map.removeLayer(circle);  // Remove each circle from the map
    });
    currentCircles = [];  // Reset the array
}


// Modified function to find the closest path where live coordinates belong, interpolate points, and call the new function
function findPathContainingLiveCoordinate(liveLatLng) {
    let foundLayer = null;
    let closestPath = null;
    let shortestDistance = Infinity;

    // Iterate through all path layers to find the closest path to the live coordinate
    pathLayers.forEach(layerObj => {
        const lineCoords = layerObj.layer.getLatLngs();

        // Loop through the coordinates of each path
        for (let i = 0; i < lineCoords.length; i++) {
            const distance = calculateDistance(liveLatLng, lineCoords[i]);

            // Check if the distance is smaller than our threshold and if it's the smallest so far
            if (distance < 10 && distance < shortestDistance) { // Adjust threshold if necessary
                foundLayer = layerObj.layer;
                shortestDistance = distance;
                closestPath = layerObj;
            }
        }
    });

    // If a path is found
    if (closestPath) {
        console.log(`Live coordinate belongs to path: ${closestPath.name}`);

        // Get the coordinates of the LineString where live coordinates lie
        const lineCoords = closestPath.layer.getLatLngs();

        // Interpolate 1000 points along the path
        const interpolatedPoints = extractCoordinates(lineCoords, 1000);

        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, interpolatedPoints);

        // Find the nearest endpoint to the live coordinate
        const nearestEndpoint = findNearestEndpoint(liveLatLng, lineCoords);

        // Log the live coordinate, the closest interpolated point, and the nearest endpoint
        console.log(`Live coordinate: ${liveLatLng.lat}, ${liveLatLng.lng}`);
        console.log(`Closest interpolated point: ${closestInterpolatedPoint[1]}, ${closestInterpolatedPoint[0]}`);
        console.log(`Nearest endpoint: ${nearestEndpoint.lat}, ${nearestEndpoint.lng}`);

       
    } else {
        console.log('No matching path found for the live coordinate.');
    }

    return foundLayer;
}

// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}



    </script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource1" readonly />
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name);
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'USIU BORDER';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#27a147 ' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // Register live coordinates for any clicked feature except 'USIU BORDER'
                layer.on('click', function (e) {
                    var latlng = e.latlng; // Get the coordinates of the clicked point

                    // Handle 'USIU BORDER' clicks (clear inputs)
                    if (feature.properties.name === 'USIU BORDER') {
                        document.getElementById('coordSource1').value = '';
                        document.getElementById('coordSource').value = '';
                        return; // Exit, no further processing for USIU BORDER
                    }

                    // Handle LineString or Polygon features (excluding 'USIU BORDER')
                    if (feature.geometry.type === "LineString" || feature.geometry.type === "Polygon") {
                        // Update the first input with live coordinates of the clicked point
                        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

                        // Handle LineString features for nearest endpoint
                        if (feature.geometry.type === "LineString") {
                            const lineCoords = layer.getLatLngs(); // Get the coordinates of the LineString

                            // Find the closest endpoint of the clicked LineString
                            const closestEndpoint = findNearestEndpoint(latlng, lineCoords);

                            // Update the second input with the closest endpoint of the LineString
                            document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                        } else {
                            // Clear coordSource input for Polygons, as no nearest endpoint is needed
                            document.getElementById('coordSource').value = '';
                        }
                    }
                });

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                if (feature.properties && feature.properties.name) {
                    layer.bindPopup(feature.properties.name);
                }
            }
        }).addTo(map);

        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));


    map.on('click', function(e) {
    var latlng = e.latlng;

    // Reset the validity flag
    var isValidFeature = false;
    var closestFeature = null;
    var shortestDistance = Infinity;

    // Loop through the featureLayers to check if clicked on LineString or Polygon (excluding 'USIU BORDER')
    featureLayers.forEach(function(featureLayer) {
        // Exclude "USIU BORDER" explicitly
        if (featureLayer.name === 'USIU BORDER') {
            return; // Skip processing for USIU BORDER
        }

        // Handle LineStrings
        if (featureLayer.featureType === 'LineString') {
            const lineCoords = featureLayer.layer.getLatLngs();
            const nearestEndpoint = findNearestEndpoint(latlng, lineCoords);
            const distanceToNearest = calculateDistance(latlng, nearestEndpoint);

            // Check if click is near the LineString (adjust distance threshold as needed)
            if (distanceToNearest < 2 && distanceToNearest < shortestDistance) {
                isValidFeature = true; // Valid LineString feature clicked
                shortestDistance = distanceToNearest; // Track the closest distance
                closestFeature = featureLayer; // Track the closest feature
            }
        }
        // Handle Polygons
        else if (featureLayer.featureType === 'Polygon') {
            if (featureLayer.layer.getBounds().contains(latlng)) {
                isValidFeature = true; // Valid Polygon feature clicked
            }
        }
    });
 // If the click was on a valid LineString, interpolate and log the points
 if (isValidFeature && closestFeature) {
        const lineCoords = closestFeature.layer.getLatLngs();
        
        // Interpolate 1000 points along the LineString
        const interpolatedPoints = extractCoordinates(lineCoords, 1000);
        
        // Log all interpolated points to the console
        console.log('Interpolated points along the clicked LineString:');
        interpolatedPoints.forEach(point => {
            console.log(`Latitude: ${point[1]}, Longitude: ${point[0]}`);
        });
    } else {
        console.log('Click was not on a valid LineString.');
    }
    // If the click was on a valid LineString or Polygon (excluding USIU BORDER), update the coordSource1 with live coordinates
    if (isValidFeature) {
        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

        // Log the closest LineString name to the console
        if (closestFeature && closestFeature.name) {
            console.log(`The closest LineString is: ${closestFeature.name}`);
        }
    } else {
        // If the click was outside valid features or on 'USIU BORDER', clear the input
        document.getElementById('coordSource1').value = '';
        document.getElementById('coordSource').value = '';
    }

    // Find the nearest endpoint of the LineString and update coordSource (second input)
    var nearestEndpoint = findNearestPoint(latlng, featureLayers);
    if (nearestEndpoint && nearestEndpoint.latLng) {
        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
    } else {
        document.getElementById('coordSource').value = 'No nearest endpoint found';
    }
});




        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }
// Add custom locations and map them to specific points
const customLocations = {
    "USIU GATE A": "POINT 86",
    "USIU GATE B": "POINT 100",
    "LIBRARY": "POINT 150",
    "SCHOOL OF HUMANITIES": "POINT 200",
    "ADMINISTRATION": "POINT 200",
    "SWIMMING POOL": "POINT 250"
};
        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        
// Populate the dropdowns with custom locations
Object.keys(customLocations).forEach(location => {
        const point = customLocations[location];

        const optionSource = document.createElement('option');
        optionSource.value = point; // Map custom location to POINT value
        optionSource.textContent = location;
        sourceSelect.appendChild(optionSource);

        const optionDestination = document.createElement('option');
        optionDestination.value = point; // Map custom location to POINT value
        optionDestination.textContent = location;
        destinationSelect.appendChild(optionDestination);

        const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point; // Map custom location to POINT value
        optionCoordDestination.textContent = location;
        coordDestinationSelect.appendChild(optionCoordDestination);
    });
}

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

function highlightPaths(paths) {
            // Reset all path colors to default
            pathLayers.forEach(layerObj => {
                layerObj.layer.setStyle({
                    color: layerObj.layer.feature.properties.borderColor || '#000',
                    fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
                });

                // Remove previous polylines (if any)
                if (layerObj.polyline) {
                    map.removeLayer(layerObj.polyline);
                }
            });

            // Highlight the paths that are part of the shortest route
            paths.forEach(({ path, from, to }) => {
                const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
                if (matchingLayer) {
                    // Set the color to red for the shortest route
                    matchingLayer.layer.setStyle({ color: 'red' });

                    // Extract the coordinates from the matching path layer and draw a polyline
                    const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

                    const polyline = L.polyline(coordinates, { color: 'red', weight: 1 }).addTo(map);

                    // Store the polyline on the layer object for potential future cleanup
                    matchingLayer.polyline = polyline;
                }
            });
        }




// Global variable to store the previously drawn polyline
let previousPolyline = null;

// New function to find the closest interpolated point, nearest endpoint, and draw the black polyline
function highlightInterpolatedPath(liveLatLng, coordSource) {
    // Clear the previous polyline if it exists
    if (previousPolyline) {
        map.removeLayer(previousPolyline); // Remove the previous polyline from the map
        previousPolyline = null; // Reset the variable
    }

    const pathLayer = findPathContainingLiveCoordinate(liveLatLng);

    if (pathLayer) {
        const lineCoords = pathLayer.getLatLngs();
        
        // Extract all the coordinates from the path (with interpolation)
        const extractedCoords = extractCoordinates(lineCoords, 1000); // You can adjust the number of interpolated points
        
        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
        
        // Find the nearest endpoint to the live coordinate
        const nearestEndpoint = findNearestEndpoint(liveLatLng, lineCoords);

        // Find the index of the closest interpolated point and nearest endpoint in the extracted coordinates
        const closestIndex = extractedCoords.findIndex(coord =>
            coord[0] === closestInterpolatedPoint[0] && coord[1] === closestInterpolatedPoint[1]);
        const nearestIndex = extractedCoords.findIndex(coord =>
            coord[0] === nearestEndpoint.lng && coord[1] === nearestEndpoint.lat);

        // Ensure the indices are valid and log the range of coordinates between them
        if (closestIndex !== -1 && nearestIndex !== -1) {
            const startIndex = Math.min(closestIndex, nearestIndex);
            const endIndex = Math.max(closestIndex, nearestIndex);

            console.log('Coordinates between the closest interpolated point and the nearest endpoint:');
            
            // Store the coordinates to connect them with a polyline
            const coordsToConnect = [];
            for (let i = startIndex; i <= endIndex; i++) {
                // console.log(`Latitude: ${extractedCoords[i][1]}, Longitude: ${extractedCoords[i][0]}`);
                coordsToConnect.push([extractedCoords[i][1], extractedCoords[i][0]]);  // Store the coordinate in [lat, lng] format
            }

            // Draw a black polyline connecting the coordinates (new polyline)
            previousPolyline = L.polyline(coordsToConnect, { color: 'red', weight: 2 }).addTo(map);

        } else {
            console.log('Could not find valid indices for closest point or nearest endpoint.');
        }
    } else {
        console.log('No matching path found for the live coordinate.');
    }
}

// Global variable to store the previously drawn polyline for the farthest endpoint
let previousFarthestPolyline = null;

// New function to find the closest interpolated point, farthest endpoint, and draw the green polyline
function highlightFarthestInterpolatedPath(liveLatLng, coordSource) {
    // Clear the previous polyline if it exists
    if (previousFarthestPolyline) {
        map.removeLayer(previousFarthestPolyline); // Remove the previous polyline from the map
        previousFarthestPolyline = null; // Reset the variable
    }

    const pathLayer = findPathContainingLiveCoordinate(liveLatLng);

    if (pathLayer) {
        const lineCoords = pathLayer.getLatLngs();
        
        // Extract all the coordinates from the path (with interpolation)
        const extractedCoords = extractCoordinates(lineCoords, 1000); // You can adjust the number of interpolated points
        
        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
        
        // Find the farthest endpoint to the live coordinate
        const farthestEndpoint = findFarthestEndpoint(liveLatLng, lineCoords);

        // Find the index of the closest interpolated point and farthest endpoint in the extracted coordinates
        const closestIndex = extractedCoords.findIndex(coord =>
            coord[0] === closestInterpolatedPoint[0] && coord[1] === closestInterpolatedPoint[1]);
        const farthestIndex = extractedCoords.findIndex(coord =>
            coord[0] === farthestEndpoint.lng && coord[1] === farthestEndpoint.lat);

        // Ensure the indices are valid and log the range of coordinates between them
        if (closestIndex !== -1 && farthestIndex !== -1) {
            const startIndex = Math.min(closestIndex, farthestIndex);
            const endIndex = Math.max(closestIndex, farthestIndex);

            console.log('Coordinates between the closest interpolated point and the farthest endpoint:');
            
            // Store the coordinates to connect them with a polyline
            const coordsToConnect = [];
            for (let i = startIndex; i <= endIndex; i++) {
                // console.log(`Latitude: ${extractedCoords[i][1]}, Longitude: ${extractedCoords[i][0]}`);
                coordsToConnect.push([extractedCoords[i][1], extractedCoords[i][0]]);  // Store the coordinate in [lat, lng] format
            }

            // Draw a green polyline connecting the coordinates (new polyline)
            previousFarthestPolyline = L.polyline(coordsToConnect, { color: 'green', weight: 2 }).addTo(map);

        } else {
            console.log('Could not find valid indices for closest point or farthest endpoint.');
        }
    } else {
        console.log('No matching path found for the live coordinate.');
    }
}

document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const liveLatLng = L.latLng(lat1, lng1);  // Live coordinate (coordSource1)

    // Call the new function to highlight the interpolated path
    highlightInterpolatedPath(liveLatLng, coordSource);
    highlightFarthestInterpolatedPath(liveLatLng, coordSource);
    // Find and log the path where live coordinate belongs
    findPathContainingLiveCoordinate(liveLatLng); // Add this call to log the path

    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }
    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                distanceCell.textContent = distanceBetweenCoords.toFixed(2) + ' meters'; // Show distance between coordSource1 and coordSource
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);

                 
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

// Function to interpolate between two coordinates, ensuring points are correctly placed even on straight lines
function interpolateCoordinates(coord1, coord2, numPoints) {
    let interpolatedPoints = [];
    let latDiff = coord2[1] - coord1[1];
    let lngDiff = coord2[0] - coord1[0];

    // Ensure we always interpolate even when the line is straight by dividing the lat and lng difference
    for (let i = 0; i <= numPoints; i++) {
        let factor = i / numPoints;  // Calculate interpolation factor (between 0 and 1)
        
        // Interpolate both latitude and longitude using linear interpolation
        let interpolatedLat = coord1[1] + (latDiff * factor);
        let interpolatedLng = coord1[0] + (lngDiff * factor);
        
        interpolatedPoints.push([interpolatedLng, interpolatedLat]);
    }

    return interpolatedPoints;
}


// Function to extract all coordinates including interpolated points along the LineString
function extractCoordinates(lineCoords, numInterpolatedPoints) {
    let allCoordinates = [];

    for (let i = 0; i < lineCoords.length - 1; i++) {
        let coord1 = [lineCoords[i].lng, lineCoords[i].lat];
        let coord2 = [lineCoords[i + 1].lng, lineCoords[i + 1].lat];
        let segmentPoints = interpolateCoordinates(coord1, coord2, numInterpolatedPoints);
        allCoordinates = allCoordinates.concat(segmentPoints);

        // Log the points from this segment
        segmentPoints.forEach(point => {
            console.log(`Interpolated Point: Latitude: ${point[1]}, Longitude: ${point[0]}`);
        });
    }

    return allCoordinates;
}


// Function to find the closest interpolated point to the live coordinate
function findClosestInterpolatedPoint(liveCoord, interpolatedPoints) {
    let closestPoint = null;
    let shortestDistance = Infinity;

    interpolatedPoints.forEach(point => {
        let pointLatLng = L.latLng(point[1], point[0]);
        let distance = calculateDistance(liveCoord, pointLatLng);
        if (distance < shortestDistance) {
            shortestDistance = distance;
            closestPoint = point;
        }
    });

    return closestPoint;
}

// Global variables to store the current polyline and circles
let currentPolyline = null;
let currentCircles = [];

// Function to remove the current polyline and circles from the map
function clearCurrentPolylineAndCircles() {
    if (currentPolyline) {
        map.removeLayer(currentPolyline);  // Remove the polyline from the map
        currentPolyline = null;  // Reset the reference
    }
    currentCircles.forEach(circle => {
        map.removeLayer(circle);  // Remove each circle from the map
    });
    currentCircles = [];  // Reset the array
}


// Modified function to find the closest path where live coordinates belong, interpolate points, and call the new function
function findPathContainingLiveCoordinate(liveLatLng) {
    let foundLayer = null;
    let closestPath = null;
    let shortestDistance = Infinity;

    // Iterate through all path layers to find the closest path to the live coordinate
    pathLayers.forEach(layerObj => {
        const lineCoords = layerObj.layer.getLatLngs();

        // Loop through each segment formed by consecutive points
        for (let i = 0; i < lineCoords.length - 1; i++) {
            const segmentStart = lineCoords[i];
            const segmentEnd = lineCoords[i + 1];

            // Project the liveLatLng onto the current segment
            const projectedPoint = projectOntoSegment(liveLatLng, segmentStart, segmentEnd);

            // Calculate the distance between the liveLatLng and the projected point
            const distance = calculateDistance(liveLatLng, projectedPoint);

            // Check if the projected point is on the segment and if the distance is smaller than our threshold
            if (isPointOnSegment(projectedPoint, segmentStart, segmentEnd) && distance < 2 && distance < shortestDistance) {
                foundLayer = layerObj.layer;
                shortestDistance = distance;
                closestPath = layerObj;
            }
        }
    });

    // If a path is found
    if (closestPath) {
        console.log(`Live coordinate belongs to path: ${closestPath.name}`);

        // Get the coordinates of the LineString where live coordinates lie
        const lineCoords = closestPath.layer.getLatLngs();

        // Interpolate 1000 points along the path
        const interpolatedPoints = extractCoordinates(lineCoords, 1000);

        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, interpolatedPoints);

        // Find the nearest endpoint to the live coordinate
        const nearestEndpoint = findNearestEndpoint(liveLatLng, lineCoords);

        // Find the farthest endpoint to the live coordinate
        const farthestEndpoint = findFarthestEndpoint(liveLatLng, lineCoords);

        // Log the live coordinate, the closest interpolated point, nearest endpoint, and farthest endpoint
        console.log(`Live coordinate: ${liveLatLng.lat}, ${liveLatLng.lng}`);
        console.log(`Closest interpolated point: ${closestInterpolatedPoint[1]}, ${closestInterpolatedPoint[0]}`);
        console.log(`Nearest endpoint: ${nearestEndpoint.lat}, ${nearestEndpoint.lng}`);
        console.log(`Farthest endpoint: ${farthestEndpoint.lat}, ${farthestEndpoint.lng}`);
    } else {
        console.log('No matching path found for the live coordinate.');
    }

    return foundLayer;
}

// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Helper function to project a point onto a line segment
function projectOntoSegment(point, segmentStart, segmentEnd) {
    const x1 = segmentStart.lng, y1 = segmentStart.lat;
    const x2 = segmentEnd.lng, y2 = segmentEnd.lat;
    const x3 = point.lng, y3 = point.lat;

    const px = x2 - x1;
    const py = y2 - y1;
    const norm = px * px + py * py;
    const u = ((x3 - x1) * px + (y3 - y1) * py) / norm;

    const clampedU = Math.max(Math.min(u, 1), 0); // Clamp the projection factor to [0, 1]
    return L.latLng(y1 + clampedU * py, x1 + clampedU * px);
}

// Helper function to check if a point is on a segment between two points (using a small tolerance)
function isPointOnSegment(point, segmentStart, segmentEnd) {
    const tolerance = 0.00001; // Adjust tolerance as needed
    const minLat = Math.min(segmentStart.lat, segmentEnd.lat) - tolerance;
    const maxLat = Math.max(segmentStart.lat, segmentEnd.lat) + tolerance;
    const minLng = Math.min(segmentStart.lng, segmentEnd.lng) - tolerance;
    const maxLng = Math.max(segmentStart.lng, segmentEnd.lng) + tolerance;

    return point.lat >= minLat && point.lat <= maxLat && point.lng >= minLng && point.lng <= maxLng;
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}

// Function to find the farthest endpoint (first or last) of a LineString to the selected coordinate
function findFarthestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the farther endpoint
    return distanceToFirst > distanceToLast ? firstPoint : lastPoint;
}


    </script>
</body>
</html>



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }
        #container {
    display: flex;
    height: 100vh;
    background-color: white;
}

#leftBox {
    width: 25%;
    background-color: #f4f4f4;
    border-right: 1px solid #ccc;
    padding: 10px;
    display: flex;
    flex-direction: column;
}

#searchBar {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

.scrollable-content {
    overflow-y: auto;
    flex-grow: 1;
    max-height: calc(100vh - 60px); /* Adjust based on padding */
}

.clickable-item {
    background-color: white;
    padding: 10px;
    margin-bottom: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.clickable-item:hover {
    background-color: #e0e0e0;
}

#rightBox {
    flex-grow: 1;
    padding: 20px;
    display: flex;
    flex-direction: column;
}
        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2, #controls3 {
    margin-bottom: 20px;
    background-color: white;
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
}

#backBtn {
    margin-bottom: 10px;
    padding: 8px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

#backBtn:hover {
    background-color: #0056b3;
}

    </style>
</head>
<body>
    <div id="container">
       <!-- HTML structure for the left box -->
       <div id="leftBox">
        <button id="backBtn" style="display: none;">Back</button> <!-- Back button -->
         <h2 id="heading"></h2>
        <input type="text" id="searchBar" placeholder="Search..." />
        <div class="scrollable-content" id="mainItems"> <!-- Main items list -->
            <div class="clickable-item" id="transportation">Transportation</div>
            <div class="clickable-item" id="restaurants">Restaurants</div>
            <div class="clickable-item" id="sports">Sports</div>
            <div class="clickable-item" id="lecturers">Lecturers</div>
            <div class="clickable-item" id="parking">Parking Lots</div>
            <div class="clickable-item" id="classrooms">Classrooms</div>
            <div class="clickable-item" id="swimming-pool">Swimming Pool</div>
            <div class="clickable-item" id="science-school">School of Science</div>
            <div class="clickable-item" id="humanities-school">School of Humanities</div>
            <div class="clickable-item" id="library">Library</div>
            <div class="clickable-item" id="lilian-k">Lilian K Beam Building</div>
            <div class="clickable-item" id="administration">Administration</div>
        </div>
    
        <div class="scrollable-content" id="transportationItems" style="display: none;"> <!-- Transportation sub-items -->
            <div class="clickable-item">Transportation Office</div>
        </div>
    
        <div class="scrollable-content" id="sportsItems" style="display: none;"> <!-- Sports sub-items -->
            <div class="clickable-item">Basketball Court</div>
            <div class="clickable-item">Football Pitch</div>
            <div class="clickable-item">Tennis</div>
            <div class="clickable-item">Pool Table</div>
        </div>
    
        <div class="scrollable-content" id="restaurantsItems" style="display: none;"> <!-- Restaurants sub-items -->
            <div class="clickable-item">Paul's Caffe</div>
            <div class="clickable-item">Sironi</div>
            <div class="clickable-item">Caffe Latte</div>
        </div>
    </div>
    

        <!-- Controls on the Right -->
        <div id="rightBox">
    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource1" readonly />
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
        </div>
    </div>
    
    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>

// Wait for the DOM to load before adding event listeners
document.addEventListener('DOMContentLoaded', function() {
    // Event listeners for normal divs
    document.getElementById('transportation').addEventListener('click', function() {
        showSubItems('transportationItems', 'Transportation');
    });

    document.getElementById('sports').addEventListener('click', function() {
        showSubItems('sportsItems', 'Sports');
    });

    document.getElementById('restaurants').addEventListener('click', function() {
        showSubItems('restaurantsItems', 'Restaurants');
    });

    // Function to show sub-items and hide the main list
    function showSubItems(subItemId, headingText) {
        // Hide main items
        document.getElementById('mainItems').style.display = 'none';

        // Show the selected sub-items
        document.getElementById(subItemId).style.display = 'block';

        // Show the back button and heading
        document.getElementById('backBtn').style.display = 'block';
        document.getElementById('heading').style.display = 'block';  // Display heading
        document.getElementById('heading').innerText = headingText;  // Set heading text
    }

    // Back button functionality to go back to the main items
    document.getElementById('backBtn').addEventListener('click', function() {
        // Hide all sub-items
        document.getElementById('transportationItems').style.display = 'none';
        document.getElementById('sportsItems').style.display = 'none';
        document.getElementById('restaurantsItems').style.display = 'none';

        // Show main items
        document.getElementById('mainItems').style.display = 'block';

        // Hide the back button and heading
        document.getElementById('backBtn').style.display = 'none';
        document.getElementById('heading').style.display = 'none';
    });

    function handleSubDivClick(locationName, customDetails) {
        const point = customLocations[locationName];

        // Automatically set the destination in both dropdowns (controls2 and controls3)
        document.getElementById('destination').value = point;
        document.getElementById('coordDestination').value = point;

        // Hide the search bar and show back button and content
        document.getElementById('searchBar').style.display = 'none';

        // Show the back button, heading, image, directions button, and table with custom content
        const content = `
            <button id="backBtn1">Back</button>
            <h2>${locationName}</h2>
            <img src="messi.jpeg" alt="${locationName}" style="width:100%;max-width:200px;" />
            <button id="directionsBtn">Directions</button>
            <table border="1" style="margin-top: 10px;">
                <tr><td>Location</td><td>${customDetails.location}</td></tr>
                <tr><td>Phone Number</td><td>${customDetails.phoneNumber}</td></tr>
                <tr><td>Email Address</td><td>${customDetails.email}</td></tr>
                <tr><td>Other</td><td>${customDetails.other}</td></tr>
            </table>
        `;

        document.getElementById('leftBox').innerHTML = content;

        // Add event listener for the Directions button
        document.getElementById('directionsBtn').addEventListener('click', function () {
            showDirectionsSubSubDiv(locationName); // Call a new function to show the Directions options
        });

        // Add back button event listener
        document.getElementById('backBtn1').addEventListener('click', function() {
            // Revert to the previous state with main items visible
            location.reload();
        });
    }

// Function to show the directions sub-sub div when the Directions button is clicked
function showDirectionsSubSubDiv(destinationName) {
    // Replace content with the new sub-sub div containing the buttons and headings
    const directionsContent = `
        <button id="backBtn2">Back</button>
        <h2>Destination: ${destinationName}</h2>
        <h3>Choose a starting location</h3>
        <button id="searchAreaBtn">Search an Area</button>
        <button id="selectMapBtn">Select an area on the map</button>
        <button id="liveLocationBtn">Use live location</button>
    `;

    document.getElementById('leftBox').innerHTML = directionsContent;

    // Add functionality for the new buttons
    document.getElementById('backBtn2').addEventListener('click', function () {
        // Restore the previous content when the back button is clicked
        handleSubDivClick(destinationName, customLocations[destinationName]);
    });

    document.getElementById('searchAreaBtn').addEventListener('click', function () {
        showSearchAreaOptions(destinationName);  // Pass the destinationName to the function
    });

    document.getElementById('selectMapBtn').addEventListener('click', function () {
        showModeSelectionSubDivForMap(destinationName); // Call the new function for map mode selection
    });

    document.getElementById('liveLocationBtn').addEventListener('click', function () {
        alert("Use live location functionality clicked!");
    });
}
// New function to show mode selection for the map when "Select an area on the map" is clicked
function showModeSelectionSubDivForMap(destinationName) {
    // Content for the new sub-div
    const modeSelectionContentForMap = `
        <h2>Selected Source: Dropped Pin</h2>
        <h2>Selected Destination: ${destinationName}</h2>
        <h3>Select the mode of transportation</h3>
        
        <!-- Buttons for selecting mode of transportation -->
        <div id="modeSelectionForMap">
            <button id="mapWalkingBtn" class="map-mode-btn">Walking</button>
            <button id="mapDrivingBtn" class="map-mode-btn">Driving</button>
            <button id="mapDisabledBtn" class="map-mode-btn">Disabled</button>
        </div>
        
        <!-- Start Button -->
        <button id="startMapBtn" style="margin-top: 20px;">Start Journey</button>

        <!-- Section to display directions below the Start button -->
        <div id="mapDirectionsOutput" style="margin-top: 20px;">
            <h4>Directions:</h4>
            <p id="mapDirectionsText">No directions available yet.</p>
        </div>
    `;

    // Replace the content of the left box with this new content
    document.getElementById('leftBox').innerHTML = modeSelectionContentForMap;

    // Add functionality to highlight the selected mode and set the mode in controls3
    document.querySelectorAll('.map-mode-btn').forEach(button => {
        button.addEventListener('click', function () {
            // Remove the yellow background from all buttons
            document.querySelectorAll('.map-mode-btn').forEach(btn => {
                btn.style.backgroundColor = ''; // Reset background color
            });

            // Highlight the clicked button
            this.style.backgroundColor = 'yellow'; // Highlight the selected mode

            // Set the mode in controls3
            const selectedModeForMap = this.textContent.toLowerCase(); // Get the mode as lowercase
            document.getElementById('coordMode').value = selectedModeForMap; // Set the mode in controls3
        });
    });

    // Add event listener for the Start button
    document.getElementById('startMapBtn').addEventListener('click', function () {
        // Check if a mode is selected
        const selectedModeForMap = [...document.querySelectorAll('.map-mode-btn')].find(btn => btn.style.backgroundColor === 'yellow')?.textContent;

        if (!selectedModeForMap) {
            alert('Please select a mode of transportation.');
            return;
        }

        // Trigger the Search button in controls3 programmatically
        document.getElementById('coordSearchBtn').click();

        // After triggering the search, extract the directions from the table and display them below the Start button
        setTimeout(displayMapDirections, 500); // Delay to ensure table data is updated
    });
}
// Function to extract directions from the last column of the coordPathTable and display them
function displayMapDirections() {
    const directionCells = document.querySelectorAll('#coordPathTable tbody tr td:nth-child(5)'); // Get all cells in the last column (Directions)
    let directionsText = '';

    directionCells.forEach(cell => {
        const direction = cell.textContent.trim();
        if (direction) {
            directionsText += direction + '<br>'; // Append direction with a line break
        }
    });

    if (!directionsText) {
        directionsText = 'No directions available.';
    }

    // Display the directions below the Start button
    document.getElementById('mapDirectionsText').innerHTML = directionsText;
}


// Function to handle search area options
function showSearchAreaOptions(destinationName) {
    const areaSelectionContent = `
        <input type="text" id="newSearchBar" placeholder="Search..." />
        <div class="scrollable-content" id="newMainItems"> <!-- Main items list -->
            <div class="clickable-item" id="newTransportation">Transportation</div>
            <div class="clickable-item" id="newRestaurants">Restaurants</div>
            <div class="clickable-item" id="newSports">Sports</div>
            <div class="clickable-item" id="newLecturers">Lecturers</div>
            <div class="clickable-item" id="newParking">Parking Lots</div>
            <div class="clickable-item" id="newClassrooms">Classrooms</div>
            <div class="clickable-item" id="newSwimmingPool">Swimming Pool</div>
            <div class="clickable-item" id="newScienceSchool">School of Science</div>
            <div class="clickable-item" id="newHumanitiesSchool">School of Humanities</div>
            <div class="clickable-item" id="newLibrary">Library</div>
            <div class="clickable-item" id="newLilianK">Lilian K Beam Building</div>
            <div class="clickable-item" id="newAdministration">Administration</div>
        </div>
        
        <!-- Additional sub-items can be dynamically created like this -->
        <div class="scrollable-content" id="newTransportationItems" style="display: none;"> <!-- Transportation sub-items -->
            <div class="clickable-item" data-source="Transportation Office">Transportation Office</div>
        </div>
        <div class="scrollable-content" id="newSportsItems" style="display: none;"> <!-- Sports sub-items -->
            <div class="clickable-item" data-source="Basketball Court">Basketball Court</div>
            <div class="clickable-item" data-source="Football Pitch">Football Pitch</div>
            <div class="clickable-item" data-source="Tennis">Tennis</div>
        </div>
    `;
    document.getElementById('leftBox').innerHTML = areaSelectionContent;

    // Add event listeners for main items to show sub-items
    document.getElementById('newTransportation').addEventListener('click', function () {
        showNewSubItems('newTransportationItems', destinationName);  // Pass the destination name
    });

    document.getElementById('newSports').addEventListener('click', function () {
        showNewSubItems('newSportsItems', destinationName);  // Pass the destination name
    });

    function showNewSubItems(subItemId, destinationName) {
        // Hide main items and show the selected sub-items
        document.getElementById('newMainItems').style.display = 'none';
        document.getElementById(subItemId).style.display = 'block';

        // Add event listeners for sub-items to register the source
        document.querySelectorAll(`#${subItemId} .clickable-item`).forEach(item => {
            item.addEventListener('click', function () {
                // Get the clicked location name, trim it to remove extra spaces
                const locationName = this.textContent.trim();

                // Normalize the case to match keys in customLocations
                const normalizedLocationName = locationName.toUpperCase(); // Convert both to uppercase for consistency

                // Look up the corresponding point from customLocations
                const source = customLocations[normalizedLocationName]; // Use normalizedLocationName

                if (source) {
                    document.getElementById('source').value = source; // Set in controls2 only
                    alert(`Source registered in controls2: ${locationName} -> ${source}`);

                    // Now show the new sub-div to select mode and start the journey
                    showModeSelectionSubDiv(locationName, destinationName); // Pass both source and destination names
                } else {
                    alert(`Location "${locationName}" not found in customLocations.`);
                }
            });
        });
    }
}

function showModeSelectionSubDiv(sourceName, destinationName) {
    // Content for the new sub-div
    const modeSelectionContent = `
        <h2>Selected Source: ${sourceName}</h2>
        <h3>Selected Destination: ${destinationName}</h3>
        
        <!-- Buttons for selecting mode of transportation -->
        <div id="modeSelection">
            <button id="walkingBtn" class="mode-btn">Walking</button>
            <button id="drivingBtn" class="mode-btn">Driving</button>
            <button id="disabledBtn" class="mode-btn">Disabled</button>
        </div>
        
        <!-- Start Button -->
        <button id="startBtn" style="margin-top: 20px;">Get Directions</button>

        <!-- New section to display directions below the Start button -->
        <div id="directionsOutput" style="margin-top: 20px;">
            <h4>Directions:</h4>
            <p id="directionsText">No directions available yet.</p>
        </div>
    `;

    // Replace the content of the left box with this new content
    document.getElementById('leftBox').innerHTML = modeSelectionContent;

    // Add functionality to highlight the selected mode (as a radio button effect) and set the mode in controls2
    document.querySelectorAll('.mode-btn').forEach(button => {
        button.addEventListener('click', function () {
            // Remove the yellow background from all buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.style.backgroundColor = ''; // Reset background color
            });

            // Highlight the clicked button
            this.style.backgroundColor = 'yellow'; // Highlight the selected mode

            // Set the mode in controls2
            const selectedMode = this.textContent.toLowerCase(); // Get the mode as lowercase (walking, driving, or disabled)
            document.getElementById('mode').value = selectedMode; // Set the mode in controls2
        });
    });

    // Add event listener for the Start button
    document.getElementById('startBtn').addEventListener('click', function () {
        // Check if a mode is selected
        const selectedMode = [...document.querySelectorAll('.mode-btn')].find(btn => btn.style.backgroundColor === 'yellow')?.textContent;

        if (!selectedMode) {
            alert('Please select a mode of transportation.');
            return;
        }

        // Trigger the Search button in controls2 programmatically
        document.getElementById('searchBtn1').click();

        // After triggering the search, extract the directions from the table and display them below the Start button
        setTimeout(displayDirections, 500); // Delay to ensure table data is updated
    });
}




// Function to extract directions from the last column of the table and display them
function displayDirections() {
    const directionCells = document.querySelectorAll('#pathTable tbody tr td:nth-child(5)'); // Get all cells in the last column (Directions)
    let directionsText = '';

    directionCells.forEach(cell => {
        const direction = cell.textContent.trim();
        if (direction) {
            directionsText += direction + '<br>'; // Append direction with a line break
        }
    });

    if (!directionsText) {
        directionsText = 'No directions available.';
    }

    // Display the directions below the Start button
    document.getElementById('directionsText').innerHTML = directionsText;
}

    // Event listeners for sub-div clicks
    document.getElementById('transportationItems').addEventListener('click', function() {
        handleSubDivClick('TRANSPORTATION OFFICE', {
            location: 'Opposite Pauls caffe back entrance',
            phoneNumber: '07863322789',
            email: 'tranport@gmail.com',
            other: 'Open everyday'
        });
    });

    document.getElementById('sportsItems').addEventListener('click', function(event) {
        const target = event.target;
        if (target.innerText === 'Basketball Court') {
            handleSubDivClick('BASKETBALL COURT', {
                location: 'Sports Complex',
                phoneNumber: '07863322765',
                email: 'sports@gmail.com',
                other: 'Open on weekends'
            });
        } else if (target.innerText === 'Football Pitch') {
            handleSubDivClick('FOOTBALL PITCH', {
                location: 'Main Campus Ground',
                phoneNumber: '07863322776',
                email: 'football@gmail.com',
                other: 'Training every evening'
            });
        }
    });

    document.getElementById('restaurantsItems').addEventListener('click', function(event) {
        const target = event.target;
        if (target.innerText === "Paul's Caffe") {
            handleSubDivClick('PAULS CAFFE', {
                location: 'Student Centre',
                phoneNumber: '07863322719',
                email: 'pauls@gmail.com',
                other: 'Very popular'
            });
        } else if (target.innerText === 'Sironi') {
            handleSubDivClick('SIRONI', {
                location: 'Student Centre',
                phoneNumber: '07863322719',
                email: 'sironi@gmail.com',
                other: 'Very good restaurant'
            });
        } else if (target.innerText === 'Caffe Latte') {
            handleSubDivClick('CAFFE LATTA', {
                location: 'Student Centre',
                phoneNumber: '07863322720',
                email: 'caffelatte@gmail.com',
                other: 'Great coffee options'
            });
        }
    });
});


        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name);
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'USIU BORDER';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#27a147 ' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // Register live coordinates for any clicked feature except 'USIU BORDER'
                layer.on('click', function (e) {
                    var latlng = e.latlng; // Get the coordinates of the clicked point

                    // Handle 'USIU BORDER' clicks (clear inputs)
                    if (feature.properties.name === 'USIU BORDER') {
                        document.getElementById('coordSource1').value = '';
                        document.getElementById('coordSource').value = '';
                        return; // Exit, no further processing for USIU BORDER
                    }

                    // Handle LineString or Polygon features (excluding 'USIU BORDER')
                    if (feature.geometry.type === "LineString" || feature.geometry.type === "Polygon") {
                        // Update the first input with live coordinates of the clicked point
                        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

                        // Handle LineString features for nearest endpoint
                        if (feature.geometry.type === "LineString") {
                            const lineCoords = layer.getLatLngs(); // Get the coordinates of the LineString

                            // Find the closest endpoint of the clicked LineString
                            const closestEndpoint = findNearestEndpoint(latlng, lineCoords);

                            // Update the second input with the closest endpoint of the LineString
                            document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                        } else {
                            // Clear coordSource input for Polygons, as no nearest endpoint is needed
                            document.getElementById('coordSource').value = '';
                        }
                    }
                });

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                if (feature.properties && feature.properties.name) {
                    layer.bindPopup(feature.properties.name);
                }
            }
        }).addTo(map);

        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));


    map.on('click', function(e) {
    var latlng = e.latlng;

    // Reset the validity flag
    var isValidFeature = false;
    var closestFeature = null;
    var shortestDistance = Infinity;

    // Loop through the featureLayers to check if clicked on LineString or Polygon (excluding 'USIU BORDER')
    featureLayers.forEach(function(featureLayer) {
        // Exclude "USIU BORDER" explicitly
        if (featureLayer.name === 'USIU BORDER') {
            return; // Skip processing for USIU BORDER
        }

        // Handle LineStrings
        if (featureLayer.featureType === 'LineString') {
            const lineCoords = featureLayer.layer.getLatLngs();
            const nearestEndpoint = findNearestEndpoint(latlng, lineCoords);
            const distanceToNearest = calculateDistance(latlng, nearestEndpoint);

            // Check if click is near the LineString (adjust distance threshold as needed)
            if (distanceToNearest < 2 && distanceToNearest < shortestDistance) {
                isValidFeature = true; // Valid LineString feature clicked
                shortestDistance = distanceToNearest; // Track the closest distance
                closestFeature = featureLayer; // Track the closest feature
            }
        }
        // Handle Polygons
        else if (featureLayer.featureType === 'Polygon') {
            if (featureLayer.layer.getBounds().contains(latlng)) {
                isValidFeature = true; // Valid Polygon feature clicked
            }
        }
    });
 // If the click was on a valid LineString, interpolate and log the points
 if (isValidFeature && closestFeature) {
        const lineCoords = closestFeature.layer.getLatLngs();
        
        // Interpolate 1000 points along the LineString
        const interpolatedPoints = extractCoordinates(lineCoords, 1000);
        
        // Log all interpolated points to the console
        console.log('Interpolated points along the clicked LineString:');
        interpolatedPoints.forEach(point => {
            console.log(`Latitude: ${point[1]}, Longitude: ${point[0]}`);
        });
    } else {
        console.log('Click was not on a valid LineString.');
    }
    // If the click was on a valid LineString or Polygon (excluding USIU BORDER), update the coordSource1 with live coordinates
    if (isValidFeature) {
        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

        // Log the closest LineString name to the console
        if (closestFeature && closestFeature.name) {
            console.log(`The closest LineString is: ${closestFeature.name}`);
        }
    } else {
        // If the click was outside valid features or on 'USIU BORDER', clear the input
        document.getElementById('coordSource1').value = '';
        document.getElementById('coordSource').value = '';
    }

    // Find the nearest endpoint of the LineString and update coordSource (second input)
    var nearestEndpoint = findNearestPoint(latlng, featureLayers);
    if (nearestEndpoint && nearestEndpoint.latLng) {
        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
    } else {
        document.getElementById('coordSource').value = 'No nearest endpoint found';
    }
});




        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }
// Add custom locations and map them to specific points
const customLocations = {
    "USIU GATE A": "POINT 86",
    "USIU GATE B": "POINT 100",
    "LIBRARY": "POINT 150",
    "SCHOOL OF HUMANITIES": "POINT 200",
    "ADMINISTRATION": "POINT 200",
    "SWIMMING POOL": "POINT 160",
    "TRANSPORTATION OFFICE": "POINT 161",
    "PAULS CAFFE": "POINT 162",
    "SIRONI": "POINT 163",
    "CAFFE LATTA": "POINT 164",
    "BASKETBALL COURT": "POINT 165",
    "FOOTBALL PITCH": "POINT 166"

};
        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        
// Populate the dropdowns with custom locations
Object.keys(customLocations).forEach(location => {
        const point = customLocations[location];

        const optionSource = document.createElement('option');
        optionSource.value = point; // Map custom location to POINT value
        optionSource.textContent = location;
        sourceSelect.appendChild(optionSource);

        const optionDestination = document.createElement('option');
        optionDestination.value = point; // Map custom location to POINT value
        optionDestination.textContent = location;
        destinationSelect.appendChild(optionDestination);

        const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point; // Map custom location to POINT value
        optionCoordDestination.textContent = location;
        coordDestinationSelect.appendChild(optionCoordDestination);
    });
}

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;


// Modify the validation logic to provide more specific error messages
if (!source) {
    alert('Please select a Source point.');
    return;
}

if (!mode) {
    alert('Please choose a means of transportation.');
    return;
}

if (!destination) {
    alert('Please select a Destination Point.');
    return;
}

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

function highlightPaths(paths, skipFirstPath) {
    // Reset all path colors to default
    pathLayers.forEach(layerObj => {
        layerObj.layer.setStyle({
            color: layerObj.layer.feature.properties.borderColor || '#000',
            fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
        });

        // Remove previous polylines (if any)
        if (layerObj.polyline) {
            map.removeLayer(layerObj.polyline);
        }
    });

    // Highlight the paths that are part of the shortest route
    paths.forEach(({ path, from, to }, index) => {
        // Skip the first path if the skipFirstPath flag is true
        if (index === 0 && skipFirstPath) {
            console.log(`Skipping highlighting for path: ${path}`);
            return;
        }

        const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
        if (matchingLayer) {
            // Set the color to red for the shortest route
            matchingLayer.layer.setStyle({ color: 'red' });

            // Extract the coordinates from the matching path layer and draw a polyline
            const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

            const polyline = L.polyline(coordinates, { color: 'red', weight: 2 }).addTo(map);

            // Store the polyline on the layer object for potential future cleanup
            matchingLayer.polyline = polyline;
        }
    });
}



// Global variable to store the previously drawn polyline
let previousPolyline = null;

// New function to find the closest interpolated point, nearest endpoint, and draw the black polyline
function highlightInterpolatedPath(liveLatLng, coordSource) {
    // Clear the previous polyline if it exists
    if (previousPolyline) {
        map.removeLayer(previousPolyline); // Remove the previous polyline from the map
        previousPolyline = null; // Reset the variable
    }

    const pathLayer = findPathContainingLiveCoordinate(liveLatLng);

    if (pathLayer) {
        const lineCoords = pathLayer.getLatLngs();
        
        // Extract all the coordinates from the path (with interpolation)
        const extractedCoords = extractCoordinates(lineCoords, 1000); // You can adjust the number of interpolated points
        
        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
        
        // Find the nearest endpoint to the live coordinate
        const nearestEndpoint = findNearestEndpoint(liveLatLng, lineCoords);

        // Find the index of the closest interpolated point and nearest endpoint in the extracted coordinates
        const closestIndex = extractedCoords.findIndex(coord =>
            coord[0] === closestInterpolatedPoint[0] && coord[1] === closestInterpolatedPoint[1]);
        const nearestIndex = extractedCoords.findIndex(coord =>
            coord[0] === nearestEndpoint.lng && coord[1] === nearestEndpoint.lat);

        // Ensure the indices are valid and log the range of coordinates between them
        if (closestIndex !== -1 && nearestIndex !== -1) {
            const startIndex = Math.min(closestIndex, nearestIndex);
            const endIndex = Math.max(closestIndex, nearestIndex);

            console.log('Coordinates between the closest interpolated point and the nearest endpoint:');
            
            // Store the coordinates to connect them with a polyline
            const coordsToConnect = [];
            for (let i = startIndex; i <= endIndex; i++) {
                coordsToConnect.push([extractedCoords[i][1], extractedCoords[i][0]]);  // Store the coordinate in [lat, lng] format
            }

            // Draw a black polyline connecting the coordinates (new polyline)
            previousPolyline = L.polyline(coordsToConnect, { color: 'red', weight: 2 }).addTo(map);

            return coordsToConnect;  // Return the coordinates for distance calculation

        } else {
            console.log('Could not find valid indices for closest point or nearest endpoint.');
        }
    } else {
        console.log('No matching path found for the live coordinate.');
    }

    return [];  // Return empty if no valid path was found
}

// Global variable to store the previously drawn polyline for the farthest endpoint
let previousFarthestPolyline = null;

// New function to find the closest interpolated point, farthest endpoint, and draw the green polyline
function highlightFarthestInterpolatedPath(liveLatLng, coordSource) {
    // Clear the previous polyline if it exists
    if (previousFarthestPolyline) {
        map.removeLayer(previousFarthestPolyline); // Remove the previous polyline from the map
        previousFarthestPolyline = null; // Reset the variable
    }

    const pathLayer = findPathContainingLiveCoordinate(liveLatLng);

    if (pathLayer) {
        const lineCoords = pathLayer.getLatLngs();
        
        // Extract all the coordinates from the path (with interpolation)
        const extractedCoords = extractCoordinates(lineCoords, 1000); // You can adjust the number of interpolated points
        
        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
        
        // Find the farthest endpoint to the live coordinate
        const farthestEndpoint = findFarthestEndpoint(liveLatLng, lineCoords);

        // Find the index of the closest interpolated point and farthest endpoint in the extracted coordinates
        const closestIndex = extractedCoords.findIndex(coord =>
            coord[0] === closestInterpolatedPoint[0] && coord[1] === closestInterpolatedPoint[1]);
        const farthestIndex = extractedCoords.findIndex(coord =>
            coord[0] === farthestEndpoint.lng && coord[1] === farthestEndpoint.lat);

        // Ensure the indices are valid and log the range of coordinates between them
        if (closestIndex !== -1 && farthestIndex !== -1) {
            const startIndex = Math.min(closestIndex, farthestIndex);
            const endIndex = Math.max(closestIndex, farthestIndex);

            console.log('Coordinates between the closest interpolated point and the farthest endpoint:');
            
            // Store the coordinates to connect them with a polyline
            const coordsToConnect = [];
            for (let i = startIndex; i <= endIndex; i++) {
                coordsToConnect.push([extractedCoords[i][1], extractedCoords[i][0]]);  // Store the coordinate in [lat, lng] format
            }

            // Draw a green polyline connecting the coordinates (new polyline)
            previousFarthestPolyline = L.polyline(coordsToConnect, { color: 'red', weight: 3 }).addTo(map);

            return coordsToConnect;  // Return the coordinates for distance calculation

        } else {
            console.log('Could not find valid indices for closest point or farthest endpoint.');
        }
    } else {
        console.log('No matching path found for the live coordinate.');
    }

    return [];  // Return empty if no valid path was found
}

// Function to calculate total distance between a list of coordinates
function calculateTotalDistance(coords) {
    let totalDistance = 0;
    for (let i = 0; i < coords.length - 1; i++) {
        const pointA = L.latLng(coords[i][0], coords[i][1]);
        const pointB = L.latLng(coords[i + 1][0], coords[i + 1][1]);
        totalDistance += pointA.distanceTo(pointB); // Calculate distance between two points
    }
    return totalDistance;
}

document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    // Modify the validation logic to provide more specific error messages
if (!coordSource) {
    alert('Please select a valid point on the map by clicking a path or a building in the map.');
    return;
}

if (!coordMode) {
    alert('Please choose a means of transportation.');
    return;
}

if (!coordDestination) {
    alert('Please select a destination.');
    return;
}

    if (previousPolyline) {
        map.removeLayer(previousPolyline);
        previousPolyline = null; // Reset
    }
    if (previousFarthestPolyline) {
        map.removeLayer(previousFarthestPolyline);
        previousFarthestPolyline = null; // Reset
    }
    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const liveLatLng = L.latLng(lat1, lng1);  // Live coordinate (coordSource1)

    // Call the function to find the path containing the live coordinate
    const foundLayer = findPathContainingLiveCoordinate(liveLatLng);
    if (!foundLayer) {
        console.log('No matching path found for the live coordinate.');
        return;
    }

    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `Turn ${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // New Section: Check path in second row, third column
                const secondRow = table.querySelector('tbody').rows[1];  // Get the second row (index 1)
                if (secondRow) {
                    const pathNameFromTable = secondRow.cells[2].textContent;  // Third column of second row
                    const pathNameFromMap = foundLayer.feature.properties.name;  // The name of the path where live coordinate lies
                    let interpolatedPoints = [];  // To store interpolated points for distance calculation
                    let skipFirstPath = false;  // Initialize variable to skip the first path
                    
                    // Compare the path names and call the appropriate highlighting function
if (pathNameFromTable === pathNameFromMap) {
    interpolatedPoints = highlightFarthestInterpolatedPath(liveLatLng, coordSource);  // Store interpolated points
    skipFirstPath = true;  // Skip the first path
} else {
    interpolatedPoints = highlightInterpolatedPath(liveLatLng, coordSource);  // Store interpolated points
}

// Step 4: Calculate the total distance for the first row using interpolated points
const totalInterpolatedDistance = calculateTotalDistance(interpolatedPoints);  // Total distance in meters

// Update the first row's distance cell with the total interpolated distance
newRow.cells[3].textContent = `${totalInterpolatedDistance.toFixed(2)} meters`;

// New logic to determine directions based on path names after calculating distance
if (pathNameFromTable === pathNameFromMap) {
    // If path names are the same, use the related path direction from directionsData
    const thirdRow = table.querySelector('tbody').rows[2];  // Check the third row
    if (thirdRow) {
        const nextPathName = thirdRow.cells[2].textContent;  // Get the third column of third row
        if (directionsData[pathNameFromMap] && directionsData[pathNameFromMap].related_paths[nextPathName]) {
            const direction = directionsData[pathNameFromMap].related_paths[nextPathName];
            newRow.cells[4].textContent = `Turn ${direction} after ${totalInterpolatedDistance.toFixed(2)} meters`;
        }
    }
} else {
    // If path names are different, provide a different direction
    const nextPathName = pathNameFromTable;  // Get next path name from table
    if (directionsData[pathNameFromMap] && directionsData[pathNameFromMap].related_paths[nextPathName]) {
        const direction = directionsData[pathNameFromMap].related_paths[nextPathName];
        newRow.cells[4].textContent = `Turn ${direction} after ${totalInterpolatedDistance.toFixed(2)} meters`;
    }
}

                      
                    // Highlight paths on the map
                    highlightPaths(result.path, skipFirstPath);  // Call the function with skipFirstPath flag
                } else {
                    console.log('The second row of the table does not exist.');
                }
                 
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});


// Function to interpolate between two coordinates, ensuring points are correctly placed even on straight lines
function interpolateCoordinates(coord1, coord2, numPoints) {
    let interpolatedPoints = [];
    let latDiff = coord2[1] - coord1[1];
    let lngDiff = coord2[0] - coord1[0];

    // Ensure we always interpolate even when the line is straight by dividing the lat and lng difference
    for (let i = 0; i <= numPoints; i++) {
        let factor = i / numPoints;  // Calculate interpolation factor (between 0 and 1)
        
        // Interpolate both latitude and longitude using linear interpolation
        let interpolatedLat = coord1[1] + (latDiff * factor);
        let interpolatedLng = coord1[0] + (lngDiff * factor);
        
        interpolatedPoints.push([interpolatedLng, interpolatedLat]);
    }

    return interpolatedPoints;
}


// Function to extract all coordinates including interpolated points along the LineString
function extractCoordinates(lineCoords, numInterpolatedPoints) {
    let allCoordinates = [];

    for (let i = 0; i < lineCoords.length - 1; i++) {
        let coord1 = [lineCoords[i].lng, lineCoords[i].lat];
        let coord2 = [lineCoords[i + 1].lng, lineCoords[i + 1].lat];
        let segmentPoints = interpolateCoordinates(coord1, coord2, numInterpolatedPoints);
        allCoordinates = allCoordinates.concat(segmentPoints);

        // Log the points from this segment
        segmentPoints.forEach(point => {
            console.log(`Interpolated Point: Latitude: ${point[1]}, Longitude: ${point[0]}`);
        });
    }

    return allCoordinates;
}


// Function to find the closest interpolated point to the live coordinate
function findClosestInterpolatedPoint(liveCoord, interpolatedPoints) {
    let closestPoint = null;
    let shortestDistance = Infinity;

    interpolatedPoints.forEach(point => {
        let pointLatLng = L.latLng(point[1], point[0]);
        let distance = calculateDistance(liveCoord, pointLatLng);
        if (distance < shortestDistance) {
            shortestDistance = distance;
            closestPoint = point;
        }
    });

    return closestPoint;
}

// Global variables to store the current polyline and circles
let currentPolyline = null;
let currentCircles = [];

// Function to remove the current polyline and circles from the map
function clearCurrentPolylineAndCircles() {
    if (currentPolyline) {
        map.removeLayer(currentPolyline);  // Remove the polyline from the map
        currentPolyline = null;  // Reset the reference
    }
    currentCircles.forEach(circle => {
        map.removeLayer(circle);  // Remove each circle from the map
    });
    currentCircles = [];  // Reset the array
}


// Modified function to find the closest path where live coordinates belong, interpolate points, and call the new function
function findPathContainingLiveCoordinate(liveLatLng) {
    let foundLayer = null;
    let closestPath = null;
    let shortestDistance = Infinity;

    // Iterate through all path layers to find the closest path to the live coordinate
    pathLayers.forEach(layerObj => {
        const lineCoords = layerObj.layer.getLatLngs();

        // Loop through each segment formed by consecutive points
        for (let i = 0; i < lineCoords.length - 1; i++) {
            const segmentStart = lineCoords[i];
            const segmentEnd = lineCoords[i + 1];

            // Project the liveLatLng onto the current segment
            const projectedPoint = projectOntoSegment(liveLatLng, segmentStart, segmentEnd);

            // Calculate the distance between the liveLatLng and the projected point
            const distance = calculateDistance(liveLatLng, projectedPoint);

            // Check if the projected point is on the segment and if the distance is smaller than our threshold
            if (isPointOnSegment(projectedPoint, segmentStart, segmentEnd) && distance < 2 && distance < shortestDistance) {
                foundLayer = layerObj.layer;
                shortestDistance = distance;
                closestPath = layerObj;
            }
        }
    });

    // If a path is found
    if (closestPath) {
        console.log(`Live coordinate belongs to path: ${closestPath.name}`);

        // Get the coordinates of the LineString where live coordinates lie
        const lineCoords = closestPath.layer.getLatLngs();

        // Interpolate 1000 points along the path
        const interpolatedPoints = extractCoordinates(lineCoords, 1000);

        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, interpolatedPoints);

        // Find the nearest endpoint to the live coordinate
        const nearestEndpoint = findNearestEndpoint(liveLatLng, lineCoords);

        // Find the farthest endpoint to the live coordinate
        const farthestEndpoint = findFarthestEndpoint(liveLatLng, lineCoords);

        // Log the live coordinate, the closest interpolated point, nearest endpoint, and farthest endpoint
        console.log(`Live coordinate: ${liveLatLng.lat}, ${liveLatLng.lng}`);
        console.log(`Closest interpolated point: ${closestInterpolatedPoint[1]}, ${closestInterpolatedPoint[0]}`);
        console.log(`Nearest endpoint: ${nearestEndpoint.lat}, ${nearestEndpoint.lng}`);
        console.log(`Farthest endpoint: ${farthestEndpoint.lat}, ${farthestEndpoint.lng}`);
    } else {
        console.log('No matching path found for the live coordinate.');
    }

    return foundLayer;
}

// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Helper function to project a point onto a line segment
function projectOntoSegment(point, segmentStart, segmentEnd) {
    const x1 = segmentStart.lng, y1 = segmentStart.lat;
    const x2 = segmentEnd.lng, y2 = segmentEnd.lat;
    const x3 = point.lng, y3 = point.lat;

    const px = x2 - x1;
    const py = y2 - y1;
    const norm = px * px + py * py;
    const u = ((x3 - x1) * px + (y3 - y1) * py) / norm;

    const clampedU = Math.max(Math.min(u, 1), 0); // Clamp the projection factor to [0, 1]
    return L.latLng(y1 + clampedU * py, x1 + clampedU * px);
}

// Helper function to check if a point is on a segment between two points (using a small tolerance)
function isPointOnSegment(point, segmentStart, segmentEnd) {
    const tolerance = 0.00001; // Adjust tolerance as needed
    const minLat = Math.min(segmentStart.lat, segmentEnd.lat) - tolerance;
    const maxLat = Math.max(segmentStart.lat, segmentEnd.lat) + tolerance;
    const minLng = Math.min(segmentStart.lng, segmentEnd.lng) - tolerance;
    const maxLng = Math.max(segmentStart.lng, segmentEnd.lng) + tolerance;

    return point.lat >= minLat && point.lat <= maxLat && point.lng >= minLng && point.lng <= maxLng;
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}

// Function to find the farthest endpoint (first or last) of a LineString to the selected coordinate
function findFarthestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the farther endpoint
    return distanceToFirst > distanceToLast ? firstPoint : lastPoint;
}


    </script>
</body>
</html>


document.getElementById('liveLocationBtn').addEventListener('click', function() {
    if (navigator.geolocation) {
        alert("Please turn on your live location.");

        // Get user's live location
        navigator.geolocation.getCurrentPosition(
            function(position) {
                const liveLat = position.coords.latitude;
                const liveLng = position.coords.longitude;

                // Check if live location is within USIU border
                if (isPointInUSIUBorder(liveLat, liveLng)) {
                    // If inside the border, show controlsLive and update the map
                    document.getElementById('controlsLive').style.display = 'block';
                    document.getElementById('liveCoordSource1').value = `${liveLat}, ${liveLng}`;
                    map.setView([liveLat, liveLng], 15);

                    // Add marker for live location on the map
                    const liveLocationMarker = L.marker([liveLat, liveLng], { title: "Your Live Location" }).addTo(map);
                    liveLocationMarker.bindPopup("Your Current Location").openPopup();
                } else {
                    // If outside the border, alert the user and do not show controlsLive
                    alert("You are located outside USIU. Please use other options.");
                }
            },
            function(error) {
                alert("Unable to retrieve your location. Please ensure location services are enabled.");
            }
        );
    } else {
        alert("Geolocation is not supported by this browser.");
    }
});


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background-color: white;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 90vh;
            width: 100vw;
        }

        #controls1 {
            position: left;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            display:none;
        }
        #controls2 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        #controls3 {
            position: right;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="controls1">
        <select id="featureSelect">
            <option value="">Select a feature</option>
        </select>
        <button id="searchBtn">Search</button>
    </div><br>

    <div id="controls2">
        <label for="source">Source:</label>
        <select id="source">
            <option value="">Select Source</option>
        </select>

        <label for="destination">Destination:</label>
        <select id="destination">
            <option value="">Select Destination</option>
        </select>

        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>

        <button id="searchBtn1">Search</button>
        
        <div id="result"></div>
        <table id="pathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    
    <div id="controls3">
        <label for="coordSource">Choose the Source by clicking on the map:</label>
        <input type="text" id="coordSource1" readonly />
        <input type="text" id="coordSource" readonly />
    
        <label for="coordDestination">Destination:</label>
        <select id="coordDestination">
            <option value="">Select Destination</option>
        </select>
    
        <label for="coordMode">Mode:</label>
        <select id="coordMode">
            <option value="">Select Mode</option>
            <option value="walking">Walking</option>
            <option value="driving">Driving</option>
            <option value="disabled">Disabled</option>
        </select>
    
        <button id="coordSearchBtn">Search</button>
    
        <div id="coordResult"></div>
        <table id="coordPathTable" border="1" style="display:none;">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Path</th>
                    <th>Distance</th>
                    <th>Directions</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    <!-- Live Location Button -->
<button id="liveLocationBtn" style="position: fixed; top: 10px; right: 10px; z-index: 1000;">Live Location</button>

<!-- New Interface for Live Location (Similar to controls3) -->
<div id="controlsLive" style="display: none;">
    <label for="liveCoordSource">Your Current Location:</label>
    <input type="text" id="liveCoordSource1" readonly />

    <label for="liveCoordDestination">Destination:</label>
    <select id="liveCoordDestination">
        <option value="">Select Destination</option>
    </select>

    <label for="liveCoordMode">Mode:</label>
    <select id="liveCoordMode">
        <option value="">Select Mode</option>
        <option value="walking">Walking</option>
        <option value="driving">Driving</option>
        <option value="disabled">Disabled</option>
    </select>

    <button id="liveCoordSearchBtn">Search</button>

    <div id="liveCoordResult"></div>
    <table id="liveCoordPathTable" border="1" style="display: none;">
        <thead>
            <tr>
                <th>From</th>
                <th>To</th>
                <th>Path</th>
                <th>Distance</th>
                <th>Directions</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>
</div>

    

    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([-1.219737, 36.879385], 15);

        // Store layers for later reference
        var featureLayers = [];
        var pathLayers = [];
        var usiuBorderLayer;

        fetch('14.geojson')
    .then(response => response.json())
    .then(data => {
        var featureSelect = document.getElementById('featureSelect');
        L.geoJSON(data, {
            pointToLayer: function (feature, latlng) {
                var marker = L.marker(latlng);
                marker.bindPopup(feature.properties.name);
                featureLayers.push({
                    name: feature.properties.name,
                    layer: marker,
                    featureType: feature.geometry.type
                });
                return marker;
            },
            style: function (feature) {
                var isUSIUBorder = feature.properties.name === 'USIU BORDER';
                return {
                    color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                    fillColor: isUSIUBorder ? '#27a147 ' : (feature.properties.fillColor || '#ccc'),
                    fillOpacity: isUSIUBorder ? 1 : 0.7,
                    weight: isUSIUBorder ? 5 : 2,
                    zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                };
            },
            onEachFeature: function (feature, layer) {
                var option = document.createElement('option');
                option.value = feature.properties.name;
                option.text = feature.properties.name;
                featureSelect.appendChild(option);

                // Register live coordinates for any clicked feature except 'USIU BORDER'
                layer.on('click', function (e) {
                    var latlng = e.latlng; // Get the coordinates of the clicked point

                    // Handle 'USIU BORDER' clicks (clear inputs)
                    if (feature.properties.name === 'USIU BORDER') {
                        document.getElementById('coordSource1').value = '';
                        document.getElementById('coordSource').value = '';
                        return; // Exit, no further processing for USIU BORDER
                    }

                    // Handle LineString or Polygon features (excluding 'USIU BORDER')
                    if (feature.geometry.type === "LineString" || feature.geometry.type === "Polygon") {
                        // Update the first input with live coordinates of the clicked point
                        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

                        // Handle LineString features for nearest endpoint
                        if (feature.geometry.type === "LineString") {
                            const lineCoords = layer.getLatLngs(); // Get the coordinates of the LineString

                            // Find the closest endpoint of the clicked LineString
                            const closestEndpoint = findNearestEndpoint(latlng, lineCoords);

                            // Update the second input with the closest endpoint of the LineString
                            document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                        } else {
                            // Clear coordSource input for Polygons, as no nearest endpoint is needed
                            document.getElementById('coordSource').value = '';
                        }
                    }
                });

                if (feature.geometry.type === "LineString") {
                    pathLayers.push({
                        name: feature.properties.name,
                        layer: layer
                    });
                }

                if (feature.properties && feature.properties.name) {
                    layer.bindPopup(feature.properties.name);
                }
            }
        }).addTo(map);

        if (usiuBorderLayer) {
            var maskBounds = usiuBorderLayer.getBounds();
            L.polygon(usiuBorderLayer.getLatLngs(), {
                color: '#000',
                fillColor: '#fff',
                fillOpacity: 1,
                zIndex: 1000
            }).addTo(map);
        }
    })
    .catch(error => console.error('Error loading the GeoJSON file:', error));


    map.on('click', function(e) {
    var latlng = e.latlng;

    // Reset the validity flag
    var isValidFeature = false;
    var closestFeature = null;
    var shortestDistance = Infinity;

    // Loop through the featureLayers to check if clicked on LineString or Polygon (excluding 'USIU BORDER')
    featureLayers.forEach(function(featureLayer) {
        // Exclude "USIU BORDER" explicitly
        if (featureLayer.name === 'USIU BORDER') {
            return; // Skip processing for USIU BORDER
        }

        // Handle LineStrings
        if (featureLayer.featureType === 'LineString') {
            const lineCoords = featureLayer.layer.getLatLngs();
            const nearestEndpoint = findNearestEndpoint(latlng, lineCoords);
            const distanceToNearest = calculateDistance(latlng, nearestEndpoint);

            // Check if click is near the LineString (adjust distance threshold as needed)
            if (distanceToNearest < 2 && distanceToNearest < shortestDistance) {
                isValidFeature = true; // Valid LineString feature clicked
                shortestDistance = distanceToNearest; // Track the closest distance
                closestFeature = featureLayer; // Track the closest feature
            }
        }
        // Handle Polygons
        else if (featureLayer.featureType === 'Polygon') {
            if (featureLayer.layer.getBounds().contains(latlng)) {
                isValidFeature = true; // Valid Polygon feature clicked
            }
        }
    });
 // If the click was on a valid LineString, interpolate and log the points
 if (isValidFeature && closestFeature) {
        const lineCoords = closestFeature.layer.getLatLngs();
        
        // Interpolate 1000 points along the LineString
        const interpolatedPoints = extractCoordinates(lineCoords, 1000);
        
        // Log all interpolated points to the console
        console.log('Interpolated points along the clicked LineString:');
        interpolatedPoints.forEach(point => {
            console.log(`Latitude: ${point[1]}, Longitude: ${point[0]}`);
        });
    } else {
        console.log('Click was not on a valid LineString.');
    }
    // If the click was on a valid LineString or Polygon (excluding USIU BORDER), update the coordSource1 with live coordinates
    if (isValidFeature) {
        document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

        // Log the closest LineString name to the console
        if (closestFeature && closestFeature.name) {
            console.log(`The closest LineString is: ${closestFeature.name}`);
        }
    } else {
        // If the click was outside valid features or on 'USIU BORDER', clear the input
        document.getElementById('coordSource1').value = '';
        document.getElementById('coordSource').value = '';
    }

    // Find the nearest endpoint of the LineString and update coordSource (second input)
    var nearestEndpoint = findNearestPoint(latlng, featureLayers);
    if (nearestEndpoint && nearestEndpoint.latLng) {
        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
    } else {
        document.getElementById('coordSource').value = 'No nearest endpoint found';
    }
});




        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }
// Add custom locations and map them to specific points
const customLocations = {
    "USIU GATE A": "POINT 86",
    "USIU GATE B": "POINT 100",
    "LIBRARY": "POINT 150",
    "SCHOOL OF HUMANITIES": "POINT 200",
    "ADMINISTRATION": "POINT 200",
    "SWIMMING POOL": "POINT 250"
};
        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        
// Populate the dropdowns with custom locations
Object.keys(customLocations).forEach(location => {
        const point = customLocations[location];

        const optionSource = document.createElement('option');
        optionSource.value = point; // Map custom location to POINT value
        optionSource.textContent = location;
        sourceSelect.appendChild(optionSource);

        const optionDestination = document.createElement('option');
        optionDestination.value = point; // Map custom location to POINT value
        optionDestination.textContent = location;
        destinationSelect.appendChild(optionDestination);

        const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point; // Map custom location to POINT value
        optionCoordDestination.textContent = location;
        coordDestinationSelect.appendChild(optionCoordDestination);
    });
}

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

// Update the search button click handler to also populate the directions
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = ''; // Clear previous results

                // Iterate through the result path to populate the table and add directions
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                table.style.display = 'table';

                // Highlight paths on the map
                highlightPaths(result.path);
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

function highlightPaths(paths, skipFirstPath) {
    // Reset all path colors to default
    pathLayers.forEach(layerObj => {
        layerObj.layer.setStyle({
            color: layerObj.layer.feature.properties.borderColor || '#000',
            fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
        });

        // Remove previous polylines (if any)
        if (layerObj.polyline) {
            map.removeLayer(layerObj.polyline);
        }
    });

    // Highlight the paths that are part of the shortest route
    paths.forEach(({ path, from, to }, index) => {
        // Skip the first path if the skipFirstPath flag is true
        if (index === 0 && skipFirstPath) {
            console.log(`Skipping highlighting for path: ${path}`);
            return;
        }

        const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
        if (matchingLayer) {
            // Set the color to red for the shortest route
            matchingLayer.layer.setStyle({ color: 'red' });

            // Extract the coordinates from the matching path layer and draw a polyline
            const coordinates = matchingLayer.layer.feature.geometry.coordinates.map(coord => [coord[1], coord[0]]); // Switch lat, lon

            const polyline = L.polyline(coordinates, { color: 'red', weight: 2 }).addTo(map);

            // Store the polyline on the layer object for potential future cleanup
            matchingLayer.polyline = polyline;
        }
    });
}



// Global variable to store the previously drawn polyline
let previousPolyline = null;

// New function to find the closest interpolated point, nearest endpoint, and draw the black polyline
function highlightInterpolatedPath(liveLatLng, coordSource) {
    // Clear the previous polyline if it exists
    if (previousPolyline) {
        map.removeLayer(previousPolyline); // Remove the previous polyline from the map
        previousPolyline = null; // Reset the variable
    }

    const pathLayer = findPathContainingLiveCoordinate(liveLatLng);

    if (pathLayer) {
        const lineCoords = pathLayer.getLatLngs();
        
        // Extract all the coordinates from the path (with interpolation)
        const extractedCoords = extractCoordinates(lineCoords, 1000); // You can adjust the number of interpolated points
        
        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
        
        // Find the nearest endpoint to the live coordinate
        const nearestEndpoint = findNearestEndpoint(liveLatLng, lineCoords);

        // Find the index of the closest interpolated point and nearest endpoint in the extracted coordinates
        const closestIndex = extractedCoords.findIndex(coord =>
            coord[0] === closestInterpolatedPoint[0] && coord[1] === closestInterpolatedPoint[1]);
        const nearestIndex = extractedCoords.findIndex(coord =>
            coord[0] === nearestEndpoint.lng && coord[1] === nearestEndpoint.lat);

        // Ensure the indices are valid and log the range of coordinates between them
        if (closestIndex !== -1 && nearestIndex !== -1) {
            const startIndex = Math.min(closestIndex, nearestIndex);
            const endIndex = Math.max(closestIndex, nearestIndex);

            console.log('Coordinates between the closest interpolated point and the nearest endpoint:');
            
            // Store the coordinates to connect them with a polyline
            const coordsToConnect = [];
            for (let i = startIndex; i <= endIndex; i++) {
                coordsToConnect.push([extractedCoords[i][1], extractedCoords[i][0]]);  // Store the coordinate in [lat, lng] format
            }

            // Draw a black polyline connecting the coordinates (new polyline)
            previousPolyline = L.polyline(coordsToConnect, { color: 'red', weight: 2 }).addTo(map);

            return coordsToConnect;  // Return the coordinates for distance calculation

        } else {
            console.log('Could not find valid indices for closest point or nearest endpoint.');
        }
    } else {
        console.log('No matching path found for the live coordinate.');
    }

    return [];  // Return empty if no valid path was found
}

// Global variable to store the previously drawn polyline for the farthest endpoint
let previousFarthestPolyline = null;

// New function to find the closest interpolated point, farthest endpoint, and draw the green polyline
function highlightFarthestInterpolatedPath(liveLatLng, coordSource) {
    // Clear the previous polyline if it exists
    if (previousFarthestPolyline) {
        map.removeLayer(previousFarthestPolyline); // Remove the previous polyline from the map
        previousFarthestPolyline = null; // Reset the variable
    }

    const pathLayer = findPathContainingLiveCoordinate(liveLatLng);

    if (pathLayer) {
        const lineCoords = pathLayer.getLatLngs();
        
        // Extract all the coordinates from the path (with interpolation)
        const extractedCoords = extractCoordinates(lineCoords, 1000); // You can adjust the number of interpolated points
        
        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
        
        // Find the farthest endpoint to the live coordinate
        const farthestEndpoint = findFarthestEndpoint(liveLatLng, lineCoords);

        // Find the index of the closest interpolated point and farthest endpoint in the extracted coordinates
        const closestIndex = extractedCoords.findIndex(coord =>
            coord[0] === closestInterpolatedPoint[0] && coord[1] === closestInterpolatedPoint[1]);
        const farthestIndex = extractedCoords.findIndex(coord =>
            coord[0] === farthestEndpoint.lng && coord[1] === farthestEndpoint.lat);

        // Ensure the indices are valid and log the range of coordinates between them
        if (closestIndex !== -1 && farthestIndex !== -1) {
            const startIndex = Math.min(closestIndex, farthestIndex);
            const endIndex = Math.max(closestIndex, farthestIndex);

            console.log('Coordinates between the closest interpolated point and the farthest endpoint:');
            
            // Store the coordinates to connect them with a polyline
            const coordsToConnect = [];
            for (let i = startIndex; i <= endIndex; i++) {
                coordsToConnect.push([extractedCoords[i][1], extractedCoords[i][0]]);  // Store the coordinate in [lat, lng] format
            }

            // Draw a green polyline connecting the coordinates (new polyline)
            previousFarthestPolyline = L.polyline(coordsToConnect, { color: 'red', weight: 3 }).addTo(map);

            return coordsToConnect;  // Return the coordinates for distance calculation

        } else {
            console.log('Could not find valid indices for closest point or farthest endpoint.');
        }
    } else {
        console.log('No matching path found for the live coordinate.');
    }

    return [];  // Return empty if no valid path was found
}

// Function to calculate total distance between a list of coordinates
function calculateTotalDistance(coords) {
    let totalDistance = 0;
    for (let i = 0; i < coords.length - 1; i++) {
        const pointA = L.latLng(coords[i][0], coords[i][1]);
        const pointB = L.latLng(coords[i + 1][0], coords[i + 1][1]);
        totalDistance += pointA.distanceTo(pointB); // Calculate distance between two points
    }
    return totalDistance;
}

document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;

    if (!coordSource || !coordDestination || !coordMode) {
        alert('Please select source, destination, and mode.');
        return;
    }
    if (previousPolyline) {
        map.removeLayer(previousPolyline);
        previousPolyline = null; // Reset
    }
    if (previousFarthestPolyline) {
        map.removeLayer(previousFarthestPolyline);
        previousFarthestPolyline = null; // Reset
    }
    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const liveLatLng = L.latLng(lat1, lng1);  // Live coordinate (coordSource1)

    // Call the function to find the path containing the live coordinate
    const foundLayer = findPathContainingLiveCoordinate(liveLatLng);
    if (!foundLayer) {
        console.log('No matching path found for the live coordinate.');
        return;
    }

    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results

                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';

                // New Section: Check path in second row, third column
                const secondRow = table.querySelector('tbody').rows[1];  // Get the second row (index 1)
                if (secondRow) {
                    const pathNameFromTable = secondRow.cells[2].textContent;  // Third column of second row
                    const pathNameFromMap = foundLayer.feature.properties.name;  // The name of the path where live coordinate lies
                    let interpolatedPoints = [];  // To store interpolated points for distance calculation
                    let skipFirstPath = false;  // Initialize variable to skip the first path
                    
                    // Compare the path names and call the appropriate highlighting function
if (pathNameFromTable === pathNameFromMap) {
    interpolatedPoints = highlightFarthestInterpolatedPath(liveLatLng, coordSource);  // Store interpolated points
    skipFirstPath = true;  // Skip the first path
} else {
    interpolatedPoints = highlightInterpolatedPath(liveLatLng, coordSource);  // Store interpolated points
}

// Step 4: Calculate the total distance for the first row using interpolated points
const totalInterpolatedDistance = calculateTotalDistance(interpolatedPoints);  // Total distance in meters

// Update the first row's distance cell with the total interpolated distance
newRow.cells[3].textContent = `${totalInterpolatedDistance.toFixed(2)} meters`;

// New logic to determine directions based on path names after calculating distance
if (pathNameFromTable === pathNameFromMap) {
    // If path names are the same, use the related path direction from directionsData
    const thirdRow = table.querySelector('tbody').rows[2];  // Check the third row
    if (thirdRow) {
        const nextPathName = thirdRow.cells[2].textContent;  // Get the third column of third row
        if (directionsData[pathNameFromMap] && directionsData[pathNameFromMap].related_paths[nextPathName]) {
            const direction = directionsData[pathNameFromMap].related_paths[nextPathName];
            newRow.cells[4].textContent = `${direction} after ${totalInterpolatedDistance.toFixed(2)} meters`;
        }
    }
} else {
    // If path names are different, provide a different direction
    const nextPathName = pathNameFromTable;  // Get next path name from table
    if (directionsData[pathNameFromMap] && directionsData[pathNameFromMap].related_paths[nextPathName]) {
        const direction = directionsData[pathNameFromMap].related_paths[nextPathName];
        newRow.cells[4].textContent = `${direction} after ${totalInterpolatedDistance.toFixed(2)} meters`;
    }
}

                      
                    // Highlight paths on the map
                    highlightPaths(result.path, skipFirstPath);  // Call the function with skipFirstPath flag
                } else {
                    console.log('The second row of the table does not exist.');
                }
                 
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});


// Function to interpolate between two coordinates, ensuring points are correctly placed even on straight lines
function interpolateCoordinates(coord1, coord2, numPoints) {
    let interpolatedPoints = [];
    let latDiff = coord2[1] - coord1[1];
    let lngDiff = coord2[0] - coord1[0];

    // Ensure we always interpolate even when the line is straight by dividing the lat and lng difference
    for (let i = 0; i <= numPoints; i++) {
        let factor = i / numPoints;  // Calculate interpolation factor (between 0 and 1)
        
        // Interpolate both latitude and longitude using linear interpolation
        let interpolatedLat = coord1[1] + (latDiff * factor);
        let interpolatedLng = coord1[0] + (lngDiff * factor);
        
        interpolatedPoints.push([interpolatedLng, interpolatedLat]);
    }

    return interpolatedPoints;
}


// Function to extract all coordinates including interpolated points along the LineString
function extractCoordinates(lineCoords, numInterpolatedPoints) {
    let allCoordinates = [];

    for (let i = 0; i < lineCoords.length - 1; i++) {
        let coord1 = [lineCoords[i].lng, lineCoords[i].lat];
        let coord2 = [lineCoords[i + 1].lng, lineCoords[i + 1].lat];
        let segmentPoints = interpolateCoordinates(coord1, coord2, numInterpolatedPoints);
        allCoordinates = allCoordinates.concat(segmentPoints);

        // Log the points from this segment
        segmentPoints.forEach(point => {
            console.log(`Interpolated Point: Latitude: ${point[1]}, Longitude: ${point[0]}`);
        });
    }

    return allCoordinates;
}


// Function to find the closest interpolated point to the live coordinate
function findClosestInterpolatedPoint(liveCoord, interpolatedPoints) {
    let closestPoint = null;
    let shortestDistance = Infinity;

    interpolatedPoints.forEach(point => {
        let pointLatLng = L.latLng(point[1], point[0]);
        let distance = calculateDistance(liveCoord, pointLatLng);
        if (distance < shortestDistance) {
            shortestDistance = distance;
            closestPoint = point;
        }
    });

    return closestPoint;
}

// Global variables to store the current polyline and circles
let currentPolyline = null;
let currentCircles = [];

// Function to remove the current polyline and circles from the map
function clearCurrentPolylineAndCircles() {
    if (currentPolyline) {
        map.removeLayer(currentPolyline);  // Remove the polyline from the map
        currentPolyline = null;  // Reset the reference
    }
    currentCircles.forEach(circle => {
        map.removeLayer(circle);  // Remove each circle from the map
    });
    currentCircles = [];  // Reset the array
}


// Modified function to find the closest path where live coordinates belong, interpolate points, and call the new function
function findPathContainingLiveCoordinate(liveLatLng) {
    let foundLayer = null;
    let closestPath = null;
    let shortestDistance = Infinity;

    // Iterate through all path layers to find the closest path to the live coordinate
    pathLayers.forEach(layerObj => {
        const lineCoords = layerObj.layer.getLatLngs();

        // Loop through each segment formed by consecutive points
        for (let i = 0; i < lineCoords.length - 1; i++) {
            const segmentStart = lineCoords[i];
            const segmentEnd = lineCoords[i + 1];

            // Project the liveLatLng onto the current segment
            const projectedPoint = projectOntoSegment(liveLatLng, segmentStart, segmentEnd);

            // Calculate the distance between the liveLatLng and the projected point
            const distance = calculateDistance(liveLatLng, projectedPoint);

            // Check if the projected point is on the segment and if the distance is smaller than our threshold
            if (isPointOnSegment(projectedPoint, segmentStart, segmentEnd) && distance < 2 && distance < shortestDistance) {
                foundLayer = layerObj.layer;
                shortestDistance = distance;
                closestPath = layerObj;
            }
        }
    });

    // If a path is found
    if (closestPath) {
        console.log(`Live coordinate belongs to path: ${closestPath.name}`);

        // Get the coordinates of the LineString where live coordinates lie
        const lineCoords = closestPath.layer.getLatLngs();

        // Interpolate 1000 points along the path
        const interpolatedPoints = extractCoordinates(lineCoords, 1000);

        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, interpolatedPoints);

        // Find the nearest endpoint to the live coordinate
        const nearestEndpoint = findNearestEndpoint(liveLatLng, lineCoords);

        // Find the farthest endpoint to the live coordinate
        const farthestEndpoint = findFarthestEndpoint(liveLatLng, lineCoords);

        // Log the live coordinate, the closest interpolated point, nearest endpoint, and farthest endpoint
        console.log(`Live coordinate: ${liveLatLng.lat}, ${liveLatLng.lng}`);
        console.log(`Closest interpolated point: ${closestInterpolatedPoint[1]}, ${closestInterpolatedPoint[0]}`);
        console.log(`Nearest endpoint: ${nearestEndpoint.lat}, ${nearestEndpoint.lng}`);
        console.log(`Farthest endpoint: ${farthestEndpoint.lat}, ${farthestEndpoint.lng}`);
    } else {
        console.log('No matching path found for the live coordinate.');
    }

    return foundLayer;
}

// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Helper function to project a point onto a line segment
function projectOntoSegment(point, segmentStart, segmentEnd) {
    const x1 = segmentStart.lng, y1 = segmentStart.lat;
    const x2 = segmentEnd.lng, y2 = segmentEnd.lat;
    const x3 = point.lng, y3 = point.lat;

    const px = x2 - x1;
    const py = y2 - y1;
    const norm = px * px + py * py;
    const u = ((x3 - x1) * px + (y3 - y1) * py) / norm;

    const clampedU = Math.max(Math.min(u, 1), 0); // Clamp the projection factor to [0, 1]
    return L.latLng(y1 + clampedU * py, x1 + clampedU * px);
}

// Helper function to check if a point is on a segment between two points (using a small tolerance)
function isPointOnSegment(point, segmentStart, segmentEnd) {
    const tolerance = 0.00001; // Adjust tolerance as needed
    const minLat = Math.min(segmentStart.lat, segmentEnd.lat) - tolerance;
    const maxLat = Math.max(segmentStart.lat, segmentEnd.lat) + tolerance;
    const minLng = Math.min(segmentStart.lng, segmentEnd.lng) - tolerance;
    const maxLng = Math.max(segmentStart.lng, segmentEnd.lng) + tolerance;

    return point.lat >= minLat && point.lat <= maxLat && point.lng >= minLng && point.lng <= maxLng;
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}

// Function to find the farthest endpoint (first or last) of a LineString to the selected coordinate
function findFarthestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the farther endpoint
    return distanceToFirst > distanceToLast ? firstPoint : lastPoint;
}


// USIU Border Polygon Coordinates
const usiuBorderCoordinates = [
    [36.87955443924471, -1.219551075108555],
    [36.88037134879136, -1.217190265152894],
    [36.87947858336054, -1.216892743808472],
    [36.88008371098167, -1.215087768554767],
    [36.88062053725127, -1.213538202193178],
    [36.88105035207693, -1.212298748613264],
    [36.88155652792798, -1.210725392425729],
    [36.8820396957874, -1.209330117409436],
    [36.88198601046969, -1.209157595889621],
    [36.88250614385259, -1.207667519774219],
    [36.88192597175444, -1.207468611988716],
    [36.87976691605007, -1.208590633902929],
    [36.87943118459978, -1.209578710366813],
    [36.87901302624101, -1.210807708413114],
    [36.87837584694205, -1.21256479572547],
    [36.87783371200825, -1.214185746911923],
    [36.87705033861167, -1.21648884154898],
    [36.87682962626818, -1.217160153032182],
    [36.87707956928878, -1.217452297793216],
    [36.87821893293008, -1.218665855956189],
    [36.8790042397402, -1.21947140938309],
    [36.87932697817411, -1.219782232991832],
    [36.87955443924471, -1.219551075108555]
];
// Function to check if a point is within the USIU border polygon
function isPointInUSIUBorder(lat, lng) {
    // Create a Leaflet polygon using USIU border coordinates
    const usiuBorderPolygon = L.polygon(usiuBorderCoordinates.map(coord => [coord[1], coord[0]]));
    
    // Check if the point is inside the polygon
    return usiuBorderPolygon.getBounds().contains(L.latLng(lat, lng));
}

document.getElementById('liveLocationBtn').addEventListener('click', function() {
    if (navigator.geolocation) {
        alert("Please turn on your live location.");

        // Get user's live location
        navigator.geolocation.getCurrentPosition(
            function(position) {
                const liveLat = position.coords.latitude;
                const liveLng = position.coords.longitude;

                // Show controlsLive interface
                document.getElementById('controlsLive').style.display = 'block';
                document.getElementById('liveCoordSource1').value = `${liveLat}, ${liveLng}`;
                map.setView([liveLat, liveLng], 15);

                // Add a temporary draggable marker for the live location
                const liveLocationMarker = L.marker([liveLat, liveLng], {
                    title: "Your Current Location",
                    draggable: true // Make the marker draggable
                }).addTo(map);
                
                let previousHighlightedPath = null; // Track the previously highlighted path layer

                // Function to update nearest path and display on the map
                function updateNearestPath(latLng) {
                    const closestPathLayer = findClosestPathToLiveCoordinate(latLng);

                    // Remove the previous highlighted path if it exists
                    if (previousHighlightedPath) {
                        previousHighlightedPath.setStyle({
                            color: previousHighlightedPath.feature.properties.borderColor || '#000'
                        });
                    }

                    if (closestPathLayer) {
                        const pathName = closestPathLayer.feature.properties.name;

                        // Highlight the current nearest path
                        closestPathLayer.setStyle({ color: 'red' });
                        previousHighlightedPath = closestPathLayer; // Update the reference

                        // Update the popup to display the closest path name
                        liveLocationMarker.bindPopup(`Closest path: ${pathName}`).openPopup();
                    } else {
                        liveLocationMarker.bindPopup('No matching path found nearby.').openPopup();
                    }
                }

                // Initial nearest path calculation for starting location
                updateNearestPath(L.latLng(liveLat, liveLng));

                // Update input field and find nearest path when marker is moved
                liveLocationMarker.on('move', function(event) {
                    const newLatLng = event.latlng;
                    document.getElementById('liveCoordSource1').value = `${newLatLng.lat}, ${newLatLng.lng}`;
                    updateNearestPath(newLatLng);
                });

                // When you're ready to use exact live location, remove this block:
                /*
                liveLocationMarker.dragging.disable(); // Make marker non-draggable
                map.removeLayer(liveLocationMarker); // Remove the temporary marker
                */
            },
            function(error) {
                alert("Unable to retrieve your location. Please ensure location services are enabled.");
            }
        );
    } else {
        alert("Geolocation is not supported by this browser.");
    }
});

function findClosestPathToLiveCoordinate(liveLatLng) {
    let closestPathLayer = null;
    let shortestDistance = Infinity;

    pathLayers.forEach(layerObj => {
        const lineCoords = layerObj.layer.getLatLngs();

        // Iterate through each segment of the LineString
        for (let i = 0; i < lineCoords.length - 1; i++) {
            const segmentStart = lineCoords[i];
            const segmentEnd = lineCoords[i + 1];

            // Project the liveLatLng onto the current segment
            const projectedPoint = projectOntoSegment(liveLatLng, segmentStart, segmentEnd);

            // Calculate the distance between liveLatLng and the projected point
            const distance = calculateDistance(liveLatLng, projectedPoint);

            // Update if this distance is shorter than previously found distances
            if (distance < shortestDistance) {
                shortestDistance = distance;
                closestPathLayer = layerObj.layer;
            }
        }
    });

    // Log the closest path layer information for debugging
    if (closestPathLayer) {
        console.log(`The closest path to the live coordinate is: ${closestPathLayer.feature.properties.name}`);
        // Optionally, highlight the closest path here
        closestPathLayer.setStyle({ color: 'blue', weight: 3 });
    } else {
        console.log("No path found close to the live coordinate.");
    }

    return closestPathLayer;
}


// Populate destinations for live location interface
function populateLiveDropdown() {
    const liveCoordDestinationSelect = document.getElementById('liveCoordDestination');
    liveCoordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';
    
    // Populate with available points and custom locations
    availablePoints.forEach(point => {
        const option = document.createElement('option');
        option.value = point;
        option.textContent = point;
        liveCoordDestinationSelect.appendChild(option);
    });

    Object.keys(customLocations).forEach(location => {
        const point = customLocations[location];
        const option = document.createElement('option');
        option.value = point;
        option.textContent = location;
        liveCoordDestinationSelect.appendChild(option);
    });
}

// Call the function to populate dropdowns for live location when the page loads
document.addEventListener('DOMContentLoaded', populateLiveDropdown);


    </script>
</body>
</html>


