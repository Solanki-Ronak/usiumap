<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <title>Masked GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
.next-direction-container {
    margin-top: 8px;
    padding: 12px 15px;
    background-color: #333;
    border-radius: 4px;
    font-size: 0.9em;
    color: #ccc;
}

.next-direction-prefix {
    color: #ff6600;
    font-weight: bold;
    margin-right: 8px;
    font-size: 0.95em;
    display: block;
    margin-bottom: 4px;
}

.next-direction-text {
    color: #fff;
    font-size: 0.95em;
}

.next-direction-container img {
    width: 20px;
    height: 20px;
    object-fit: contain;
    vertical-align: middle;
}
.direction-from-table {
    background-color: #333;
    color: white;
    font-size: 1.2em;
    padding: 15px;
    margin: 30px 0;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    transition: background-color 0.3s ease, color 0.3s ease;
}

    /* Basic Reset */
/* Basic Reset and Container Styles */
body, html {
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}
h1, h2, h3, h4, h5, h6, 
.heading-wrapper, 
#sourceHeading, 
#destinationHeading,
#sub9DestinationHeading1,
#sub9DestinationHeading2,
#sub8SourceHeading,
#sub8DestinationHeading,
#sub9SourceHeading,
#sub9DestinationHeading {
    font-family: 'Poppins', sans-serif;
    font-weight: 600;
    letter-spacing: -0.02em;
}

.button-text {
    font-family: 'Poppins', sans-serif;
    font-weight: 500;
}
.container {
    display: flex;
    width: 100%;
    height: 100vh;
}

/* Map Styles */
#map {
    width: 70%;
    height: 100%;
}

/* Controls Container */
#controls {
    width: 30%;
    height: 100%;
    background-color: #000;
    position: relative;
    overflow: hidden;
}
#directionDisplayContainer{
    display: none;
    
}
/* Controls Part 1 */
#controlspart1 {
    display: none;
    background-color: #000;
    color: white;
    height: 100%;
    overflow-y: auto;
}

#controlspart2 {
    height: 100%;
    background-color: #000;
    position: relative;
    overflow: hidden;
    width: 100%; /* Add this */
}

#searchContainer {
    position: sticky;
    top: 0;
    width: 100%;
    padding: 10px 20px;
    background-color: #000;
    z-index: 1000;
    display: flex;
    justify-content: center;
    box-sizing: border-box;
}

#searchBar {
    width: 92%;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #444;
    background-color: #222;
    color: white;
    font-size: 1em;
    margin: 0 auto;
}

#locationsHeading {
    position: sticky; /* Change from fixed to sticky */
    top: 60px;
    width: 100%; /* Change from 30% to 100% */
    margin: 0;
    padding: 10px 20px;
    color: #ff6600;
    background-color: #000;
    z-index: 1000;
    text-align: left;
}

#categoryContainer {
    margin-top: 0; /* Change from 120px to 0 */
    padding: 10px 20px;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    box-sizing: border-box;
    height: calc(100% - 100px); /* Adjust this value based on the height of search + heading */
}

#categoryContainer::-webkit-scrollbar {
    display: none;
}

.location-category {
    padding: 10px 20px;
    margin: 8px 0;
    background-color: #222;
    border-radius: 5px;
    cursor: pointer;
    text-align: left;
    color: white;
    font-weight: bold;
    transition: background-color 0.3s ease;
    height:1.4em;
    font-size: 18px;
}

.location-category:hover {
    background-color: #ff6600;
}

/* Sub Div Container */
#subDivContainer {
    position: relative;
    height: 100%;
    background-color: #000;
    overflow: hidden;
    display: none;
    width: 100%; 
}

#backButton {
    position: fixed;
    top: 10px;
    right: 10px;
    background-color: #ff6600;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    color: white;
    z-index: 1001;
    font-weight: bold;
}

#backButton:hover {
    background-color: #999;
}

#subDivHeading {
    position: sticky;
    top: 60px;
   
    width: 100%;
    margin: 0;
    padding: 10px;
    color: white;
    background-color: #000;
    text-align: center;
    z-index: 1000;
    font-size: 1.5em;
    font-weight: bold;
}

#subSearchContainer {
    position: sticky;
    top: 120px;
    width: 100%;
    padding: 10px 20px;
    background-color: #000;
    z-index: 1000;
    display: flex;
    justify-content: center;
    box-sizing: border-box;
}

#subSearchBar {
    width: 92%;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #444;
    background-color: #222;
    color: white;
    font-size: 1em;
    margin: 0 auto;
}

#subLocationsHeading {
    position: sticky;
    top: 180px;
   
    width: 100%;
    margin: 0;
    padding: 10px 20px;
    color: #ff6600;
    background-color: #000;
    z-index: 1000;
    text-align: left;
}

#subDivContent {
    margin-top: 60px;
    padding: 10px 20px;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    height: calc(100% - 240px);
}

#subDivContent::-webkit-scrollbar {
    display: none;
}
#sub3DivContainer {
    display: none;
    background-color: #000;
    color: white;
    height: 100%;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    position: relative;
    box-sizing: border-box;
}

#sub3DivContainer::-webkit-scrollbar {
    display: none;
}

/* Fixed Header Elements */
#backButtonSub3 {
    position: fixed;
    top: 10px;
    right: 20px;
    background-color: #ff6600;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    color: white;
    z-index: 1002;
    font-weight: bold;
}

#backButtonSub3:hover {
    background-color: #999;
}
#sub3DivHeading {
    position: fixed;
    top: 50px;
    width: 30%;
    right: 0;
    padding: 10px;
    margin: 0;
    color: white;
    background-color: transparent;
    text-align: center;
    z-index: 1002;
    font-size: 1.5em;
    font-weight: bold;
    box-sizing: border-box;
    transform: translateX(0); /* Remove any transform if it was there */
}

/* Also adjust the header-background */
.header-background {
    position: fixed;
    top: 0;
    right: 0;  /* Add this */
    width: 30%;  /* Add this */
    height: 110px;
    background-color: #000;
    z-index: 1001;
}


/* Content Container */
.sub3-content {
    margin-top: 110px; /* Match the header-background height */
    padding: 20px;
    position: relative;
    z-index: 1000;
}

#sub3Image {
    width: 220px;
    height: auto;
    margin: 30px auto;
    display: block;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(255, 255, 255, 0.1);
}

#directionsBtn {
    margin: 20px auto;
    padding: 12px 25px;
    background-color: #ff6600;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    display: block;
    transition: background-color 0.3s ease;
}

#directionsBtn:hover {
    background-color: #999;
    transform: translateY(-2px);
}

#overviewHeading {
    color: white;
    font-size: 1.5em;
    font-weight: bold;
    margin: 30px 0 20px;
    position: relative;
    display: inline-block;
}

#overviewHeading::after {
    content: '';
    display: block;
    width: 100%;
    height: 3px;
    background-color: #ff6600;
    margin-top: 5px;
}

/* Enhanced Table Styles */
#detailsTable {
    width: 100%;
    margin-top: 20px;
    border-collapse: separate;
    border-spacing: 0;
    border-radius: 8px;
    overflow: hidden;
}

#detailsTable td {
    padding: 15px;
    border: none;
    color: white;
    background-color: #222;
}

#detailsTable tr {
    transition: background-color 0.3s ease;
}

#detailsTable tr:hover {
    background-color: #333;
}

#detailsTable td:first-child {
    width: 30%;
    font-weight: bold;
    color: #ff6600;
    background-color: #1a1a1a;
    border-right: 2px solid #333;
}

#detailsTable tr:not(:last-child) td {
    border-bottom: 1px solid #333;
}




/* Common Back Button Styles */
#backButtonSub4, #backButtonSub5, #backButtonSub6,
#backButtonSub7, #backButtonSub8, #backButtonSub9 {

   
    position: fixed;
    top: 10px;
    right: 20px;
    background-color: #ff6600;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    color: white;
    z-index: 1002;
    font-weight: bold;
}




#backButtonSub4:hover, #backButtonSub5:hover, #backButtonSub6:hover,
#backButtonSub7:hover, #backButtonSub8:hover, #backButtonSub9:hover {
    background-color: #999;
}





#sub4DivContainer {
    display: none;
    background-color: #000;
    color: white;
    height: 100%;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    position: relative;
    box-sizing: border-box;
}

#sub4DivContainer::-webkit-scrollbar {
    display: none;
}

#sub4DestinationHeading {
    position: sticky;
    top: 60px; 
    width: 100%;
    margin: 0;
    padding: 10px;
    color: white;
    background-color: #000;
    text-align: left;
    z-index: 1000;
    font-size: 1.5em;
    font-weight: bold;
}

#sub4DestinationHeading2 {
    position: sticky;
    top: 140px; 
    width: 100%;
    margin: 0;
    padding: 10px;
    color: white;
    background-color: #000;
    text-align: center;
    z-index: 1000;
    font-size: 18px;
    font-weight: bold;
    /* Remove display: inline-block from here */
}




#sub5DivContainer {
    display: none;
    background-color: #000;
    color: white;
    height: 100%;
    width: 100%;
    overflow-x: hidden; /* Prevent horizontal scroll */
    box-sizing: border-box;
}







.button-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 25px;
    margin-top: 90px;
    padding: 20px;
}

/* Individual Button Styling */
.navigation-button {
    background-color: #1a1a1a;
    border: none;
    border-radius: 12px;
    padding: 20px;
    width: 80%;
    max-width: 300px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    display: flex;
    align-items: center;
    gap: 15px;
}

.navigation-button:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(255, 102, 0, 0.2);
}

.navigation-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent, rgba(255, 102, 0, 0.1), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s ease;
}

.navigation-button:hover::before {
    transform: translateX(100%);
}

/* Button Icon Container */
.button-icon {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #ff6600;
    border-radius: 50%;
    padding: 8px;
    transition: all 0.3s ease;
    animation: pulse 2s infinite;
}

/* Common Zoom Animation for Icons */
@keyframes pulse {
    0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0.4);
    }
    50% {
        transform: scale(1.1);
        box-shadow: 0 0 0 10px rgba(255, 102, 0, 0);
    }
    100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0);
    }
}

/* Enhance animation on hover */
.navigation-button:hover .button-icon {
    animation: pulseHover 1s infinite;
}

@keyframes pulseHover {
    0% {
        transform: scale(1.1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0.6);
    }
    50% {
        transform: scale(1.2);
        box-shadow: 0 0 0 15px rgba(255, 102, 0, 0);
    }
    100% {
        transform: scale(1.1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0);
    }
}

/* Button Text Styling */
.button-text {
    color: white;
    font-weight: bold;
    font-size: 1.1em;
    text-align: left;
    flex-grow: 1;
}

/* Animated Border Effect */
.navigation-button::after {
    content: '';
    position: absolute;
    inset: 0;
    border: 2px solid transparent;
    border-radius: 12px;
    background: linear-gradient(45deg, #ff6600, #ff8533) border-box;
    mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.navigation-button:hover::after {
    opacity: 1;
}

/* Responsive Design */
@media (max-width: 768px) {
    .navigation-button {
        width: 90%;
        padding: 15px;
    }

    .button-icon {
        width: 32px;
        height: 32px;
    }

    .button-text {
        font-size: 1em;
    }
}
/* Add a wrapper span in your HTML around the text */
.heading-wrapper {
    display: inline-block;
    position: relative;
}

/* Move the underline styles to the wrapper's after element */
.heading-wrapper::after {
    content: '';
    display: block;
    width: 100%;
    height: 3px;
    background-color: #ff6600;
    margin-top: 5px;
    position: absolute;
    bottom: -8px;
    left: 0;
}







#sub5Heading {
    position: sticky;
    top: 60px;
   
    width: 100%;
    margin: 0;
    padding: 10px;
    color: white;
    background-color: #000;
    text-align: center;
    z-index: 1000;
    font-size: 1.5em;
    font-weight: bold;
}



#sub5SearchBar {
    width: 100%;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #444;
    background-color: #222;
    color: white;
    font-size: 1em;
    margin: 0 auto;
}

#sub5Content {
    margin-top: 60px;
    padding: 10px 20px;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    height: calc(100% - 190px);
}

#sub5Content::-webkit-scrollbar {
    display: none;
}

#sub5DivContainer::-webkit-scrollbar {
    display: none;
}



#sub6Heading {
    position: sticky;
    top: 60px;
   
    width: 100%;
    margin: 0;
    padding: 10px;
    color: white;
    background-color: #000;
    text-align: center;
    z-index: 1000;
    font-size: 1.5em;
    font-weight: bold;
}



#sub6SearchBar {
    width: 100%;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #444;
    background-color: #222;
    color: white;
    font-size: 1em;
    margin: 0 auto;
}

#sub6Content {
    margin-top: 60px;
    padding: 10px 20px;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    height: calc(100% - 190px);
}

#sub6Content::-webkit-scrollbar {
    display: none;
}



#sub6DivContainer {
    display: none;
    background-color: #000;
    color: white;
    height: 100%;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    position: relative;
    box-sizing: border-box;
}

#sub6DivContainer::-webkit-scrollbar {
    display: none;
}








#sub7DivContainer {
    display: none;
    background-color: #000;
    color: white;
    height: 100%;
    width: 100%;
    position: relative;
    overflow: hidden;
}

.header-background1 {
    position: fixed;
    top: 0;
    right: 0;
    width: 30%;
    height: 200px; /* Adjusted height to accommodate all fixed elements */
    background-color: #000;
    z-index: 1001;
}



#sourceHeading, #destinationHeading {
    position: fixed;
    width: 25%;
    right: 0;
    margin: 0;
    padding: 10px 20px;
    color: white;
    background-color: transparent;
    text-align: left;
    font-weight: bold;
    z-index: 1002;
    font-size: 20px;
}

#sourceHeading {
    top: 60px;
}

#destinationHeading {
    top: 110px;
}




.scrollable-content {
    height: calc(100% - 160px);
    margin-top: 160px;
    overflow-y: auto;
    padding: 20px;
    padding-bottom: 80px; /* Increased bottom padding */
    display: flex;
    flex-direction: column;
    background-color: #000;
}


.scrollable-content::-webkit-scrollbar {
    display: none;
}

/* Mode Selection Section */
#sub9DestinationHeading1 {
    margin: 20px 0 15px 0;
    padding: 10px;
    color: white;
    text-align: center;
}



/* Action Buttons Section */
#sub9DestinationHeading2 {
    margin: 0 0 15px 0;
    padding: 10px;
    color: white;
    text-align: center;
}
#modeButtons {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 25px 0;
    padding: 0 20px;
}

/* Action Buttons Container */
#actionButtons {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 25px 0;
    padding: 0 20px;
}

/* Common Button Styles */
.mode-btn, #getDirectionsBtn, #startJourneyBtn {
    background-color: #1a1a1a;
    border: none;
    border-radius: 12px;
    padding: 16px 20px;
    width: 85%;
    max-width: 300px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    display: flex;
    align-items: center;
    gap: 15px;
}

/* Button Hover Effects */
.mode-btn:hover, #getDirectionsBtn:hover, #startJourneyBtn:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(255, 102, 0, 0.2);
}

/* Button Gradient Sweep Effect */
.mode-btn::before, #getDirectionsBtn::before, #startJourneyBtn::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent, rgba(255, 102, 0, 0.1), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s ease;
}

.mode-btn:hover::before, #getDirectionsBtn:hover::before, #startJourneyBtn:hover::before {
    transform: translateX(100%);
}

/* Button Icon Container */
.button-icon {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #ff6600;
    border-radius: 50%;
    padding: 8px;
    transition: all 0.3s ease;
    animation: pulse 2s infinite;
}

/* Pulsing Animation */
@keyframes pulse {
    0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0.4);
    }
    50% {
        transform: scale(1.1);
        box-shadow: 0 0 0 10px rgba(255, 102, 0, 0);
    }
    100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0);
    }
}

/* Enhanced Hover Animation */
.mode-btn:hover .button-icon, 
#getDirectionsBtn:hover .button-icon, 
#startJourneyBtn:hover .button-icon {
    animation: pulseHover 1s infinite;
}

@keyframes pulseHover {
    0% {
        transform: scale(1.1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0.6);
    }
    50% {
        transform: scale(1.2);
        box-shadow: 0 0 0 15px rgba(255, 102, 0, 0);
    }
    100% {
        transform: scale(1.1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0);
    }
}

/* Button Text */
.button-text {
    color: white;
    font-weight: bold;
    font-size: 1.1em;
    text-align: left;
    flex-grow: 1;
}

/* Active State for Mode Buttons */
.mode-btn.active {
    background-color: #ff6600;
    transform: scale(1.02);
}

.mode-btn.active .button-icon {
    background-color: #ffffff;
}

.mode-btn.active .button-icon svg {
    stroke: #ff6600;
}

/* Animated Border Effect */
.mode-btn::after, #getDirectionsBtn::after, #startJourneyBtn::after {
    content: '';
    position: absolute;
    inset: 0;
    border: 2px solid transparent;
    border-radius: 12px;
    background: linear-gradient(45deg, #ff6600, #ff8533) border-box;
    mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.mode-btn:hover::after, #getDirectionsBtn:hover::after, #startJourneyBtn:hover::after {
    opacity: 1;
}

/* Responsive Design */
@media (max-width: 768px) {
    .mode-btn, #getDirectionsBtn, #startJourneyBtn {
        width: 90%;
        padding: 14px;
    }

    .button-icon {
        width: 32px;
        height: 32px;
    }

    .button-text {
        font-size: 1em;
    }
}


#currentDirection {
    width: 100%;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #444;
    background-color: #222;
    color: white;
    font-size: 1em;
    
}





#directionsDisplay {
    display: none;
    background-color: #222;
    border-radius: 8px;
    margin-top: 20px;
    margin-bottom: 40px; /* Added bottom margin */
    width: 100%;
    box-sizing: border-box;
}

#directionsList {
    padding: 10px 20px 30px; /* Increased bottom padding */
}

#directionsList div:last-child {
    margin-bottom: 20px; /* Added margin to last item */
}

#directionsDisplay h2 {
    padding: 15px 20px;
    margin: 0;
    color: #ff6600;
    border-bottom: 2px solid #444;
    background-color: #222;
}



#directionsList div {
    padding: 12px 0;
    border-bottom: 1px solid #444;
    color: white;
}

 













#sub8DivContainer {
    display: none;
    background-color: #000;
    color: white;
    height: 100%;
    width: 100%;
    overflow-y: auto;
    scrollbar-width: none; /* For Firefox */
    -ms-overflow-style: none; /* For Internet Explorer and Edge */
}

#sub8DivContainer::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}
.header-background1 {
    position: fixed;
    top: 0;
    right: 0;
    width: 30%;
    height: 200px; /* Adjusted height to accommodate all fixed elements */
    background-color: #000;
    z-index: 1001;
}



#sub8SourceHeading, #sub8DestinationHeading {
    position: fixed;
    width: 25%;
    right: 0;
    margin: 0;
    padding: 10px 20px;
    color: white;
    background-color: transparent;
    text-align: left;
    font-weight: bold;
    z-index: 1002;
    font-size: 20px;
}

#sub8SourceHeading {
    top: 60px;
}

#sub8DestinationHeading {
    top: 110px;
}




.scrollable-content {
    height: calc(100% - 160px);
    margin-top: 160px;
    overflow-y: auto;
    padding: 20px;
    padding-bottom: 80px; /* Increased bottom padding */
    display: flex;
    flex-direction: column;
    background-color: #000;
}


.scrollable-content::-webkit-scrollbar {
    display: none;
}

/* Mode Selection Section */
#sub9DestinationHeading1 {
    margin: 20px 0 15px 0;
    padding: 10px;
    color: white;
    text-align: center;
}



/* Action Buttons Section */
#sub9DestinationHeading2 {
    margin: 0 0 15px 0;
    padding: 10px;
    color: white;
    text-align: center;
}





#modeButtonsSub8 {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 25px 0;
    padding: 0 20px;
}

/* Action Buttons Container */
#actionButtonsSub8 {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 25px 0;
    padding: 0 20px;
}

/* Common Button Styles */
#modeButtonsSub8 .mode-btn, 
#getDirectionsBtnSub8, 
#startJourneyBtnSub8 {
    background-color: #1a1a1a;
    border: none;
    border-radius: 12px;
    padding: 16px 20px;
    width: 85%;
    max-width: 300px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    display: flex;
    align-items: center;
    gap: 15px;
}

/* Button Hover Effects */
#modeButtonsSub8 .mode-btn:hover, 
#getDirectionsBtnSub8:hover, 
#startJourneyBtnSub8:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(255, 102, 0, 0.2);
}

/* Button Gradient Sweep Effect */
#modeButtonsSub8 .mode-btn::before, 
#getDirectionsBtnSub8::before, 
#startJourneyBtnSub8::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent, rgba(255, 102, 0, 0.1), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s ease;
}

#modeButtonsSub8 .mode-btn:hover::before, 
#getDirectionsBtnSub8:hover::before, 
#startJourneyBtnSub8:hover::before {
    transform: translateX(100%);
}

/* Button Icon Container */
.button-icon {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #ff6600;
    border-radius: 50%;
    padding: 8px;
    transition: all 0.3s ease;
    animation: pulse 2s infinite;
}

/* Pulsing Animation */
@keyframes pulse {
    0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0.4);
    }
    50% {
        transform: scale(1.1);
        box-shadow: 0 0 0 10px rgba(255, 102, 0, 0);
    }
    100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0);
    }
}

/* Enhanced Hover Animation */
#modeButtonsSub8 .mode-btn:hover .button-icon, 
#getDirectionsBtnSub8:hover .button-icon, 
#startJourneyBtnSub8:hover .button-icon {
    animation: pulseHover 1s infinite;
}

@keyframes pulseHover {
    0% {
        transform: scale(1.1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0.6);
    }
    50% {
        transform: scale(1.2);
        box-shadow: 0 0 0 15px rgba(255, 102, 0, 0);
    }
    100% {
        transform: scale(1.1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0);
    }
}

/* Button Text */
.button-text {
    color: white;
    font-weight: bold;
    font-size: 1.1em;
    text-align: left;
    flex-grow: 1;
}

/* Active State for Mode Buttons */
#modeButtonsSub8 .mode-btn.active {
    background-color: #ff6600;
    transform: scale(1.02);
}

#modeButtonsSub8 .mode-btn.active .button-icon {
    background-color: #ffffff;
}

#modeButtonsSub8 .mode-btn.active .button-icon svg {
    stroke: #ff6600;
}

/* Animated Border Effect */
#modeButtonsSub8 .mode-btn::after, 
#getDirectionsBtnSub8::after, 
#startJourneyBtnSub8::after {
    content: '';
    position: absolute;
    inset: 0;
    border: 2px solid transparent;
    border-radius: 12px;
    background: linear-gradient(45deg, #ff6600, #ff8533) border-box;
    mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    opacity: 0;
    transition: opacity 0.3s ease;
}

#modeButtonsSub8 .mode-btn:hover::after, 
#getDirectionsBtnSub8:hover::after, 
#startJourneyBtnSub8:hover::after {
    opacity: 1;
}

/* Responsive Design */
@media (max-width: 768px) {
    #modeButtonsSub8 .mode-btn, 
    #getDirectionsBtnSub8, 
    #startJourneyBtnSub8 {
        width: 90%;
        padding: 14px;
    }

    .button-icon {
        width: 32px;
        height: 32px;
    }

    .button-text {
        font-size: 1em;
    }
}



#currentDirection {
    width: 100%;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #444;
    background-color: #222;
    color: white;
    font-size: 1em;
    
}





#directionsDisplay1 {
    display: none;
    background-color: #222;
    border-radius: 8px;
    margin-top: 20px;
    margin-bottom: 40px; /* Added bottom margin */
    width: 100%;
    box-sizing: border-box;
}

#directionsList1 {
    padding: 10px 20px 30px; /* Increased bottom padding */
}

#directionsList1 div:last-child {
    border-bottom: none;
    padding-bottom: 20px;
}

#directionsDisplay1 h2 {
    padding: 15px 20px;
    margin: 0;
    color: #ff6600;
    border-bottom: 2px solid #444;
    background-color: #222;
}



#directionsList1 div {
    padding: 12px 0;
    border-bottom: 1px solid #444;
    color: white;
}






#sub9DivContainer {
    display: none;
    background-color: #000;
    color: white;
    height: 100%;
    width: 100%;
    overflow-y: auto;
    scrollbar-width: none; /* For Firefox */
    -ms-overflow-style: none; /* For Internet Explorer and Edge */
}

#sub9DivContainer::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}



#sub9SourceHeading, #sub9DestinationHeading {
    position: fixed;
    width: 25%;
    right: 0;
    margin: 0;
    padding: 10px 20px;
    color: white;
    background-color: transparent;
    text-align: left;
    font-weight: bold;
    z-index: 1002;
    font-size: 20px;
}

#sub9SourceHeading {
    top: 60px;
}

#sub9DestinationHeading {
    top: 110px;
}




.scrollable-content {
    height: calc(100% - 160px);
    margin-top: 160px;
    overflow-y: auto;
    padding: 20px;
    padding-bottom: 80px; /* Increased bottom padding */
    display: flex;
    flex-direction: column;
    background-color: #000;
}


.scrollable-content::-webkit-scrollbar {
    display: none;
}

/* Mode Selection Section */
#sub9DestinationHeading1 {
    margin: 20px 0 15px 0;
    padding: 10px;
    color: white;
    text-align: center;
}




/* Action Buttons Section */
#sub9DestinationHeading2 {
    margin: 0 0 15px 0;
    padding: 10px;
    color: white;
    text-align: center;
}

#modeButtonsSub9 {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 25px 0;
    padding: 0 20px;
}

/* Action Buttons Container */
#actionButtonsSub9 {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 25px 0;
    padding: 0 20px;
}

/* Common Button Styles */
#modeButtonsSub9 .mode-btn, 
#getDirectionsBtnSub9, 
#startJourneyBtnSub9 {
    background-color: #1a1a1a;
    border: none;
    border-radius: 12px;
    padding: 16px 20px;
    width: 85%;
    max-width: 300px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    display: flex;
    align-items: center;
    gap: 15px;
}

/* Button Hover Effects */
#modeButtonsSub9 .mode-btn:hover, 
#getDirectionsBtnSub9:hover, 
#startJourneyBtnSub9:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(255, 102, 0, 0.2);
}

/* Button Gradient Sweep Effect */
#modeButtonsSub9 .mode-btn::before, 
#getDirectionsBtnSub9::before, 
#startJourneyBtnSub9::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent, rgba(255, 102, 0, 0.1), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s ease;
}

#modeButtonsSub9 .mode-btn:hover::before, 
#getDirectionsBtnSub9:hover::before, 
#startJourneyBtnSub9:hover::before {
    transform: translateX(100%);
}

/* Button Icon Container */
.button-icon {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #ff6600;
    border-radius: 50%;
    padding: 8px;
    transition: all 0.3s ease;
    animation: pulse 2s infinite;
}

/* Pulsing Animation */
@keyframes pulse {
    0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0.4);
    }
    50% {
        transform: scale(1.1);
        box-shadow: 0 0 0 10px rgba(255, 102, 0, 0);
    }
    100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0);
    }
}

/* Enhanced Hover Animation */
#modeButtonsSub9 .mode-btn:hover .button-icon, 
#getDirectionsBtnSub9:hover .button-icon, 
#startJourneyBtnSub9:hover .button-icon {
    animation: pulseHover 1s infinite;
}

@keyframes pulseHover {
    0% {
        transform: scale(1.1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0.6);
    }
    50% {
        transform: scale(1.2);
        box-shadow: 0 0 0 15px rgba(255, 102, 0, 0);
    }
    100% {
        transform: scale(1.1);
        box-shadow: 0 0 0 0 rgba(255, 102, 0, 0);
    }
}

/* Button Text */
.button-text {
    color: white;
    font-weight: bold;
    font-size: 1.1em;
    text-align: left;
    flex-grow: 1;
}

/* Active State for Mode Buttons */
#modeButtonsSub9 .mode-btn.active {
    background-color: #ff6600;
    transform: scale(1.02);
}

#modeButtonsSub9 .mode-btn.active .button-icon {
    background-color: #ffffff;
}

#modeButtonsSub9 .mode-btn.active .button-icon svg {
    stroke: #ff6600;
}

/* Animated Border Effect */
#modeButtonsSub9 .mode-btn::after, 
#getDirectionsBtnSub9::after, 
#startJourneyBtnSub9::after {
    content: '';
    position: absolute;
    inset: 0;
    border: 2px solid transparent;
    border-radius: 12px;
    background: linear-gradient(45deg, #ff6600, #ff8533) border-box;
    mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    opacity: 0;
    transition: opacity 0.3s ease;
}

#modeButtonsSub9 .mode-btn:hover::after, 
#getDirectionsBtnSub9:hover::after, 
#startJourneyBtnSub9:hover::after {
    opacity: 1;
}

/* Responsive Design */
@media (max-width: 768px) {
    #modeButtonsSub9 .mode-btn, 
    #getDirectionsBtnSub9, 
    #startJourneyBtnSub9 {
        width: 90%;
        padding: 14px;
    }

    .button-icon {
        width: 32px;
        height: 32px;
    }

    .button-text {
        font-size: 1em;
    }

}
#currentDirection {
    width: 100%;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #444;
    background-color: #222;
    color: white;
    font-size: 1em;
    
}





#directionsDisplay2 {
    display: none;
    background-color: #222;
    border-radius: 8px;
    margin-top: 20px;
    margin-bottom: 40px; /* Added bottom margin */
    width: 100%;
    box-sizing: border-box;
}

#directionsList2 {
    padding: 10px 20px 30px; /* Increased bottom padding */
}

#directionsList2 div:last-child {
    margin-bottom: 20px; /* Added margin to last item */
}

#directionsDisplay2 h2 {
    padding: 15px 20px;
    margin: 0;
    color: #ff6600;
    border-bottom: 2px solid #444;
    background-color: #222;
}



#directionsList2 div {
    padding: 12px 0;
    border-bottom: 1px solid #444;
    color: white;
}


#subnav7Container,
#subnav8Container,
#subnav9Container {
    display: none;
    background-color: #000;
    color: white;
    height: 100%;
    width: 100%;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    position: relative;
    box-sizing: border-box;
}

#subnav7Container::-webkit-scrollbar,
#subnav8Container::-webkit-scrollbar,
#subnav9Container::-webkit-scrollbar {
    display: none;
}

#exitNavButtonSub7,
#exitNavButtonSub8,
#exitNavButtonSub9 {
    position: fixed;
    top: 10px;
    right: 20px;
    background-color: #ff6600;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    color: white;
    z-index: 1002;
    font-weight: bold;
}

#exitNavButtonSub7:hover,
#exitNavButtonSub8:hover,
#exitNavButtonSub9:hover {
    background-color: #999;
}

#sourceHeadingNav7,
#destinationHeadingNav7,
#sourceHeadingNav8,
#destinationHeadingNav8,
#sourceHeadingNav9,
#destinationHeadingNav9 {
    position: fixed;
    width: 25%;
    right: 0;
    margin: 0;
    padding: 10px 20px;
    color: white;
    background-color: transparent;
    text-align: left;
    font-weight: bold;
    z-index: 1002;
    font-size: 20px;
}

#sourceHeadingNav7,
#sourceHeadingNav8,
#sourceHeadingNav9 {
    top: 60px;
}

#destinationHeadingNav7,
#destinationHeadingNav8,
#destinationHeadingNav9 {
    top: 110px;
}

@media (max-width: 768px) {

:root {
--map-height: 60vh;
--controls-initial: 40vh;
--controls-expanded: 70vh;
--transition-duration: 0.3s;
}
.container {
flex-direction: column;
height: 100vh;
position: relative;
overflow: hidden;
}

#map {
width: 100%;
height: var(--map-height);
position: fixed;
top: 0;
left: 0;
}


#controls {
position: absolute;
bottom: 0;
left: 0;
width: 100%;
height: var(--controls-initial);
background: #000;
transition: height var(--transition-duration) ease;
z-index: 1000;
border-radius: 20px 20px 0 0;
}
/* Back button styling - positioned at the top-right corner within the container width */
#backButton, #backButtonSub3, #backButtonSub4,
#backButtonSub5, #backButtonSub6, #backButtonSub7,
#backButtonSub8, #backButtonSub9 {
position: absolute;
top: 10px;
right: 10px;
background-color: #ff6600;
border: none;
padding: 8px 15px;
border-radius: 5px;
cursor: pointer;
color: white;
z-index: 1002;
font-weight: bold;
}



#sub3DivContainer .header-background {
position: absolute;
top: 50px; /* Below the back button */
right: 0;
width: 100%;
height: 110px;
z-index: 1000;
}

/* Position the heading inside the header background */
#sub3DivHeading {
position: absolute;
top: 60px; /* Adjust to place it centrally within the header background */
width: 100%;
text-align: center;
color: white;
font-size: 1.5em;
font-weight: bold;
z-index: 1001; /* Keeps it above the header background */
}


#sub7DivContainer .header-background1 {
position: absolute;
top: 50px; /* Below the back button */
right: 0;
width: 100%;
height: 110px;
z-index: 1000;
}

/* Position the source and destination headings inside the header background */
#sourceHeading, #destinationHeading {
position: absolute;
width: 100%;
text-align: center;
color: white;
font-size: 1.2em;
font-weight: bold;
z-index: 1001; /* Keeps it above the header background */
}

/* Adjust top positions for each heading */
#sourceHeading {
top: 60px; /* Centered within the header background */
}

#destinationHeading {
top: 90px; /* Adjust to position below the source heading */
}
#sub8DivContainer .header-background1 {
position: absolute;
top: 50px; /* Below the back button */
right: 0;
width: 100%;
height: 110px;
z-index: 1000;
}

/* Position the source and destination headings inside the header background for sub8 */
#sub8SourceHeading, #sub8DestinationHeading {
position: absolute;
width: 100%;
text-align: center;
color: white;
font-size: 1.2em;
font-weight: bold;
z-index: 1001; /* Keeps it above the header background */
}

/* Adjust top positions for each heading in sub8 */
#sub8SourceHeading {
top: 60px; /* Centered within the header background */
}

#sub8DestinationHeading {
top: 90px; /* Position below the source heading */
}

#sub9SourceHeading, #sub9DestinationHeading {
position: absolute;
width: 100%;
text-align: center;
color: white;
font-size: 1.2em;
font-weight: bold;
z-index: 1001; /* Keeps it above the header background */
}

/* Adjust top positions for each heading in sub9 */
#sub9SourceHeading {
top: 60px; /* Centered within the header background */
}

#sub9DestinationHeading {
top: 90px; /* Position below the source heading */
}

#sub9DivContainer .header-background1 {
position: absolute;
top: 50px; /* Below the back button */
right: 0;
width: 100%;
height: 110px;
z-index: 1000;
}
.sub3-content {
margin-top: 20px; /* Match the header-background height */

}
}

    </style>
</head>
<body>
    <div class="container">
        <!-- Left side for the map -->
        <div id="map"></div>
        
        <!-- Right side for controls -->
        <div id="controls">
            
            
            <div id="controlspart1">
            <div id="controls1">
                <select id="featureSelect">
                    <option value="">Select a feature</option>
                </select>
                <button id="searchBtn">Search</button>
            </div><br>

            <div id="controls2">
                <label for="source">Source:</label>
                <select id="source">
                    <option value="">Select Source</option>
                </select>

                <label for="destination">Destination:</label>
                <select id="destination">
                    <option value="">Select Destination</option>
                </select>

                <label for="mode">Mode:</label>
                <select id="mode">
                    <option value="">Select Mode</option>
                    <option value="walking">Walking</option>
                    <option value="driving">Driving</option>
                    <option value="disabled">Disabled</option>
                </select>

                <button id="searchBtn1">Search</button>
                <button id="startjourney1">start journey</button>

                <div id="result"></div>
                <table id="pathTable" border="1" style="display:none;">
                    <thead>
                        <tr>
                            <th>From</th>
                            <th>To</th>
                            <th>Path</th>
                            <th>Distance</th>
                            <th>Directions</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>

            <div id="controls3">
                <label for="sourceType">Source Type:</label>
                <select id="sourceType">
                    <option value="clickOnMap">Click on Map</option>
                    <option value="liveLoc">Choose Live Location</option>
                </select>

                <label for="coordSource">Choose the Source by clicking on the map:</label>
                <input type="text" id="coordSource2" readonly />
                <input type="text" id="coordSource4" readonly />

                <input type="text" id="coordSource1" readonly />
                <input type="text" id="coordSource" readonly />

                <label for="coordDestination">Destination:</label>
                <select id="coordDestination">
                    <option value="">Select Destination</option>
                </select>

                <label for="coordMode">Mode:</label>
                <select id="coordMode">
                    <option value="">Select Mode</option>
                    <option value="walking">Walking</option>
                    <option value="driving">Driving</option>
                    <option value="disabled">Disabled</option>
                </select>

                <button id="coordSearchBtn">Search</button>
                <button id="liveSearchBtn">live Search</button>
                <button id="startjourney2">start journey</button>


                <div id="coordResult"></div>
                <table id="coordPathTable" border="1" style="display:none;">
                    <thead>
                        <tr>
                            <th>From</th>
                            <th>To</th>
                            <th>Path</th>
                            <th>Distance</th>
                            <th>Directions</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="controlspart2">
            
            <!-- Fixed Search Bar -->
            <div id="searchContainer">
                <input type="text" id="searchBar" placeholder="Search..." />
            </div>
    
            <!-- Locations Heading -->
            <h3 id="locationsHeading">Locations</h3>
    
            <div id="categoryContainer"></div>
            <div class="scroll-trigger"></div>
        </div>
    
        <!-- Sub Div Container -->
        <div id="subDivContainer" style="display: none;">
            <!-- Back Button -->
            <button id="backButton" onclick="goBack()">← Back</button>
            <h2 id="subDivHeading"></h2>
            <!-- Search Bar for Sub Divs -->
            <div id="subSearchContainer">
                <input type="text" id="subSearchBar" placeholder="Search..." />
            </div>
    
            <!-- Sub Locations Heading -->
            <h3 id="subLocationsHeading">Locations</h3>
            
            <!-- Dynamically Loaded Sub Div Content -->
            <div id="subDivContent"></div>
        </div>
        <div id="sub3DivContainer">
            <div class="header-background"></div>
            <button id="backButtonSub3" onclick="goBackToSubDiv()">← Back</button>
           
           
            <h2 id="sub3DivHeading"></h2>
            <div id="scrollTrigger" class="scroll-trigger"></div>
            <div class="sub3-content">
                <!-- Added this new div -->
                <img id="sub3Image" src="" alt="Location Image">
                <button id="directionsBtn">Directions</button>
                <h3 id="overviewHeading">Overview</h3>
                <table id="detailsTable">
                    <tbody>
                        <tr><td>Location</td><td id="locationDetail"></td></tr>
                        <tr><td>Phone Number</td><td id="phoneNumberDetail"></td></tr>
                        <tr><td>Email Address</td><td id="emailAddressDetail"></td></tr>
                        <tr><td>Other</td><td id="otherDetail"></td></tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div id="sub4DivContainer" style="display: none;">
            <button id="backButtonSub4" onclick="goBackToSub3()">← Back</button>
            <h2 id="sub4DestinationHeading"></h2>
            <h3 id="sub4DestinationHeading2">
                <span class="heading-wrapper">Choose a starting location:</span>
            </h3>
            
            <div class="button-container">
                <button id="searchAreaBtn" class="navigation-button">
                    <div class="button-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="11" cy="11" r="8"/>
                            <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                        </svg>
                    </div>
                    <span class="button-text">Search an area</span>
                </button>
            
                <button id="selectAreaBtn" class="navigation-button">
                    <div class="button-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                            <circle cx="12" cy="10" r="3"/>
                        </svg>
                    </div>
                    <span class="button-text">Select an area on the map</span>
                </button>
            
                <button id="useLiveLocationBtn" class="navigation-button">
                    <div class="button-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                    </div>
                    <span class="button-text">Use live location</span>
                </button>
            </div>
        </div>
        

<!-- Sub Div Container for Level 5 Search -->
<div id="sub5DivContainer" style="display: none;">
    <button id="backButtonSub5" onclick="goBackToSub4()">← Back</button>
    <h2 id="sub5Heading">Search a source</h2>

    <div id="subSearchContainer">
        <input type="text" id="sub5SearchBar" placeholder="Search..." />
    </div>


   
    <div id="sub5Content"></div>
</div>

<!-- Sub Div Container for Level 6 Details -->
<div id="sub6DivContainer" style="display: none;">
    <button id="backButtonSub6" onclick="goBackToSub5()">← Back</button>
    <h2 id="sub6Heading"></h2> <!-- Heading will be set dynamically based on selected div in div5 -->
    <div id="subSearchContainer">
        <input type="text" id="sub6SearchBar" placeholder="Search..." />
    </div>
    
    <div id="sub6Content"></div> <!-- Divs will be populated based on locations.json -->
</div>

<div id="sub7DivContainer" style="display: none;">
    <!-- Fixed header background -->
    <div class="header-background1"></div>
    
    <!-- Fixed elements -->
    <button id="backButtonSub7" onclick="goBackToSub6()">← Back</button>
    <h2 id="sourceHeading"></h2>
    <h2 id="destinationHeading"></h2>

    <!-- Scrollable content -->
    <div class="scrollable-content">
        <h3 id="sub9DestinationHeading1">
            <span class="heading-wrapper">Choose a mode:</span>
        </h3>

        <div id="modeButtons">
            <button id="walkingMode" class="mode-btn">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M13 4v16"></path>
                        <path d="M17 4v16"></path>
                        <path d="M21 4v16"></path>
                        <path d="M8 4v16"></path>
                        <path d="M4 4v16"></path>
                    </svg>
                </div>
                <span class="button-text">Walking</span>
            </button>
        
            <button id="vehicleMode" class="mode-btn">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M5 17h14M5 17a2 2 0 0 1-2-2V9l2.5-4h13L21 9v6a2 2 0 0 1-2 2M5 17v2m14-2v2M7 14h.01M17 14h.01"></path>
                    </svg>
                </div>
                <span class="button-text">Vehicle</span>
            </button>
        
            <button id="disabledMode" class="mode-btn">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="16" cy="4" r="1"/>
                        <path d="M8 21a2 2 0 1 0 4 0 2 2 0 1 0-4 0"/>
                        <path d="M19 21a2 2 0 1 0 4 0 2 2 0 1 0-4 0"/>
                        <path d="M17 13l-4-4-3 3"/>
                        <path d="M11 16.5V13"/>
                        <path d="M14 6h-4a2 2 0 0 0-2 2v5"/>
                    </svg>
                </div>
                <span class="button-text">Disabled</span>
            </button>
        </div>
        <h3 id="sub9DestinationHeading2">
            <span class="heading-wrapper">Get directions or start the journey</span>
        </h3>
        <div id="actionButtons">
            <button id="getDirectionsBtn">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 18l6-6-6-6"></path>
                    </svg>
                </div>
                <span class="button-text">Get Directions</span>
            </button>
        
            <button id="startJourneyBtn">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </div>
                <span class="button-text">Start Journey</span>
            </button>
        </div>

        

        <div id="directionsDisplay" style="display: none;">
            <h2>Directions</h2>
            <div id="directionsList"></div>
        </div>
    </div>
</div>


<!-- Sub Div Container for Select Area (Level 8) -->
<div id="sub8DivContainer" style="display: none;">
    <div class="header-background1"></div>
    <button id="backButtonSub8" onclick="goBackToSub4FromSub8()">← Back</button>
    <h2 id="sub8SourceHeading">Source: Dropped Pin</h2>
    <h2 id="sub8DestinationHeading"></h2>

    <!-- Mode Selection Heading and Buttons -->
    <div class="scrollable-content">
        <h3 id="sub9DestinationHeading1">
            <span class="heading-wrapper">Choose a mode:</span>
        </h3>


   
        <div id="modeButtonsSub8">
            <button id="walkingModeSub8" class="mode-btn">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M13 4v16"></path>
                        <path d="M17 4v16"></path>
                        <path d="M21 4v16"></path>
                        <path d="M8 4v16"></path>
                        <path d="M4 4v16"></path>
                    </svg>
                </div>
                <span class="button-text">Walking</span>
            </button>
        
            <button id="vehicleModeSub8" class="mode-btn">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M5 17h14M5 17a2 2 0 0 1-2-2V9l2.5-4h13L21 9v6a2 2 0 0 1-2 2M5 17v2m14-2v2M7 14h.01M17 14h.01"></path>
                    </svg>
                </div>
                <span class="button-text">Vehicle</span>
            </button>
        
            <button id="disabledModeSub8" class="mode-btn">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="16" cy="4" r="1"/>
                        <path d="M8 21a2 2 0 1 0 4 0 2 2 0 1 0-4 0"/>
                        <path d="M19 21a2 2 0 1 0 4 0 2 2 0 1 0-4 0"/>
                        <path d="M17 13l-4-4-3 3"/>
                        <path d="M11 16.5V13"/>
                        <path d="M14 6h-4a2 2 0 0 0-2 2v5"/>
                    </svg>
                </div>
                <span class="button-text">Disabled</span>
            </button>
        </div>
         <!-- Get Directions and Start Journey Section -->
    <h3 id="sub9DestinationHeading2">
        <span class="heading-wrapper">Get directions or start the journey</span>
    </h3>
        <div id="actionButtonsSub8">
            <button id="getDirectionsBtnSub8">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 18l6-6-6-6"></path>
                    </svg>
                </div>
                <span class="button-text">Get Directions</span>
            </button>
        
            <button id="startJourneyBtnSub8">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </div>
                <span class="button-text">Start Journey</span>
            </button>
        </div>




    <div id="directionsDisplay1" style="display: none; background-color: #222; border-radius: 8px; margin-top: 20px; margin-bottom: 40px; width: 100%; box-sizing: border-box;">
        <h2 style="padding: 15px 20px; margin: 0; color: #ff6600; border-bottom: 2px solid #444; background-color: #222;">Directions</h2>
        <div id="directionsList1" style="padding: 10px 20px 30px;"></div>
    </div>
    </div>
    
</div>


<!-- Sub Div Container for Use Live Location (Level 9) -->
<div id="sub9DivContainer" style="display: none;">
    <div class="header-background1"></div>
    <button id="backButtonSub9" onclick="goBackToSub4FromSub9()">← Back</button>
    <h2 id="sub9SourceHeading">Source: Live Location</h2>
    <h2 id="sub9DestinationHeading"></h2>

    <!-- Mode Selection Heading and Buttons -->
    <div class="scrollable-content">
        <h3 id="sub9DestinationHeading1">
            <span class="heading-wrapper">Choose a mode:</span>
        </h3>

        <div id="modeButtonsSub9">
            <button id="walkingModeSub9" class="mode-btn">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M13 4v16"></path>
                        <path d="M17 4v16"></path>
                        <path d="M21 4v16"></path>
                        <path d="M8 4v16"></path>
                        <path d="M4 4v16"></path>
                    </svg>
                </div>
                <span class="button-text">Walking</span>
            </button>
        
            <button id="vehicleModeSub9" class="mode-btn">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M5 17h14M5 17a2 2 0 0 1-2-2V9l2.5-4h13L21 9v6a2 2 0 0 1-2 2M5 17v2m14-2v2M7 14h.01M17 14h.01"></path>
                    </svg>
                </div>
                <span class="button-text">Vehicle</span>
            </button>
        
            <button id="disabledModeSub9" class="mode-btn">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="16" cy="4" r="1"/>
                        <path d="M8 21a2 2 0 1 0 4 0 2 2 0 1 0-4 0"/>
                        <path d="M19 21a2 2 0 1 0 4 0 2 2 0 1 0-4 0"/>
                        <path d="M17 13l-4-4-3 3"/>
                        <path d="M11 16.5V13"/>
                        <path d="M14 6h-4a2 2 0 0 0-2 2v5"/>
                    </svg>
                </div>
                <span class="button-text">Disabled</span>
            </button>
        </div>
        <!-- Get Directions and Start Journey Section -->
     <h3 id="sub9DestinationHeading2">
        <span class="heading-wrapper">Get directions or start the journey</span>
    </h3>
        <div id="actionButtonsSub9">
            <button id="getDirectionsBtnSub9">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 18l6-6-6-6"></path>
                    </svg>
                </div>
                <span class="button-text">Get Directions</span>
            </button>
        
            <button id="startJourneyBtnSub9">
                <div class="button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </div>
                <span class="button-text">Start Journey</span>
            </button>
        </div>
    <div id="directionsDisplay2" style="display: none; background-color: #222; border-radius: 8px; margin-top: 20px; margin-bottom: 40px; width: 100%; box-sizing: border-box;">
        <h2 style="padding: 15px 20px; margin: 0; color: #ff6600; border-bottom: 2px solid #444; background-color: #222;">Directions</h2>
        <div id="directionsList2" style="padding: 10px 20px 30px;"></div>
    </div>

    </div>
</div>
<!-- Navigation Container for Sub7 -->
<div id="subnav7Container" style="display: none;">
    <div class="header-background1"></div>
    <button id="exitNavButtonSub7" onclick="exitNavigationSub7()">Exit Navigation</button>
    <h2 id="sourceHeadingNav7"></h2>
    <h2 id="destinationHeadingNav7"></h2>

    <div class="scrollable-content">

        <div id="directionDisplayContainer">
            <input type="text" id="currentDirection7" readonly placeholder="Current direction will appear here">
        </div>
        <div id="directionFromTable7" class="direction-from-table" style="background-color: #222; padding: 10px; display: flex; align-items: center;">
            <img id="directionImage7" style="width: 24px; height: 24px; margin-right: 10px; object-fit: contain;">
            <span id="directionText7"></span>
        </div>

        <div id="nextDirectionContainer7" class="next-direction-container">
            <span class="next-direction-prefix">Then:</span>
            <span class="next-direction-text"></span>
        </div>
        <div id="directionsDisplay" style="display: none;">
            <h2>Directions</h2>
            <div id="directionsList"></div>
        </div>
    </div>

    
</div>

<!-- Navigation Container for Sub8 -->
<div id="subnav8Container" style="display: none;">
    <div class="header-background1"></div>
    <button id="exitNavButtonSub8" onclick="exitNavigationSub8()">Exit Navigation</button>
    <h2 id="sourceHeadingNav8"></h2>
    <h2 id="destinationHeadingNav8"></h2>

    <div class="scrollable-content">
 <div id="directionDisplayContainer" class="mb-4">
        <input type="text" id="currentDirection8" readonly class="w-full p-2 border rounded" placeholder="Current direction will appear here">
    </div>
    <div id="directionFromTable8" class="direction-from-table" style="background-color: #222; padding: 10px; display: flex; align-items: center;">
        <img id="directionImage8" style="width: 24px; height: 24px; margin-right: 10px; object-fit: contain;">
        <span id="directionText8"></span>
    </div>

    
    <div id="nextDirectionContainer8" class="next-direction-container">
        <span class="next-direction-prefix">Then:</span>
        <span class="next-direction-text"></span>
    </div>
        <div id="directionsDisplay1" style="display: none;">
            <h2>Directions</h2>
            <div id="directionsList1"></div>
        </div>
    </div>

    
</div>

<!-- Navigation Container for Sub9 -->
<div id="subnav9Container" style="display: none;">
    <div class="header-background1"></div>
    <button id="exitNavButtonSub9" onclick="exitNavigationSub9()">Exit Navigation</button>
    <h2 id="sourceHeadingNav9"></h2>
    <h2 id="destinationHeadingNav9"></h2>

    <div class="scrollable-content">
        <div id="directionDisplayContainer" class="mb-4">
            <input type="text" id="currentDirection9" readonly class="w-full p-2 border rounded" placeholder="Current direction will appear here">
        </div>

        <div id="directionFromTable9" class="direction-from-table" style="background-color: #222; padding: 10px; display: flex; align-items: center;">
            <img id="directionImage9" style="width: 24px; height: 24px; margin-right: 10px; object-fit: contain;">
            <span id="directionText9"></span>
        </div>

        
        <div id="nextDirectionContainer9" class="next-direction-container">
            <span class="next-direction-prefix">Then:</span>
            <span class="next-direction-text"></span>
        </div>
        <div id="directionsDisplay2" style="display: none;">
            <h2>Directions</h2>
            <div id="directionsList2"></div>
        </div>
    </div>

   
</div>


</div>



    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>

// Load base tile layer
// Initialize map with center and zoom
var map = L.map('map').setView([-1.2133067398143993, 36.879474707493756], 16);

// Add tile layer with proper bounds and config
// When initializing your map, store the base layer:
window.currentBaseLayer = L.tileLayer('https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
    maxZoom: 18,
    maxBounds: [
        [-1.2243618055135954, 36.864871289220616],
        [-1.2038858452725378, 36.89613868534187]
    ],
    maxBoundsViscosity: 1.0,
    minZoom: 15
}).addTo(map);


// Store layers for reference
var featureLayers = [];
var pathLayers = [];
var usiuBorderLayer;
// Load polygon coordinates first, then process GeoJSON data
fetch('polygon_coordinates.json')
    .then(response => response.json())
    .then(polygonCoords => {
        // After loading polygon coordinates, proceed to load GeoJSON
        return fetch('14.geojson')
            .then(response => response.json())
            .then(data => {
                var featureSelect = document.getElementById('featureSelect');
                L.geoJSON(data, {
    pointToLayer: function (feature, latlng) {
        var marker = L.marker(latlng, {
            opacity: 0,  // Make marker completely transparent
            interactive: false  // Disable mouse interactions
        });
        // Still store the marker for functionality but don't show popup
        featureLayers.push({
            name: feature.properties.name,
            layer: marker,
            featureType: feature.geometry.type
        });
        return marker;
    },
                    style: function (feature) {
                        var isUSIUBorder = feature.properties.name === 'USIU BORDER';
                        return {
                            color: isUSIUBorder ? '#000' : (feature.properties.borderColor || '#000'),
                            fillColor: isUSIUBorder ? '#27a147' : (feature.properties.fillColor || '#ccc'),
                            fillOpacity: isUSIUBorder ? 1 : 0.7,
                            weight: isUSIUBorder ? 5 : 2,
                            zIndex: isUSIUBorder ? 1000 : (feature.properties.zIndex || 1)
                        };
                    },
                    onEachFeature: function (feature, layer) {
                        var option = document.createElement('option');
                        option.value = feature.properties.name;
                        option.text = feature.properties.name;
                        featureSelect.appendChild(option);

                        // Function to swap coordinate order for display
                        function swapCoordinates(coordString) {
                            const [lng, lat] = coordString.split(',').map(coord => coord.trim());
                            return `${lat},${lng}`;
                        }

                        // Single click handler that handles both popup display and coordinate settings
                        layer.on('click', function (e) {
                            e.originalEvent.preventDefault(); // Prevent map click propagation
                            const featureName = feature.properties.name;
                            const latlng = e.latlng;

                            // Open popup immediately at the clicked position
                            L.popup()
                                .setLatLng(latlng)
                                .setContent(featureName)
                                .openOn(map);

                            // Handle 'USIU BORDER' clicks by clearing coordinates
                            if (featureName === 'USIU BORDER') {
                                document.getElementById('coordSource1').value = '';
                                document.getElementById('coordSource').value = '';
                                return;
                            }

                            // If predefined coordinates exist in polygonCoords, use them
                            if (polygonCoords[featureName]) {
                                document.getElementById('coordSource1').value = swapCoordinates(polygonCoords[featureName].source1);
                                document.getElementById('coordSource').value = swapCoordinates(polygonCoords[featureName].source);
                            } else {
                                // Handle LineString and Polygon features if no predefined coordinates
                                document.getElementById('coordSource1').value = `${latlng.lat}, ${latlng.lng}`;

                                if (feature.geometry.type === "LineString") {
                                    const lineCoords = layer.getLatLngs();
                                    const closestEndpoint = findNearestEndpoint(latlng, lineCoords);
                                    document.getElementById('coordSource').value = `${closestEndpoint.lat}, ${closestEndpoint.lng}`;
                                } else {
                                    const nearestEndpoint = findNearestPoint(latlng, featureLayers);
                                    if (nearestEndpoint && nearestEndpoint.latLng) {
                                        document.getElementById('coordSource').value = `${nearestEndpoint.latLng.lat}, ${nearestEndpoint.latLng.lng}`;
                                    } else {
                                        document.getElementById('coordSource').value = '';
                                    }
                                }
                            }
                        });

                        // Store LineString features separately for path-based logic
                        if (feature.geometry.type === "LineString") {
                            pathLayers.push({
                                name: feature.properties.name,
                                layer: layer
                            });
                        }
                    }
                }).addTo(map);

                // Apply a mask for USIU border if defined
                if (usiuBorderLayer) {
                    L.polygon(usiuBorderLayer.getLatLngs(), {
                        color: '#000',
                        fillColor: '#fff',
                        fillOpacity: 1,
                        zIndex: 1000
                    }).addTo(map);
                }

                // Map click handler for areas outside of defined features
                map.on('click', function(e) {
                    if (!e.originalEvent.defaultPrevented) { // Ensure not handled by a feature click
                        const latlng = e.latlng;
                        let isValidFeature = false;
                        let closestFeature = null;
                        let shortestDistance = Infinity;

                        featureLayers.forEach(function(featureLayer) {
                            if (featureLayer.name === 'USIU BORDER') return;

                            if (featureLayer.featureType === 'LineString') {
                                const lineCoords = featureLayer.layer.getLatLngs();
                                const nearestEndpoint = findNearestEndpoint(latlng, lineCoords);
                                const distanceToNearest = calculateDistance(latlng, nearestEndpoint);

                                if (distanceToNearest < 2 && distanceToNearest < shortestDistance) {
                                    isValidFeature = true;
                                    shortestDistance = distanceToNearest;
                                    closestFeature = featureLayer;
                                }
                            }
                        });

                        // Clear coordinates if clicked outside of valid features
                        if (!isValidFeature) {
                            document.getElementById('coordSource1').value = '';
                            document.getElementById('coordSource').value = '';
                        }
                    }
                });
            });
    })
    .catch(error => console.error('Error loading data:', error));


        // Define the points from POINT 13 to POINT 335 excluding specific points
        const availablePoints = [];
        for (let i = 13; i <= 335; i++) {
            if (![29, 31, 44, 107, 174, 194].includes(i)) {
                availablePoints.push(`POINT ${i}`);
            }
        }
// Add custom locations and map them to specific points
const customLocations = {
    "USIU GATE A": "POINT 86",
    "USIU GATE B": "POINT 100",
    "LIBRARY": "POINT 150",
    "SCHOOL OF HUMANITIES": "POINT 200",
    "ADMINISTRATION": "POINT 200",
    "SWIMMING POOL": "POINT 250"
};
        // Function to populate source and destination dropdowns with filtered points
        function populateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const destinationSelect = document.getElementById('destination');
            const coordDestinationSelect = document.getElementById('coordDestination');

            // Clear previous options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            destinationSelect.innerHTML = '<option value="">Select Destination</option>';
            coordDestinationSelect.innerHTML = '<option value="">Select Destination</option>';

            // Populate the dropdowns with the available points
            availablePoints.forEach(point => {
                const optionSource = document.createElement('option');
                optionSource.value = point;
                optionSource.textContent = point;
                sourceSelect.appendChild(optionSource);

                const optionDestination = document.createElement('option');
                optionDestination.value = point;
                optionDestination.textContent = point;
                destinationSelect.appendChild(optionDestination);

                const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point;
        optionCoordDestination.textContent = point;
        coordDestinationSelect.appendChild(optionCoordDestination);
            });
        
// Populate the dropdowns with custom locations
Object.keys(customLocations).forEach(location => {
        const point = customLocations[location];

        const optionSource = document.createElement('option');
        optionSource.value = point; // Map custom location to POINT value
        optionSource.textContent = location;
        sourceSelect.appendChild(optionSource);

        const optionDestination = document.createElement('option');
        optionDestination.value = point; // Map custom location to POINT value
        optionDestination.textContent = location;
        destinationSelect.appendChild(optionDestination);

        const optionCoordDestination = document.createElement('option');
        optionCoordDestination.value = point; // Map custom location to POINT value
        optionCoordDestination.textContent = location;
        coordDestinationSelect.appendChild(optionCoordDestination);
    });
}

        // Call the function to populate the dropdowns when the page loads
        document.addEventListener('DOMContentLoaded', populateDropdowns);

       // Fetch the directions file (1.json)
let directionsData = {};

fetch('1.json')
    .then(response => response.json())
    .then(data => {
        directionsData = data; // Store the directions data for later use
    })
    .catch(error => console.error('Error loading directions JSON:', error));

   // Add this to your frontend JavaScript where you handle the response from /shortest-path





let interpolatedMarkers = [];

// Add these two functions anywhere in your JavaScript code
function clearInterpolatedMarkers() {
    interpolatedMarkers.forEach(marker => {
        map.removeLayer(marker);
    });
    interpolatedMarkers = [];
}

// Add these global variables at the top of your script
let redCircleMarker = null;
let allPathPoints = [];  // Store all points for path restriction

// Function to clear the red circle
function clearRedCircle() {
    if (redCircleMarker) {
        map.removeLayer(redCircleMarker);
        redCircleMarker = null;
    }
}

// Function to find closest point on path
function findClosestPathPoint(latLng) {
    let closestPoint = null;
    let minDistance = Infinity;
    
    allPathPoints.forEach(point => {
        const distance = L.latLng(point[0], point[1]).distanceTo(latLng);
        if (distance < minDistance) {
            minDistance = distance;
            closestPoint = point;
        }
    });
    
    return closestPoint;
}


function displayAllPathPoints(result, foundLayer, pathNameFromMap, liveLatLng, pathNameFromTable) {
    clearInterpolatedMarkers();
    clearRedCircle();
    allPathPoints = [];
    endpointMarkers = [];

    let initialPathPoints = [];
    let startPoint = null;

    if (pathNameFromTable === pathNameFromMap) {
        const pathLayer = findPathContainingLiveCoordinate(liveLatLng);
        if (pathLayer) {
            const lineCoords = pathLayer.getLatLngs();
            const extractedCoords = extractCoordinates(lineCoords, 1000);
            const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
            startPoint = [closestInterpolatedPoint[1], closestInterpolatedPoint[0]];
        }
        initialPathPoints = highlightFarthestInterpolatedPath(liveLatLng);
    } else {
        const pathLayer = findPathContainingLiveCoordinate(liveLatLng);
        if (pathLayer) {
            const lineCoords = pathLayer.getLatLngs();
            const extractedCoords = extractCoordinates(lineCoords, 10);
            const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
            startPoint = [closestInterpolatedPoint[1], closestInterpolatedPoint[0]];
        }
        initialPathPoints = highlightInterpolatedPath(liveLatLng);
    }

    // Display markers for the initial path points
    initialPathPoints.forEach((point, index, arr) => {
        allPathPoints.push(point);
        const isEndpoint = (index === 0 || index === arr.length - 1);
        const marker = L.circleMarker(point, {
            radius: isEndpoint ? 5 : 3,
            fillColor: isEndpoint ? 'green' : '#000',
            color: isEndpoint ? 'green' : '#000',
            weight: 1,
            opacity: 1,
            fillOpacity: 1
        }).addTo(map);

        if (isEndpoint) {
            endpointMarkers.push({
                marker: marker,
                pathIndex: 0
            });
        }
        interpolatedMarkers.push(marker);
    });

    // Handle all other paths
    result.path.forEach((pathEntry, pathIndex) => {
        const matchingLayer = pathLayers.find(layerObj => layerObj.name === pathEntry.path);
        if (matchingLayer && matchingLayer.name !== pathNameFromMap) {
            const lineCoords = matchingLayer.layer.getLatLngs();
            const interpolatedPoints = extractCoordinates(lineCoords, 1000);

            interpolatedPoints.forEach((point, index, arr) => {
                const pointLatLng = [point[1], point[0]];
                allPathPoints.push(pointLatLng);
                const isEndpoint = (index === 0 || index === arr.length - 1);
                const marker = L.circleMarker(pointLatLng, {
                    radius: isEndpoint ? 5 : 3,
                    fillColor: isEndpoint ? 'green' : '#000',
                    color: isEndpoint ? 'green' : '#000',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 1
                }).addTo(map);

                if (isEndpoint) {
                    endpointMarkers.push({
                        marker: marker,
                        pathIndex: pathIndex,
                        isLastEndpoint: (pathIndex === result.path.length - 1 && index === arr.length - 1)
                    });
                }
                interpolatedMarkers.push(marker);
            });
        }
    });

    // Initialize with first direction
    if (result.path.length > 0) {
        const firstDirection = getDirectionFromTable1(0);
        document.getElementById('currentDirection8').value = firstDirection;
    }

    // Create draggable red circle at the closest interpolated point
    if (startPoint) {
        redCircleMarker = L.marker(startPoint, {
            icon: L.divIcon({
                className: 'custom-div-icon',
                html: '<div style="background-color: red; width: 15px; height: 15px; border-radius: 50%;"></div>',
                iconSize: [15, 15],
                iconAnchor: [7.5, 7.5]
            }),
            draggable: true
        }).addTo(map);

        // Add drag event handlers with direction updates
        redCircleMarker.on('drag', function(e) {
            const closestPoint = findClosestPathPoint(e.latlng);
            if (closestPoint) {
                redCircleMarker.setLatLng(closestPoint);
                
                // Check for overlap with any endpoint marker
                endpointMarkers.forEach((endpointObj, index) => {
                    const endpointLatLng = endpointObj.marker.getLatLng();
                    const distance = map.distance(closestPoint, endpointLatLng);
                    
                    if (distance < 5) {
                        const table = document.getElementById('coordPathTable');
                        const tbody = table.querySelector('tbody');
                        const lastRowIndex = tbody.rows.length - 1;
                        
                        if (endpointObj.isLastEndpoint) {
    // For the last endpoint, show the last direction from table
    console.log('At last endpoint, getting direction from row:', lastRowIndex);
    const lastDirection = getDirectionFromTable1(lastRowIndex);
    console.log('Last direction:', lastDirection);
    document.getElementById('currentDirection8').value = lastDirection;
} else if (index === endpointMarkers.length - 2) {
    // Show destination message with the distance
    const distance = getDistanceToEnd(); // Assuming you have this function, or use your distance calculation
    document.getElementById('currentDirection8').value = `Destination in ${distance.toFixed(2)} metres`;
} else {
    // For all other endpoints, show normal directions
    const tableRow = Math.floor(index / 2);
    const direction = getDirectionFromTable1(tableRow);
    if (direction) {
        document.getElementById('currentDirection8').value = direction;
        currentPathIndex = tableRow;
    }
}
                    }
                });
            }
        });
    }
}

// Helper function to get direction from table with debugging
function getDirectionFromTable1(rowIndex) {
    const table = document.getElementById('coordPathTable');
    const tbody = table.querySelector('tbody');
    
    console.log('Total rows in table:', tbody.rows.length);
    console.log('Trying to get direction from row:', rowIndex);
    
    if (rowIndex >= 0 && rowIndex < tbody.rows.length) {
        const row = tbody.rows[rowIndex];
        const cells = row.getElementsByTagName('td');
        const direction = cells[cells.length - 1].textContent;
        console.log('Found direction:', direction);
        return direction;
    }
    console.log('Row index out of bounds');
    return '';
}


function displayLivePathPoints(result, foundLayer, pathNameFromMap, liveLatLng, pathNameFromTable) {
    clearInterpolatedMarkers();
    clearRedCircle();
    allPathPoints = [];
    endpointMarkers = [];

    let initialPathPoints = [];
    let startPoint = null;

    if (pathNameFromTable === pathNameFromMap) {
        const pathLayer = findPathContainingLiveCoordinate(liveLatLng);
        if (pathLayer) {
            const lineCoords = pathLayer.getLatLngs();
            const extractedCoords = extractCoordinates(lineCoords, 1000);
            const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
            startPoint = [closestInterpolatedPoint[1], closestInterpolatedPoint[0]];
        }
        initialPathPoints = highlightFarthestInterpolatedPath(liveLatLng);
    } else {
        const pathLayer = findPathContainingLiveCoordinate(liveLatLng);
        if (pathLayer) {
            const lineCoords = pathLayer.getLatLngs();
            const extractedCoords = extractCoordinates(lineCoords, 10);
            const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
            startPoint = [closestInterpolatedPoint[1], closestInterpolatedPoint[0]];
        }
        initialPathPoints = highlightInterpolatedPath(liveLatLng);
    }

    // Display markers for the initial path points
    initialPathPoints.forEach((point, index, arr) => {
        allPathPoints.push(point);
        const isEndpoint = (index === 0 || index === arr.length - 1);
        const marker = L.circleMarker(point, {
            radius: isEndpoint ? 5 : 3,
            fillColor: isEndpoint ? 'green' : '#000',
            color: isEndpoint ? 'green' : '#000',
            weight: 1,
            opacity: 1,
            fillOpacity: 1
        }).addTo(map);

        if (isEndpoint) {
            endpointMarkers.push({
                marker: marker,
                pathIndex: 0
            });
        }
        interpolatedMarkers.push(marker);
    });

    // Handle all other paths
    result.path.forEach((pathEntry, pathIndex) => {
        const matchingLayer = pathLayers.find(layerObj => layerObj.name === pathEntry.path);
        if (matchingLayer && matchingLayer.name !== pathNameFromMap) {
            const lineCoords = matchingLayer.layer.getLatLngs();
            const interpolatedPoints = extractCoordinates(lineCoords, 1000);

            interpolatedPoints.forEach((point, index, arr) => {
                const pointLatLng = [point[1], point[0]];
                allPathPoints.push(pointLatLng);
                const isEndpoint = (index === 0 || index === arr.length - 1);
                const marker = L.circleMarker(pointLatLng, {
                    radius: isEndpoint ? 5 : 3,
                    fillColor: isEndpoint ? 'green' : '#000',
                    color: isEndpoint ? 'green' : '#000',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 1
                }).addTo(map);

                if (isEndpoint) {
                    endpointMarkers.push({
                        marker: marker,
                        pathIndex: pathIndex,
                        isLastEndpoint: (pathIndex === result.path.length - 1 && index === arr.length - 1)
                    });
                }
                interpolatedMarkers.push(marker);
            });
        }
    });

    // Initialize with first direction
    if (result.path.length > 0) {
        const firstDirection = getDirectionFromTable2(0);
        document.getElementById('currentDirection9').value = firstDirection;
    }

    // Create draggable red circle at the closest interpolated point
    if (startPoint) {
        redCircleMarker = L.marker(startPoint, {
            icon: L.divIcon({
                className: 'custom-div-icon',
                html: '<div style="background-color: red; width: 15px; height: 15px; border-radius: 50%;"></div>',
                iconSize: [15, 15],
                iconAnchor: [7.5, 7.5]
            }),
            draggable: true
        }).addTo(map);

        // Add drag event handlers with direction updates
        redCircleMarker.on('drag', function(e) {
            const closestPoint = findClosestPathPoint(e.latlng);
            if (closestPoint) {
                redCircleMarker.setLatLng(closestPoint);
                
                // Check for overlap with any endpoint marker
                endpointMarkers.forEach((endpointObj, index) => {
                    const endpointLatLng = endpointObj.marker.getLatLng();
                    const distance = map.distance(closestPoint, endpointLatLng);
                    
                    if (distance < 5) {
                        const table = document.getElementById('coordPathTable');
                        const tbody = table.querySelector('tbody');
                        const lastRowIndex = tbody.rows.length - 1;
                        
                        if (endpointObj.isLastEndpoint) {
                            // For the last endpoint, show the last direction from table
                            console.log('At last endpoint, getting direction from row:', lastRowIndex);
                            const lastDirection = getDirectionFromTable2(lastRowIndex);
                            console.log('Last direction:', lastDirection);
document.getElementById('currentDirection9').value = lastDirection;
} else if (index === endpointMarkers.length - 2) {
    // Show destination message with the distance
    const distance = getDistanceToEnd(); // Assuming you have this function, or use your distance calculation
    document.getElementById('currentDirection9').value = `Destination in ${distance.toFixed(2)} metres`;
} else {
    // For all other endpoints, show normal directions
    const tableRow = Math.floor(index / 2);
    const direction = getDirectionFromTable2(tableRow);
    if (direction) {
        document.getElementById('currentDirection9').value = direction;
        currentPathIndex = tableRow;
    }
}
                    }
                });
            }
        });
    }
}

// Helper function to get direction from table
function getDirectionFromTable2(rowIndex) {
    const table = document.getElementById('coordPathTable');
    const tbody = table.querySelector('tbody');
    
    console.log('Total rows in table:', tbody.rows.length);
    console.log('Trying to get direction from row:', rowIndex);
    
    if (rowIndex >= 0 && rowIndex < tbody.rows.length) {
        const row = tbody.rows[rowIndex];
        const cells = row.getElementsByTagName('td');
        const direction = cells[cells.length - 1].textContent;
        console.log('Found direction:', direction);
        return direction;
    }
    console.log('Row index out of bounds');
    return '';
}



// Keep track of endpoint markers specifically
let endpointMarkers = [];
let currentPathIndex = 0;
function addInterpolatedPoints(result) {
    clearInterpolatedMarkers();
    clearRedCircle();
    allPathPoints = [];
    endpointMarkers = [];
    
    // Get the first path's start point explicitly
    if (result.path.length > 0) {
        const firstPath = result.path[0];
        const firstLayer = pathLayers.find(layerObj => layerObj.name === firstPath.path);
        if (firstLayer) {
            const firstLineCoords = firstLayer.layer.getLatLngs();
            
            // Compare both ends of the path to find the correct start point
            const initialPoint = {
                lat: -1.209586319690957,
                lng: 36.88147858865221
            };
            
            // Calculate distances to both ends of the path
            const distanceToStart = L.latLng(firstLineCoords[0].lat, firstLineCoords[0].lng)
                .distanceTo(L.latLng(initialPoint.lat, initialPoint.lng));
            const distanceToEnd = L.latLng(firstLineCoords[firstLineCoords.length - 1].lat, 
                firstLineCoords[firstLineCoords.length - 1].lng)
                .distanceTo(L.latLng(initialPoint.lat, initialPoint.lng));
            
            // Select the end that's closer to the initial point
            const firstEndpoint = distanceToStart < distanceToEnd ? 
                [firstLineCoords[0].lat, firstLineCoords[0].lng] :
                [firstLineCoords[firstLineCoords.length - 1].lat, firstLineCoords[firstLineCoords.length - 1].lng];
            
            console.log('Initial point:', initialPoint);
            console.log('Distance to start:', distanceToStart);
            console.log('Distance to end:', distanceToEnd);
            console.log('Selected endpoint:', firstEndpoint);
            
            // Create red circle at the correct start point
            redCircleMarker = L.marker(firstEndpoint, {
                icon: L.divIcon({
                    className: 'custom-div-icon',
                    html: '<div style="background-color: red; width: 15px; height: 15px; border-radius: 50%;"></div>',
                    iconSize: [15, 15],
                    iconAnchor: [7.5, 7.5]
                }),
                draggable: true
            }).addTo(map);

            // Add drag event handlers
            redCircleMarker.on('drag', function(e) {
                const closestPoint = findClosestPathPoint(e.latlng);
                if (closestPoint) {
                    redCircleMarker.setLatLng(closestPoint);
                    
                    endpointMarkers.forEach((endpointObj, index) => {
                        const endpointLatLng = endpointObj.marker.getLatLng();
                        const distance = map.distance(closestPoint, endpointLatLng);
                        
                        if (distance < 5) {
    const tableRow = Math.floor(index / 2);
    const direction = getDirectionFromTable(tableRow);
    if (direction) {
        document.getElementById('currentDirection7').value = direction;
        currentPathIndex = tableRow;
    }
}
                    });
                }
            });
        }
    }
    
    // Process all paths for markers as before
    result.path.forEach((pathEntry, pathIndex) => {
        const matchingLayer = pathLayers.find(layerObj => layerObj.name === pathEntry.path);
        if (matchingLayer) {
            const lineCoords = matchingLayer.layer.getLatLngs();
            const interpolatedPoints = extractCoordinates(lineCoords, 1000);
            
            interpolatedPoints.forEach((point, index, arr) => {
                const pointLatLng = [point[1], point[0]];
                allPathPoints.push(pointLatLng);
                
                const isEndpoint = (index === 0 || index === arr.length - 1);
                
                const marker = L.circleMarker(pointLatLng, {
                    radius: isEndpoint ? 5 : 3,
                    fillColor: isEndpoint ? 'green' : '#000',
                    color: isEndpoint ? 'green' : '#000',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 1
                }).addTo(map);

                if (isEndpoint) {
                    endpointMarkers.push({
                        marker: marker,
                        pathIndex: pathIndex,
                        isLastEndpoint: (pathIndex === result.path.length - 1 && index === arr.length - 1)
                    });
                }
                
                interpolatedMarkers.push(marker);
            });
        }
    });

    // Initialize with first direction
    if (result.path.length > 0) {
        const firstDirection = getDirectionFromTable(0);
        document.getElementById('currentDirection7').value = firstDirection;
    }

    // Add drag event handlers to red circle if it exists
    if (redCircleMarker) {
        redCircleMarker.on('drag', function(e) {
            const closestPoint = findClosestPathPoint(e.latlng);
            if (closestPoint) {
                redCircleMarker.setLatLng(closestPoint);
                
                endpointMarkers.forEach((endpointObj, index) => {
                    const endpointLatLng = endpointObj.marker.getLatLng();
                    const distance = map.distance(closestPoint, endpointLatLng);
                    
                    if (distance < 5) {
                        // Get the table to check the last row index
                        const tableRow = Math.floor(index / 2);
const direction = getDirectionFromTable1(tableRow);
if (direction) {
    document.getElementById('currentDirection7').value = direction;
    currentPathIndex = tableRow;
}
                    }
                });
            }
        });
    }
}
// Helper function to get direction from table
function getDirectionFromTable(rowIndex) {
    const table = document.getElementById('pathTable');
    const tbody = table.querySelector('tbody');
    const rows = tbody.getElementsByTagName('tr');
    
    if (rowIndex < rows.length) {
        const cells = rows[rowIndex].getElementsByTagName('td');
        return cells[cells.length - 1].textContent;
    }
    return '';
}
// Function to get direction image based on direction text
function getDirectionImage(directionText) {
    directionText = directionText.toLowerCase();
    
    const imageMap = {
        'turn right': 'turnright.png',
        'turn left': 'turnleft.png',
        'turn slight left': 'turnslightleft.png',
        'turn slight right': 'turnslightright.png',
        'head straight': 'headstraight.png',
        'destination': 'destination.png'
    };

    for (let key in imageMap) {
        if (directionText.includes(key)) {
            return imageMap[key];
        }
    }
    return 'default.jpeg';
}

// Function to create direction item with image
function createDirectionItem(directionText) {
    const directionDiv = document.createElement('div');
    directionDiv.style.cssText = `
        display: flex;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #ddd;
        color: white;
    `;

    const img = document.createElement('img');
    img.src = getDirectionImage(directionText);
    img.style.cssText = `
        width: 24px;
        height: 24px;
        margin-right: 10px;
        object-fit: contain;
    `;

    const textSpan = document.createElement('span');
    textSpan.textContent = directionText;

    directionDiv.appendChild(img);
    directionDiv.appendChild(textSpan);

    return directionDiv;
}

// Modified searchBtn1 event listener
document.getElementById('searchBtn1').addEventListener('click', function() {
    const source = document.getElementById('source').value;
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;

    if (!source || !destination || !mode) {
        alert('Please select source, destination, and mode.');
        return;
    }

    fetch(`/shortest-path?source=${source}&destination=${destination}&mode=${mode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('result');
            const table = document.getElementById('pathTable');
            const tbody = table.querySelector('tbody');
            const directionsList = document.getElementById('directionsList');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
                directionsList.innerHTML = '';
                document.getElementById('directionsDisplay').style.display = 'none';
            } else {
                resultDiv.textContent = `Total Distance: ${result.distance.toFixed(2)} units`;

                tbody.innerHTML = '';
                directionsList.innerHTML = '';

                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

    // Create table row
    let row = document.createElement('tr');
    row.innerHTML = `
        <td>${from}</td>
        <td>${to}</td>
        <td>${path}</td>
        <td>${distance.toFixed(2)}</td>
    `;

    // Get direction
    let direction = '';
    if (index < result.path.length - 1) {
        const nextPathName = result.path[index + 1].path;
        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
            direction = `${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
        }
    } else {
        direction = `Destination in ${distance.toFixed(2)} metres`;
    }

    // Modify the first row to include "Head Straight and ..."
    if (index === 0) {
        direction = `Head Straight and ${direction}`;
    }

    // Add direction to table
    let directionCell = document.createElement('td');
    directionCell.textContent = direction;
    row.appendChild(directionCell);
    tbody.appendChild(row);

    // Add direction with image to directions list
    if (direction) {
        const directionItem = createDirectionItem(direction);
        directionsList.appendChild(directionItem);
    }
                });

                table.style.display = 'table';
                document.getElementById('directionsDisplay').style.display = 'block';
                
                // Highlight the paths on the map
                highlightPaths(result.path);
                addInterpolatedPoints(result); 
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

// Add this CSS to your existing styles
const styles = document.createElement('style');
styles.textContent = `
    .direction-from-table {
        display: flex;
        align-items: center;
    }

    .direction-from-table img {
        width: 24px;
        height: 24px;
        margin-right: 10px;
        object-fit: contain;
    }

    #directionsList div,
    #directionsList1 div,
    #directionsList2 div {
        display: flex;
        align-items: center;
    }
`;
document.head.appendChild(styles);
function highlightPaths(paths, skipFirstPath) {
    // Reset all path colors to default
    pathLayers.forEach(layerObj => {
        layerObj.layer.setStyle({
            color: layerObj.layer.feature.properties.borderColor || '#000',
            fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
        });

        // Remove previous polylines (if any)
        if (layerObj.polyline) {
            map.removeLayer(layerObj.polyline);
            delete layerObj.polyline;
        }
    });

    // Now we just set the styles without drawing polylines
    paths.forEach(({ path, from, to }, index) => {
        if (index === 0 && skipFirstPath) {
            console.log(`Skipping highlighting for path: ${path}`);
            return;
        }

        const matchingLayer = pathLayers.find(layerObj => layerObj.name === path);
        if (matchingLayer) {
            // Just reset the style, don't draw new polylines
            matchingLayer.layer.setStyle({ 
                color: matchingLayer.layer.feature.properties.borderColor || '#000'
            });
        }
    });
}




// Global variable to store the previously drawn polyline
let previousPolyline = null;

function highlightInterpolatedPath(liveLatLng, coordSource) {
    // Clear the previous polyline if it exists
    if (previousPolyline) {
        map.removeLayer(previousPolyline);
        previousPolyline = null;
    }

    const pathLayer = findPathContainingLiveCoordinate(liveLatLng);

    if (pathLayer) {
        const lineCoords = pathLayer.getLatLngs();
        const extractedCoords = extractCoordinates(lineCoords, 1000);
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
        const nearestEndpoint = findNearestEndpoint(liveLatLng, lineCoords);

        const closestIndex = extractedCoords.findIndex(coord =>
            coord[0] === closestInterpolatedPoint[0] && coord[1] === closestInterpolatedPoint[1]);
        const nearestIndex = extractedCoords.findIndex(coord =>
            coord[0] === nearestEndpoint.lng && coord[1] === nearestEndpoint.lat);

        if (closestIndex !== -1 && nearestIndex !== -1) {
            const startIndex = Math.min(closestIndex, nearestIndex);
            const endIndex = Math.max(closestIndex, nearestIndex);
            
            const coordsToConnect = [];
            for (let i = startIndex; i <= endIndex; i++) {
                coordsToConnect.push([extractedCoords[i][1], extractedCoords[i][0]]);
            }

            return coordsToConnect;
        }
    }

    return [];
}
// Global variable to store the previously drawn polyline for the farthest endpoint
let previousFarthestPolyline = null;

// New function to find the closest interpolated point, farthest endpoint, and draw the green polyline
function highlightFarthestInterpolatedPath(liveLatLng, coordSource) {
    // Clear the previous polyline if it exists
    if (previousFarthestPolyline) {
        map.removeLayer(previousFarthestPolyline);
        previousFarthestPolyline = null;
    }

    const pathLayer = findPathContainingLiveCoordinate(liveLatLng);

    if (pathLayer) {
        const lineCoords = pathLayer.getLatLngs();
        const extractedCoords = extractCoordinates(lineCoords, 1000);
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, extractedCoords);
        const farthestEndpoint = findFarthestEndpoint(liveLatLng, lineCoords);

        const closestIndex = extractedCoords.findIndex(coord =>
            coord[0] === closestInterpolatedPoint[0] && coord[1] === closestInterpolatedPoint[1]);
        const farthestIndex = extractedCoords.findIndex(coord =>
            coord[0] === farthestEndpoint.lng && coord[1] === farthestEndpoint.lat);

        if (closestIndex !== -1 && farthestIndex !== -1) {
            const startIndex = Math.min(closestIndex, farthestIndex);
            const endIndex = Math.max(closestIndex, farthestIndex);
            
            const coordsToConnect = [];
            for (let i = startIndex; i <= endIndex; i++) {
                coordsToConnect.push([extractedCoords[i][1], extractedCoords[i][0]]);
            }

            return coordsToConnect;
        }
    }

    return [];
}





// Function to calculate total distance between a list of coordinates
function calculateTotalDistance(coords) {
    let totalDistance = 0;
    for (let i = 0; i < coords.length - 1; i++) {
        const pointA = L.latLng(coords[i][0], coords[i][1]);
        const pointB = L.latLng(coords[i + 1][0], coords[i + 1][1]);
        totalDistance += pointA.distanceTo(pointB); // Calculate distance between two points
    }
    return totalDistance;
}


// Function to check if a point is an endpoint
function isEndpoint(point, lineString) {
    const coordinates = lineString.getLatLngs();
    const firstPoint = coordinates[0];
    const lastPoint = coordinates[coordinates.length - 1];
    
    return (point.lat === firstPoint.lat && point.lng === firstPoint.lng) ||
           (point.lat === lastPoint.lat && point.lng === lastPoint.lng);
}

// Function to process directions and combine if needed
function processDirections(tbody, liveLatLng, foundLayer, pathNameFromMap, totalInterpolatedDistance, directionsList) {
    // Clear the directions list
    directionsList.innerHTML = '';
    
    // Get all rows
    const allRows = tbody.querySelectorAll('tr');
    if (allRows.length < 2) return;

    const firstRow = allRows[0];
    const secondRow = allRows[1];
    const secondRowPath = secondRow.cells[2].textContent;

    // Check if starting point is an endpoint
    const isStartingPointEndpoint = isEndpoint(liveLatLng, foundLayer);

    if (isStartingPointEndpoint) {
        // Hide first row
        firstRow.style.display = 'none';
        
        // Get direction from second row
        let secondRowDirection = secondRow.cells[4].textContent;
        
        // Combine "Head straight and" with the second row direction
        const combinedDirection = `Head straight and ${secondRowDirection}`;
        secondRow.cells[4].textContent = combinedDirection;
        
        // Create direction item with image
        const directionItem = createDirectionItem(combinedDirection);
        directionsList.appendChild(directionItem);
        
        // Add remaining directions
        for (let i = 2; i < allRows.length; i++) {
            const direction = allRows[i].cells[4].textContent;
            if (direction) {
                const directionItem = createDirectionItem(direction);
                directionsList.appendChild(directionItem);
            }
        }
    } else {
        // For non-endpoint case
        // Get the direction between current path and next path
        const nextDirection = directionsData[pathNameFromMap]?.related_paths[secondRowPath] || '';
        const firstDirection = `Head straight...${nextDirection} for ${totalInterpolatedDistance.toFixed(2)} metres`;
        
        // Update first row's direction
        firstRow.cells[4].textContent = firstDirection;
        
        // Create direction item with image for first row
        const firstDirectionItem = createDirectionItem(firstDirection);
        directionsList.appendChild(firstDirectionItem);
        
        // Add all remaining directions
        for (let i = 1; i < allRows.length; i++) {
            const direction = allRows[i].cells[4].textContent;
            if (direction) {
                const directionItem = createDirectionItem(direction);
                directionsList.appendChild(directionItem);
            }
        }
    }
}

document.getElementById('coordSearchBtn').addEventListener('click', function() {
    const coordSource1 = document.getElementById('coordSource1').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;
    const directionsList1 = document.getElementById('directionsList1');

    if (!coordSource ) {
        alert('Please click on a path or a building until a popup appears of the name of the path or building.');
        return;
    }
    if ( !coordDestination || !coordMode) {
        alert('Please select destination, and mode.');
        return;
    }
    if (previousPolyline) {
        map.removeLayer(previousPolyline);
        previousPolyline = null; // Reset
    }
    if (previousFarthestPolyline) {
        map.removeLayer(previousFarthestPolyline);
        previousFarthestPolyline = null; // Reset
    }
    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource1.split(',').map(Number);
    const liveLatLng = L.latLng(lat1, lng1);  // Live coordinate (coordSource1)

    // Call the function to find the path containing the live coordinate
    const foundLayer = findPathContainingLiveCoordinate(liveLatLng);
    if (!foundLayer) {
        console.log('No matching path found for the live coordinate.');
        return;
    }

    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource1 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
                directionsList1.innerHTML = '';
                document.getElementById('directionsDisplay1').style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource1 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results
                directionsList1.innerHTML = '';
                // Add the new row with coordSource1 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource1;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);
                

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }
// Add the direction as a div in the directionsDisplay section
if (direction) {
    const directionItem = createDirectionItem(direction);
    directionsList1.appendChild(directionItem);  // or directionsList2 for liveSearchBtn
}
                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';
                document.getElementById('directionsDisplay1').style.display = 'block';
                // New Section: Check path in second row, third column
                const secondRow = table.querySelector('tbody').rows[1];  // Get the second row (index 1)
                if (secondRow) {
                    const pathNameFromTable = secondRow.cells[2].textContent;  // Third column of second row
                    const pathNameFromMap = foundLayer.feature.properties.name;  // The name of the path where live coordinate lies
                    let interpolatedPoints = [];  // To store interpolated points for distance calculation
                    let skipFirstPath = false;  // Initialize variable to skip the first path
                    
                    // Compare the path names and call the appropriate highlighting function
if (pathNameFromTable === pathNameFromMap) {
    interpolatedPoints = highlightFarthestInterpolatedPath(liveLatLng, coordSource);  // Store interpolated points
    skipFirstPath = true;  // Skip the first path
} else {
    interpolatedPoints = highlightInterpolatedPath(liveLatLng, coordSource);  // Store interpolated points
}

// Step 4: Calculate the total distance for the first row using interpolated points
const totalInterpolatedDistance = calculateTotalDistance(interpolatedPoints);  // Total distance in meters

// Update the first row's distance cell with the total interpolated distance
newRow.cells[3].textContent = `${totalInterpolatedDistance.toFixed(2)} meters`;
// Add this in your click handlers before calling processDirections
console.log('Path names comparison:', {
    jsonPaths: Object.keys(directionsData),
    tablePathName: secondRow.cells[2].textContent,
    layerPathName: foundLayer.feature.properties.name
});
processDirections(tbody, liveLatLng, foundLayer, pathNameFromMap, totalInterpolatedDistance, directionsList1);
                      
                    // Highlight paths on the map
                    highlightPaths(result.path, skipFirstPath); 
                   // Extract coordinates and display black dots
                   displayAllPathPoints(result, foundLayer, pathNameFromMap, liveLatLng, pathNameFromTable);
                } else {
                    console.log('The second row of the table does not exist.');
                }
                 
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});

document.getElementById('liveSearchBtn').addEventListener('click', function() {
    const coordSource4 = document.getElementById('coordSource4').value;
    const coordSource = document.getElementById('coordSource').value;
    const coordDestination = document.getElementById('coordDestination').value;
    const coordMode = document.getElementById('coordMode').value;
    const directionsList2 = document.getElementById('directionsList2'); 
    
    if (!coordDestination || !coordMode) {
        alert('Please select destination and mode.');
        return;
    }

   // Replace this alert with the modal
   if (!coordSource4) {
        showOutsideCampusModal();
        return;
    }
    if (previousPolyline) {
        map.removeLayer(previousPolyline);
        previousPolyline = null; // Reset
    }
    if (previousFarthestPolyline) {
        map.removeLayer(previousFarthestPolyline);
        previousFarthestPolyline = null; // Reset
    }
    // Split the coordinates from the text input
    const [lat1, lng1] = coordSource4.split(',').map(Number);
    const liveLatLng = L.latLng(lat1, lng1);  // Live coordinate (coordSource4)

    // Call the function to find the path containing the live coordinate
    const foundLayer = findPathContainingLiveCoordinate(liveLatLng);
    if (!foundLayer) {
        console.log('No matching path found for the live coordinate.');
        return;
    }

    const [lat2, lng2] = coordSource.split(',').map(Number);
    const distanceBetweenCoords = calculateDistance(L.latLng(lat1, lng1), L.latLng(lat2, lng2)); // Distance between coordSource4 and coordSource

    const userLatLng = L.latLng(lat2, lng2);  // This is the coordSource LatLng

    // Find the nearest point or LineString endpoint to the user-selected coordinate
    const nearestLocation = findNearestPoint(userLatLng, featureLayers);

    if (!nearestLocation) {
        alert('No nearest location found.');
        return;
    }

    let source;
    if (nearestLocation.latLng) { // If it's a LineString coordinate (nearest endpoint)
        source = nearestLocation.latLng; // Use the closest endpoint
    } else {
        source = nearestLocation.name; // It's already a point
    }

    // Proceed with shortest path calculation using the found source (nearest Point or endpoint)
    fetch(`/shortest-path?source=${source}&destination=${coordDestination}&mode=${coordMode}`)
        .then(response => response.json())
        .then(result => {
            const resultDiv = document.getElementById('coordResult');
            const table = document.getElementById('coordPathTable');
            const tbody = table.querySelector('tbody');

            if (result.error) {
                resultDiv.textContent = result.error;
                table.style.display = 'none';
                directionsList2.innerHTML = '';
        document.getElementById('directionsDisplay2').style.display = 'none';
            } else {
                // Total distance will include the distance between coordSource4 and coordSource
                let totalDistance = distanceBetweenCoords;

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`;

                tbody.innerHTML = ''; // Clear previous results
                directionsList2.innerHTML = '';
                // Add the new row with coordSource4 and coordSource
                let newRow = document.createElement('tr');
                
                let fromCell = document.createElement('td');
                fromCell.textContent = coordSource4;
                newRow.appendChild(fromCell);

                let toCell = document.createElement('td');
                toCell.textContent = coordSource;
                newRow.appendChild(toCell);

                let pathCell = document.createElement('td');
                pathCell.textContent = '';  // Leave path blank
                newRow.appendChild(pathCell);

                let distanceCell = document.createElement('td');
                newRow.appendChild(distanceCell);

                let directionCell = document.createElement('td');
                directionCell.textContent = '';  // Leave directions blank
                newRow.appendChild(directionCell);

                tbody.appendChild(newRow);

                // Iterate through the result path to populate the rest of the table
                result.path.forEach((pathEntry, index) => {
                    const { from, to, path, distance } = pathEntry;

                    let row = document.createElement('tr');

                    let fromCell = document.createElement('td');
                    fromCell.textContent = from;
                    row.appendChild(fromCell);

                    let toCell = document.createElement('td');
                    toCell.textContent = to;
                    row.appendChild(toCell);

                    let pathCell = document.createElement('td');
                    pathCell.textContent = path;
                    row.appendChild(pathCell);

                    let distanceCell = document.createElement('td');
                    distanceCell.textContent = distance;
                    row.appendChild(distanceCell);

                    totalDistance += distance;  // Add this path's distance to the total

                    // Get direction for this path
                    let direction = '';
                    if (index < result.path.length - 1) { // Check if there is a next path
                        const nextPathName = result.path[index + 1].path;
                        if (directionsData[path] && directionsData[path].related_paths[nextPathName]) {
                            direction = `${directionsData[path].related_paths[nextPathName]} after ${distance.toFixed(2)} metres`;
                        }
                    } else { // For the last row, say "Destination"
                        direction = `Destination in ${distance.toFixed(2)} metres`;
                    }
                   if (direction) {
    const directionItem = createDirectionItem(direction);
    directionsList2.appendChild(directionItem);  // or directionsList2 for liveSearchBtn
}

                    let directionCell = document.createElement('td');
                    directionCell.textContent = direction;
                    row.appendChild(directionCell);

                    tbody.appendChild(row);
                });

                resultDiv.textContent = `Total Distance: ${totalDistance.toFixed(2)} meters`; // Update with total distance
                table.style.display = 'table';
                document.getElementById('directionsDisplay2').style.display = 'block';
                // New Section: Check path in second row, third column
                const secondRow = table.querySelector('tbody').rows[1];  // Get the second row (index 1)
                if (secondRow) {
                    const pathNameFromTable = secondRow.cells[2].textContent;  // Third column of second row
                    const pathNameFromMap = foundLayer.feature.properties.name;  // The name of the path where live coordinate lies
                    let interpolatedPoints = [];  // To store interpolated points for distance calculation
                    let skipFirstPath = false;  // Initialize variable to skip the first path
                    
                    // Compare the path names and call the appropriate highlighting function
if (pathNameFromTable === pathNameFromMap) {
    interpolatedPoints = highlightFarthestInterpolatedPath(liveLatLng, coordSource);  // Store interpolated points
    skipFirstPath = true;  // Skip the first path
} else {
    interpolatedPoints = highlightInterpolatedPath(liveLatLng, coordSource);  // Store interpolated points
}

// Step 4: Calculate the total distance for the first row using interpolated points
const totalInterpolatedDistance = calculateTotalDistance(interpolatedPoints);  // Total distance in meters

// Update the first row's distance cell with the total interpolated distance
newRow.cells[3].textContent = `${totalInterpolatedDistance.toFixed(2)} meters`;
// Add this in your click handlers before calling processDirections
console.log('Path names comparison:', {
    jsonPaths: Object.keys(directionsData),
    tablePathName: secondRow.cells[2].textContent,
    layerPathName: foundLayer.feature.properties.name
});
processDirections(tbody, liveLatLng, foundLayer, pathNameFromMap, totalInterpolatedDistance, directionsList2);

                      
                    // Highlight paths on the map
                    highlightPaths(result.path, skipFirstPath);  // Call the function with skipFirstPath flag
                    
                    displayLivePathPoints(result, foundLayer, pathNameFromMap, liveLatLng, pathNameFromTable);
               
                } else {
                    console.log('The second row of the table does not exist.');
                }
                 
            }
        })
        .catch(error => console.error('Error calculating shortest path:', error));
});



// Function to interpolate between two coordinates, ensuring points are correctly placed even on straight lines
function interpolateCoordinates(coord1, coord2, numPoints) {
    let interpolatedPoints = [];
    let latDiff = coord2[1] - coord1[1];
    let lngDiff = coord2[0] - coord1[0];

    // Ensure we always interpolate even when the line is straight by dividing the lat and lng difference
    for (let i = 0; i <= numPoints; i++) {
        let factor = i / numPoints;  // Calculate interpolation factor (between 0 and 1)
        
        // Interpolate both latitude and longitude using linear interpolation
        let interpolatedLat = coord1[1] + (latDiff * factor);
        let interpolatedLng = coord1[0] + (lngDiff * factor);
        
        interpolatedPoints.push([interpolatedLng, interpolatedLat]);
    }

    return interpolatedPoints;
}


// Function to extract all coordinates including interpolated points along the LineString
function extractCoordinates(lineCoords, numInterpolatedPoints) {
    let allCoordinates = [];

    for (let i = 0; i < lineCoords.length - 1; i++) {
        let coord1 = [lineCoords[i].lng, lineCoords[i].lat];
        let coord2 = [lineCoords[i + 1].lng, lineCoords[i + 1].lat];
        let segmentPoints = interpolateCoordinates(coord1, coord2, numInterpolatedPoints);
        allCoordinates = allCoordinates.concat(segmentPoints);

       
    }

    return allCoordinates;
}


// Function to find the closest interpolated point to the live coordinate
function findClosestInterpolatedPoint(liveCoord, interpolatedPoints) {
    let closestPoint = null;
    let shortestDistance = Infinity;

    interpolatedPoints.forEach(point => {
        let pointLatLng = L.latLng(point[1], point[0]);
        let distance = calculateDistance(liveCoord, pointLatLng);
        if (distance < shortestDistance) {
            shortestDistance = distance;
            closestPoint = point;
        }
    });

    return closestPoint;
}

// Global variables to store the current polyline and circles
let currentPolyline = null;
let currentCircles = [];

// Function to remove the current polyline and circles from the map
function clearCurrentPolylineAndCircles() {
    if (currentPolyline) {
        map.removeLayer(currentPolyline);  // Remove the polyline from the map
        currentPolyline = null;  // Reset the reference
    }
    currentCircles.forEach(circle => {
        map.removeLayer(circle);  // Remove each circle from the map
    });
    currentCircles = [];  // Reset the array
}


// Modified function to find the closest path where live coordinates belong, interpolate points, and call the new function
function findPathContainingLiveCoordinate(liveLatLng) {
    let foundLayer = null;
    let closestPath = null;
    let shortestDistance = Infinity;

    // Iterate through all path layers to find the closest path to the live coordinate
    pathLayers.forEach(layerObj => {
        const lineCoords = layerObj.layer.getLatLngs();

        // Loop through each segment formed by consecutive points
        for (let i = 0; i < lineCoords.length - 1; i++) {
            const segmentStart = lineCoords[i];
            const segmentEnd = lineCoords[i + 1];

            // Project the liveLatLng onto the current segment
            const projectedPoint = projectOntoSegment(liveLatLng, segmentStart, segmentEnd);

            // Calculate the distance between the liveLatLng and the projected point
            const distance = calculateDistance(liveLatLng, projectedPoint);

            // Check if the projected point is on the segment and if the distance is smaller than our threshold
            if (isPointOnSegment(projectedPoint, segmentStart, segmentEnd) && distance < 2 && distance < shortestDistance) {
                foundLayer = layerObj.layer;
                shortestDistance = distance;
                closestPath = layerObj;
            }
        }
    });

    // If a path is found
    if (closestPath) {
        console.log(`Live coordinate belongs to path: ${closestPath.name}`);

        // Get the coordinates of the LineString where live coordinates lie
        const lineCoords = closestPath.layer.getLatLngs();

        // Interpolate 1000 points along the path
        const interpolatedPoints = extractCoordinates(lineCoords, 1000);

        // Find the closest interpolated point to the live coordinate
        const closestInterpolatedPoint = findClosestInterpolatedPoint(liveLatLng, interpolatedPoints);

        // Find the nearest endpoint to the live coordinate
        const nearestEndpoint = findNearestEndpoint(liveLatLng, lineCoords);

        // Find the farthest endpoint to the live coordinate
        const farthestEndpoint = findFarthestEndpoint(liveLatLng, lineCoords);

        // Log the live coordinate, the closest interpolated point, nearest endpoint, and farthest endpoint
        console.log(`Live coordinate: ${liveLatLng.lat}, ${liveLatLng.lng}`);
        console.log(`Closest interpolated point: ${closestInterpolatedPoint[1]}, ${closestInterpolatedPoint[0]}`);
        console.log(`Nearest endpoint: ${nearestEndpoint.lat}, ${nearestEndpoint.lng}`);
        console.log(`Farthest endpoint: ${farthestEndpoint.lat}, ${farthestEndpoint.lng}`);
    } else {
        console.log('No matching path found for the live coordinate.');
    }

    return foundLayer;
}

// Helper function to calculate the distance between two coordinates (Haversine formula or Leaflet's distanceTo)
function calculateDistance(latlng1, latlng2) {
    return latlng1.distanceTo(latlng2); // Using Leaflet's built-in method
}

// Helper function to project a point onto a line segment
function projectOntoSegment(point, segmentStart, segmentEnd) {
    const x1 = segmentStart.lng, y1 = segmentStart.lat;
    const x2 = segmentEnd.lng, y2 = segmentEnd.lat;
    const x3 = point.lng, y3 = point.lat;

    const px = x2 - x1;
    const py = y2 - y1;
    const norm = px * px + py * py;
    const u = ((x3 - x1) * px + (y3 - y1) * py) / norm;

    const clampedU = Math.max(Math.min(u, 1), 0); // Clamp the projection factor to [0, 1]
    return L.latLng(y1 + clampedU * py, x1 + clampedU * px);
}

// Helper function to check if a point is on a segment between two points (using a small tolerance)
function isPointOnSegment(point, segmentStart, segmentEnd) {
    const tolerance = 0.00001; // Adjust tolerance as needed
    const minLat = Math.min(segmentStart.lat, segmentEnd.lat) - tolerance;
    const maxLat = Math.max(segmentStart.lat, segmentEnd.lat) + tolerance;
    const minLng = Math.min(segmentStart.lng, segmentEnd.lng) - tolerance;
    const maxLng = Math.max(segmentStart.lng, segmentEnd.lng) + tolerance;

    return point.lat >= minLat && point.lat <= maxLat && point.lng >= minLng && point.lng <= maxLng;
}

// Function to find the nearest point or LineString endpoint to the selected coordinate
function findNearestPoint(userLatLng, featureLayers) {
    let nearestPoint = null;
    let shortestDistance = Infinity;

    featureLayers.forEach(featureLayer => {
        // For Point features, compare directly
        if (featureLayer.featureType === "Point") {
            const pointLatLng = featureLayer.layer.getLatLng();
            const distance = calculateDistance(userLatLng, pointLatLng);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = featureLayer;
            }
        }
        // For LineString features, check the closest endpoint (first or last)
        else if (featureLayer.featureType === "LineString") {
            const lineCoords = featureLayer.layer.getLatLngs();
            const closestEndpoint = findNearestEndpoint(userLatLng, lineCoords);  // Only consider endpoints
            const distance = calculateDistance(userLatLng, closestEndpoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearestPoint = { // Store the closest endpoint on the LineString
                    name: featureLayer.name,
                    latLng: closestEndpoint  // Use closest endpoint
                };
            }
        }
    });

    return nearestPoint;
}


// Function to find the nearest endpoint (first or last) of a LineString to the selected coordinate
function findNearestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the closer endpoint
    return distanceToFirst < distanceToLast ? firstPoint : lastPoint;
}

// Function to find the farthest endpoint (first or last) of a LineString to the selected coordinate
function findFarthestEndpoint(userLatLng, lineLatLngs) {
    const firstPoint = L.latLng(lineLatLngs[0].lat, lineLatLngs[0].lng);
    const lastPoint = L.latLng(lineLatLngs[lineLatLngs.length - 1].lat, lineLatLngs[lineLatLngs.length - 1].lng);

    const distanceToFirst = calculateDistance(userLatLng, firstPoint);
    const distanceToLast = calculateDistance(userLatLng, lastPoint);

    // Return the farther endpoint
    return distanceToFirst > distanceToLast ? firstPoint : lastPoint;
}












// Function to find the nearest path to the live coordinates
function findNearestPath(latLng) {
    let closestPathLayer = null;
    let shortestDistance = Infinity;

    // Iterate over each path layer to find the nearest path
    pathLayers.forEach(layerObj => {
        const lineCoords = layerObj.layer.getLatLngs();

        // Loop through each segment in the LineString
        for (let i = 0; i < lineCoords.length - 1; i++) {
            const segmentStart = lineCoords[i];
            const segmentEnd = lineCoords[i + 1];
            const projectedPoint = projectOntoSegment(latLng, segmentStart, segmentEnd);
            const distance = latLng.distanceTo(projectedPoint);

            if (distance < shortestDistance) {
                shortestDistance = distance;
                closestPathLayer = layerObj;
            }
        }
    });

    return closestPathLayer;
}
// Define USIU border coordinates
const usiuBorderCoordinates = [
    [36.87955443924471, -1.219551075108555],
    [36.88037134879136, -1.217190265152894],
    [36.87947858336054, -1.216892743808472],
    [36.88008371098167, -1.215087768554767],
    [36.88062053725127, -1.213538202193178],
    [36.88105035207693, -1.212298748613264],
    [36.88155652792798, -1.210725392425729],
    [36.8820396957874, -1.209330117409436],
    [36.88198601046969, -1.209157595889621],
    [36.88250614385259, -1.207667519774219],
    [36.88192597175444, -1.207468611988716],
    [36.87976691605007, -1.208590633902929],
    [36.87943118459978, -1.209578710366813],
    [36.87901302624101, -1.210807708413114],
    [36.87837584694205, -1.21256479572547],
    [36.87783371200825, -1.214185746911923],
    [36.87705033861167, -1.21648884154898],
    [36.87682962626818, -1.217160153032182],
    [36.87707956928878, -1.217452297793216],
    [36.87821893293008, -1.218665855956189],
    [36.8790042397402, -1.21947140938309],
    [36.87932697817411, -1.219782232991832],
    [36.87955443924471, -1.219551075108555]
];

// Function to check if a point is inside a polygon using ray casting algorithm
function isPointInPolygon(point, polygon) {
    const x = point[0], y = point[1];
    let inside = false;

    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i][0], yi = polygon[i][1];
        const xj = polygon[j][0], yj = polygon[j][1];

        const intersect = ((yi > y) !== (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }

    return inside;
}
var liveMarker = L.marker([ -1.219645599730465,36.87932573861777], {  // Replace with your desired coordinates
    draggable: true, 
    zIndexOffset: 1000 
}).addTo(map);

// Function to initialize marker coordinates
function initializeMarkerCoordinates() {
    const initialLatLng = liveMarker.getLatLng();
    const initialPoint = [initialLatLng.lng, initialLatLng.lat];

    // Check if initial position is inside USIU border
    if (isPointInPolygon(initialPoint, usiuBorderCoordinates)) {
        document.getElementById('coordSource2').value = `${initialLatLng.lat}, ${initialLatLng.lng}`;

        // Find the nearest path and update other fields
        const closestPathLayer = findNearestPath(initialLatLng);
        if (closestPathLayer) {
            const lineCoords = closestPathLayer.layer.getLatLngs();
            const interpolatedPoints = extractCoordinates(lineCoords, 1000);
            const closestInterpolatedPoint = findClosestInterpolatedPoint(initialLatLng, interpolatedPoints);
            const nearestEndpoint = findNearestEndpoint(
                L.latLng(closestInterpolatedPoint[1], closestInterpolatedPoint[0]), 
                lineCoords
            );

            // Update both coordSource and coordSource4
            document.getElementById('coordSource').value = `${nearestEndpoint.lat}, ${nearestEndpoint.lng}`;
            document.getElementById('coordSource4').value = `${closestInterpolatedPoint[1]}, ${closestInterpolatedPoint[0]}`;
            
            // Log the values for debugging
            console.log('Initial coordinates set:', {
                coordSource2: document.getElementById('coordSource2').value,
                coordSource4: document.getElementById('coordSource4').value,
                coordSource: document.getElementById('coordSource').value
            });
        }
    }
}

// Initialize coordinates when the map is ready
map.whenReady(() => {
    setTimeout(initializeMarkerCoordinates, 500); // Add a small delay to ensure all elements are loaded
});


// Set initial tooltip
liveMarker.bindTooltip("Drag me to get coordinates").openTooltip();

// Handle marker movement
liveMarker.on('move', function(e) {
    const latLng = e.target.getLatLng();
    const point = [latLng.lng, latLng.lat]; // Note: GeoJSON uses [longitude, latitude]

    // Check if the point is inside USIU border
    if (isPointInPolygon(point, usiuBorderCoordinates)) {
        // Point is inside USIU - update the coordinate fields
        document.getElementById('coordSource2').value = `${latLng.lat}, ${latLng.lng}`;

        // Find the nearest path and update other fields
        const closestPathLayer = findNearestPath(latLng);
        if (closestPathLayer) {
            const lineCoords = closestPathLayer.layer.getLatLngs();
            const interpolatedPoints = extractCoordinates(lineCoords, 1000);
            const closestInterpolatedPoint = findClosestInterpolatedPoint(latLng, interpolatedPoints);
            const nearestEndpoint = findNearestEndpoint(L.latLng(closestInterpolatedPoint[1], closestInterpolatedPoint[0]), lineCoords);

            document.getElementById('coordSource').value = `${nearestEndpoint.lat}, ${nearestEndpoint.lng}`;
            document.getElementById('coordSource4').value = `${closestInterpolatedPoint[1]}, ${closestInterpolatedPoint[0]}`;
        } else {
            document.getElementById('coordSource').value = '';
            document.getElementById('coordSource4').value = '';
        }
    } else {
        // Point is outside USIU - clear all coordinate fields
        document.getElementById('coordSource2').value = '';
        document.getElementById('coordSource').value = '';
        document.getElementById('coordSource4').value = '';
    }
});

// Handle drag start
liveMarker.on('dragstart', function() {
    this.unbindTooltip();
});

// Add this variable at the start to track if red circle should follow
let isNearRedCircle = false;
const FOLLOW_DISTANCE = 40; // Distance in meters within which the red circle will follow
// Modal warning variables
let isModalShowing = false;
const WARNING_DISTANCE = 100; // meters
 // Distance in meters within which red circle follows live marker

// Function to clear map elements
function clearMapElements() {
    // Clear interpolated markers
    clearInterpolatedMarkers();
    // Clear red circle
    if (redCircleMarker) {
        map.removeLayer(redCircleMarker);
        redCircleMarker = null;
    }
    // Reset all path colors and remove polylines
    pathLayers.forEach(layerObj => {
        layerObj.layer.setStyle({
            color: layerObj.layer.feature.properties.borderColor || '#000',
            fillColor: layerObj.layer.feature.properties.fillColor || '#ccc'
        });
        // Remove polyline if it exists
        if (layerObj.polyline) {
            map.removeLayer(layerObj.polyline);
            delete layerObj.polyline;
        }
    });
    // Clear the directions display
    const directionsDisplay = document.getElementById('directionsDisplay2');
    if (directionsDisplay) {
        directionsDisplay.style.display = 'none';
    }
    const directionsList = document.getElementById('directionsList2');
    if (directionsList) {
        directionsList.innerHTML = '';
    }
}

// Function to transfer values between controls
function transferControlValues() {
    // Check controls2 first
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;
    
    // If values exist in controls2, transfer to controls3
    if (destination && mode) {
        document.getElementById('coordDestination').value = destination;
        document.getElementById('coordMode').value = mode;
    }
    
    // Make sure sourceType is set to "liveLoc"
    const sourceType = document.getElementById('sourceType');
    if (sourceType) {
        sourceType.value = 'liveLoc';
    }
}
// Add this function to transfer values from controls2 to controls3
function transferControls2ToControls3() {
    // Get values from controls2
    const destination = document.getElementById('destination').value;
    const mode = document.getElementById('mode').value;
    
    // Set values in controls3
    const coordDestination = document.getElementById('coordDestination');
    const coordMode = document.getElementById('coordMode');
    const sourceType = document.getElementById('sourceType');
    
    // Set destination
    if (destination) {
        Array.from(coordDestination.options).forEach(option => {
            if (option.value === destination) {
                option.selected = true;
            }
        });
    }
    
    // Set mode
    if (mode) {
        Array.from(coordMode.options).forEach(option => {
            if (option.value === mode) {
                option.selected = true;
            }
        });
    }
    
    // Set source type to live location
    sourceType.value = 'liveLoc';
}
// Function to trigger live search with current marker position
async function triggerLiveSearch() {
    const markerLatLng = liveMarker.getLatLng();
    
    // Update the coordinate fields
    document.getElementById('coordSource2').value = `${markerLatLng.lat}, ${markerLatLng.lng}`;

    // Find the nearest path and update other fields
    const closestPathLayer = findNearestPath(markerLatLng);
    if (closestPathLayer) {
        const lineCoords = closestPathLayer.layer.getLatLngs();
        const interpolatedPoints = extractCoordinates(lineCoords, 1000);
        const closestInterpolatedPoint = findClosestInterpolatedPoint(markerLatLng, interpolatedPoints);
        const nearestEndpoint = findNearestEndpoint(
            L.latLng(closestInterpolatedPoint[1], closestInterpolatedPoint[0]), 
            lineCoords
        );

        // Update the coordinate fields
        document.getElementById('coordSource').value = `${nearestEndpoint.lat}, ${nearestEndpoint.lng}`;
        document.getElementById('coordSource4').value = `${closestInterpolatedPoint[1]}, ${closestInterpolatedPoint[0]}`;

        // Wait a brief moment to ensure all fields are updated
        await new Promise(resolve => setTimeout(resolve, 100));

        // Click the live search button
        document.getElementById('liveSearchBtn').click();
    }
}
let activeJourneyButton = null;


// Function to update red circle position and handle interactions
function handleRedCircleInteraction(latLng) {
    if (redCircleMarker && interpolatedMarkers.length > 0) {
        const distanceToRedCircle = latLng.distanceTo(redCircleMarker.getLatLng());
        
        if (distanceToRedCircle <= FOLLOW_DISTANCE) {
            // If near, make red circle follow the marker along the path
            const closestPathPoint = findClosestPathPoint(latLng);
            if (closestPathPoint) {
                redCircleMarker.setLatLng(closestPathPoint);
                
                // Trigger the drag event on red circle to update directions
                redCircleMarker.fire('drag', {
                    latlng: closestPathPoint
                });
            }
            liveMarker.bindTooltip("Controlling red marker").openTooltip();
            return true;
        } else if (distanceToRedCircle <= FOLLOW_DISTANCE * 2) {
            // Show "Getting closer" message when approaching red circle
            liveMarker.bindTooltip("Move closer to control red marker").openTooltip();
        } else {
            liveMarker.bindTooltip("Valid location inside USIU").openTooltip();
        }
    }
    return false;
}
// Add these global variables at the top with your other globals
let journeyStarted = false;
document.addEventListener('DOMContentLoaded', function() {
    const startjourney1 = document.getElementById('startjourney1');
    const startjourney2 = document.getElementById('startjourney2');
    
    const newStartjourney1 = startjourney1.cloneNode(true);
    const newStartjourney2 = startjourney2.cloneNode(true);
    
    startjourney1.parentNode.replaceChild(newStartjourney1, startjourney1);
    startjourney2.parentNode.replaceChild(newStartjourney2, startjourney2);

    // Add event listener for startjourney1
    newStartjourney1.addEventListener('click', function(e) {
        const markerLatLng = liveMarker.getLatLng();
        const point = [markerLatLng.lng, markerLatLng.lat];
        
        if (!isPointInPolygon(point, usiuBorderCoordinates)) {
            e.preventDefault();
            showOutsideCampusModal();
            return;
        }

        const destination = document.getElementById('destination').value;
        const mode = document.getElementById('mode').value;

        if (!destination || !mode) {
            e.preventDefault();
            alert('Please select both destination and mode before starting the journey.');
            return;
        }

        // Start the journey
        journeyStarted = true;
        activeJourneyButton = 'startjourney1';

        // Enable the direction display container
        const directionDisplayContainer = document.getElementById('directionDisplayContainer');
        if (directionDisplayContainer) {
            directionDisplayContainer.style.display = 'block';
        }
    });

    // Add event listener for startjourney2
    newStartjourney2.addEventListener('click', function(e) {
        const destination = document.getElementById('coordDestination').value;
        const mode = document.getElementById('coordMode').value;

        if (!destination || !mode) {
            e.preventDefault();
            alert('Please select both destination and mode before starting the journey.');
            return;
        }

        // Start the journey
        journeyStarted = true;
        activeJourneyButton = 'startjourney2';

        // Enable the direction display container
        const directionDisplayContainer = document.getElementById('directionDisplayContainer');
        if (directionDisplayContainer) {
            directionDisplayContainer.style.display = 'block';
        }
    });
});

// Helper function to check if a point is inside USIU border
function isValidLocation(coordSource) {
    if (!coordSource) return false;
    
    const [lat, lng] = coordSource.split(',').map(coord => coord.trim());
    const point = [parseFloat(lng), parseFloat(lat)];
    
    return isPointInPolygon(point, usiuBorderCoordinates);
}

// Add this new function to show the outside campus modal
function showOutsideCampusModal() {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        z-index: 1000;
        text-align: center;
    `;
    
    modal.innerHTML = `
        <h3 style="margin-bottom: 15px; color: #dc3545;">Outside USIU Campus</h3>
        <p style="margin-bottom: 20px;">You are outside the USIU campus. You cannot use this feature.</p>
        <button id="closeModalBtn" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
    `;
    
    document.body.appendChild(modal);

    // Handle Close button click
    document.getElementById('closeModalBtn').onclick = function() {
        document.body.removeChild(modal);
    };
}


// Function to check distance and show modal
// function checkDistance() {
//     if (!redCircleMarker || !liveMarker) return;
    
//     const latLng = liveMarker.getLatLng();
//     const distanceToRedCircle = latLng.distanceTo(redCircleMarker.getLatLng());
    
//     if (distanceToRedCircle > WARNING_DISTANCE && !isModalShowing) {
//         showWarningModal();
//     }
// }
// Update the showWarningModal function
function showWarningModal() {
    isModalShowing = true;
    
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        z-index: 1000;
    `;
    
    modal.innerHTML = `
        <h3 style="margin-bottom: 15px;">You are far from the given path</h3>
        <p>Would you like to start closer to your position?</p>
        <div style="margin-top: 20px; display: flex; justify-content: flex-end; gap: 10px;">
            <button id="modalYesBtn" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Yes</button>
            <button id="modalExitBtn" style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">Exit</button>
        </div>
    `;
    
    document.body.appendChild(modal);

    // Handle Yes button click
    document.getElementById('modalYesBtn').onclick = async function() {
        // If startjourney1 was clicked, transfer values from controls2 to controls3
        if (activeJourneyButton === 'startjourney1') {
            transferControls2ToControls3();
        }
        
        document.body.removeChild(modal);
        isModalShowing = false;
        
        // Wait a brief moment for the values to be transferred
        await new Promise(resolve => setTimeout(resolve, 100));
        
        await triggerLiveSearch();
    };

    // Handle Exit button click
    document.getElementById('modalExitBtn').onclick = function() {
        document.body.removeChild(modal);
        isModalShowing = false;
    };
}

// Add these global variables at the top of your script
let isNavigationActive = false;
const REROUTE_WARNING_DISTANCE = 40; // Distance in meters
let rerooteModalShown = false; // To prevent multiple modals

// Modify your live marker's move event
liveMarker.on('move', function(e) {
    const latLng = e.target.getLatLng();
    const point = [latLng.lng, latLng.lat];
    
    if (isPointInPolygon(point, usiuBorderCoordinates)) {
        document.getElementById('coordSource2').value = `${latLng.lat}, ${latLng.lng}`;

        const closestPathLayer = findNearestPath(latLng);
        if (closestPathLayer) {
            const lineCoords = closestPathLayer.layer.getLatLngs();
            const interpolatedPoints = extractCoordinates(lineCoords, 1000);
            const closestInterpolatedPoint = findClosestInterpolatedPoint(latLng, interpolatedPoints);
            const nearestEndpoint = findNearestEndpoint(
                L.latLng(closestInterpolatedPoint[1], closestInterpolatedPoint[0]), 
                lineCoords
            );

            document.getElementById('coordSource').value = `${nearestEndpoint.lat}, ${nearestEndpoint.lng}`;
            document.getElementById('coordSource4').value = `${closestInterpolatedPoint[1]}, ${closestInterpolatedPoint[0]}`;

            // Control red circle when navigation is active
            if (isNavigationActive && redCircleMarker) {
                const distanceToRedCircle = latLng.distanceTo(redCircleMarker.getLatLng());
                
                // If close enough, move red circle
                if (distanceToRedCircle <= FOLLOW_DISTANCE) {
                    const closestPoint = findClosestPathPoint(latLng);
                    if (closestPoint) {
                        redCircleMarker.setLatLng(closestPoint);
                        redCircleMarker.fire('drag', {
                            latlng: closestPoint
                        });
                    }
                }
                // If too far and modal not shown, show reroute modal
                else if (distanceToRedCircle > REROUTE_WARNING_DISTANCE && !rerooteModalShown) {
                    rerooteModalShown = true; // Prevent multiple modals
                    
                    // Determine current navigation container
                    let currentContainer = null;
                    let sourceText = '';
                    let destText = '';

                    ['subnav7Container', 'subnav8Container', 'subnav9Container'].forEach(containerId => {
                        const container = document.getElementById(containerId);
                        if (container && container.style.display === 'block') {
                            currentContainer = containerId;
                            const navNumber = containerId.charAt(6);
                            sourceText = document.getElementById(`sourceHeadingNav${navNumber}`).textContent;
                            destText = document.getElementById(`destinationHeadingNav${navNumber}`).textContent;
                        }
                    });

                    if (currentContainer) {
                        showRerouteModal(currentContainer, sourceText, destText);
                    }
                }
            }
        }
    }
});

// Function to show reroute modal
function showRerouteModal(currentContainer, sourceText, destText) {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        z-index: 1000;
        text-align: center;
    `;

    modal.innerHTML = `
        <h3 style="margin-bottom: 15px;">Off Route Warning</h3>
        <p style="margin-bottom: 20px;">You are going out of the desired path. Would you like to reroute?</p>
        <div style="display: flex; justify-content: center; gap: 10px;">
            <button id="rerouteYesBtn" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">
                Yes
            </button>
            <button id="closeNavBtn" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">
                Close Navigation
            </button>
        </div>
    `;

    document.body.appendChild(modal);

    // Handle Yes button
    modal.querySelector('#rerouteYesBtn').onclick = async () => {
        document.body.removeChild(modal);
        await handleReroute(currentContainer, sourceText, destText);
        rerooteModalShown = false; // Reset modal flag
    };

    // Handle Close Navigation button
    modal.querySelector('#closeNavBtn').onclick = () => {
        document.body.removeChild(modal);
        closeNavigation(currentContainer);
        rerooteModalShown = false; // Reset modal flag
    };
}
// First, add this CSS to your existing styles
const loadingStyles = document.createElement('style');
loadingStyles.textContent = `
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 2000;
}

.loading-spinner {
    width: 50px;
    height: 50px;
    border: 5px solid #f3f3f3;
    border-top: 5px solid #ff6600;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.loading-text {
    color: white;
    margin-top: 20px;
    font-size: 1.2em;
}

.loading-countdown {
    color: #ff6600;
    margin-top: 10px;
    font-size: 1.5em;
    font-weight: bold;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
`;
document.head.appendChild(loadingStyles);

// Function to create and show loading overlay with countdown
function showLoadingWithCountdown(seconds, onComplete) {
    const overlay = document.createElement('div');
    overlay.className = 'loading-overlay';
    
    const spinner = document.createElement('div');
    spinner.className = 'loading-spinner';
    
    const text = document.createElement('div');
    text.className = 'loading-text';
    text.textContent = 'Calculating new route';
    
    const countdown = document.createElement('div');
    countdown.className = 'loading-countdown';
    
    overlay.appendChild(spinner);
    overlay.appendChild(text);
    overlay.appendChild(countdown);
    document.body.appendChild(overlay);
    
    let timeLeft = seconds;
    
    const countdownInterval = setInterval(() => {
        timeLeft -= 1;
        countdown.textContent = `${timeLeft} seconds`;
        
        if (timeLeft <= 0) {
            clearInterval(countdownInterval);
            document.body.removeChild(overlay);
            if (onComplete) onComplete();
        }
    }, 1000);

    // Start with initial value
    countdown.textContent = `${timeLeft} seconds`;
     animateLoadingText();
}

// Modify the handleReroute function to include the loading animation
async function handleReroute(currentContainer, sourceText, destText) {
    // Hide all navigation containers
    ['subnav7Container', 'subnav8Container', 'subnav9Container'].forEach(container => {
        document.getElementById(container).style.display = 'none';
    });

    // Show sub9 container
    const sub9Container = document.getElementById('sub9DivContainer');
    sub9Container.style.display = 'block';

    // Set headings
    document.getElementById('sub9SourceHeading').textContent = 'Source: Live location';
    document.getElementById('sub9DestinationHeading').textContent = destText;

    // Click get directions button
    const getDirectionsBtn = document.getElementById('getDirectionsBtnSub9');
    if (getDirectionsBtn) {
        getDirectionsBtn.click();
        
        // Show loading overlay with countdown
        showLoadingWithCountdown(7, () => {
            // This will execute after countdown finishes
            const startJourneyBtn = document.getElementById('startJourneyBtnSub9');
            if (startJourneyBtn) {
                startJourneyBtn.click();
            }
        });
    }
}

// Optional: Add loading text animation
function animateLoadingText() {
    const loadingText = document.querySelector('.loading-text');
    if (!loadingText) return;

    let dots = 0;
    const interval = setInterval(() => {
        dots = (dots + 1) % 4;
        loadingText.textContent = 'Calculating new route' + '.'.repeat(dots);
    }, 500);

    // Clear interval when overlay is removed
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.removedNodes) {
                mutation.removedNodes.forEach((node) => {
                    if (node.classList && node.classList.contains('loading-overlay')) {
                        clearInterval(interval);
                        observer.disconnect();
                    }
                });
            }
        });
    });

    observer.observe(document.body, {
        childList: true
    });
}

// Add animation to loading overlay creation
const originalShowLoadingWithCountdown = showLoadingWithCountdown;
showLoadingWithCountdown = function(seconds, onComplete) {
    originalShowLoadingWithCountdown(seconds, onComplete);
    animateLoadingText();
};

// Function to close navigation
function closeNavigation(currentContainer) {
    // Hide all navigation containers
    ['subnav7Container', 'subnav8Container', 'subnav9Container'].forEach(container => {
        document.getElementById(container).style.display = 'none';
    });

    // Determine which container to show and reset
    const containerMap = {
        'subnav7Container': 'sub7DivContainer',
        'subnav8Container': 'sub8DivContainer',
        'subnav9Container': 'sub9DivContainer'
    };

    const containerToShow = containerMap[currentContainer];
    if (containerToShow) {
        const container = document.getElementById(containerToShow);
        container.style.display = 'block';
        resetContainer(containerToShow);
    }

    isNavigationActive = false;
}

// Function to reset container state
function resetContainer(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;

    // Reset mode buttons
    const modeButtons = container.querySelectorAll('.mode-btn');
    modeButtons.forEach(btn => btn.classList.remove('active'));

    // Hide directions display
    const directionsDisplay = container.querySelector('[id^="directionsDisplay"]');
    if (directionsDisplay) {
        directionsDisplay.style.display = 'none';
    }

    // Clear directions list
    const directionsList = container.querySelector('[id^="directionsList"]');
    if (directionsList) {
        directionsList.innerHTML = '';
    }
}

// Update your start journey button handlers
['startJourneyBtn', 'startJourneyBtnSub8', 'startJourneyBtnSub9'].forEach(btnId => {
    const btn = document.getElementById(btnId);
    if (btn) {
        const originalClick = btn.onclick;
        btn.onclick = async function(e) {
            if (originalClick) await originalClick.call(this, e);
            isNavigationActive = true;
            rerooteModalShown = false;
        };
    }
});

// Update your exit navigation functions
function exitNavigationSub7() {
    isNavigationActive = false;
    rerooteModalShown = false;
    document.getElementById('subnav7Container').style.display = 'none';
    document.getElementById('sub7DivContainer').style.display = 'block';
}

function exitNavigationSub8() {
    isNavigationActive = false;
    rerooteModalShown = false;
    document.getElementById('subnav8Container').style.display = 'none';
    document.getElementById('sub8DivContainer').style.display = 'block';
}

function exitNavigationSub9() {
    isNavigationActive = false;
    rerooteModalShown = false;
    document.getElementById('subnav9Container').style.display = 'none';
    document.getElementById('sub9DivContainer').style.display = 'block';
}
// Update the resetJourney function to also reset the activeJourneyButton
function resetJourney() {
    journeyStarted = false;
    activeJourneyButton = null;
    if (redCircleMarker) {
        map.removeLayer(redCircleMarker);
        redCircleMarker = null;
    }
    clearMapElements();
}

document.addEventListener('DOMContentLoaded', function() {
    

    // Reset journey when certain navigation actions occur
    document.getElementById('searchBtn').addEventListener('click', resetJourney);
    document.getElementById('searchBtn1').addEventListener('click', resetJourney);
});
// Handle drag end
liveMarker.on('dragend', function(e) {
    const latLng = e.target.getLatLng();
    const point = [latLng.lng, latLng.lat];
    
    if (!isPointInPolygon(point, usiuBorderCoordinates)) {
        this.bindTooltip("Please drag the marker inside USIU border").openTooltip();
    }
});

function clearJourneyState() {
    journeyStarted = false;
    activeJourneyButton = null;
    
    // Reset direction display for all containers
    ['currentDirection7', 'currentDirection8', 'currentDirection9'].forEach(inputId => {
        const currentDirectionInput = document.getElementById(inputId);
        if (currentDirectionInput) {
            currentDirectionInput.value = '';
        }
    });

    // Hide direction display container in all navigation containers
    ['subnav7Container', 'subnav8Container', 'subnav9Container'].forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container) {
            const directionDisplayContainer = container.querySelector('#directionDisplayContainer');
            if (directionDisplayContainer) {
                directionDisplayContainer.style.display = 'none';
            }
        }
    });
}

// Add this to your existing reset/cleanup functions
function resetControls() {
    // Reset controls2
    document.getElementById('destination').selectedIndex = 0;
    document.getElementById('mode').selectedIndex = 0;
    document.getElementById('pathTable').style.display = 'none';
    document.getElementById('result').textContent = '';

    // Reset controls3
    document.getElementById('coordDestination').selectedIndex = 0;
    document.getElementById('coordMode').selectedIndex = 0;
    document.getElementById('coordSource').value = '';
    document.getElementById('coordSource1').value = '';
    document.getElementById('coordSource2').value = '';
    document.getElementById('coordSource4').value = '';
    document.getElementById('coordPathTable').style.display = 'none';
    document.getElementById('coordResult').textContent = '';

    // Clear journey state
    clearJourneyState();
}

// Add to your existing event listeners for navigation/reset
document.getElementById('backButton')?.addEventListener('click', resetControls);
document.getElementById('searchBtn')?.addEventListener('click', clearJourneyState);
document.getElementById('coordSearchBtn')?.addEventListener('click', clearJourneyState);


















// Function to load categories from destination.json
async function loadCategories() {
    const response = await fetch('destination.json');
    const data = await response.json();
    return data.categories;
}

// Function to display categories dynamically
async function displayCategories() {
    const categoryContainer = document.getElementById('categoryContainer');
    const categories = await loadCategories();

    categories.forEach(category => {
        const div = document.createElement('div');
        div.classList.add('location-category');
        div.id = category.toLowerCase();
        div.textContent = category;
        categoryContainer.appendChild(div);
    });

    // Attach event listeners for dynamically created categories
    document.querySelectorAll('.location-category').forEach(div => {
        div.addEventListener('click', async (e) => {
            const category = e.target.id.charAt(0).toUpperCase() + e.target.id.slice(1);
            const locationsData = await loadLocationsData(); // Load location data if needed
            
            if (locationsData[category]) {
                displaySubDivs(category, locationsData[category]);
            } else {
                console.log(`No sub-divs found for ${category}`);
            }
        });
    });
}

// Call the function to load and display categories when the page loads
document.addEventListener('DOMContentLoaded', displayCategories);




// Function to load locations data from locations.json
async function loadLocationsData() {
    const response = await fetch('locations.json');
    const data = await response.json();
    return data;
}

// Function to display main categories
function showMainCategories() {
    document.getElementById('controlspart2').style.display = 'block';
    document.getElementById('subDivContainer').style.display = 'none';
}

// Function to display sub-divs based on selected main category
function displaySubDivs(category, subDivs) {
    const subDivContainer = document.getElementById('subDivContainer');
    const subDivContent = document.getElementById('subDivContent');
    const subDivHeading = document.getElementById('subDivHeading'); // Get the heading element

    // Set the heading text with the category name, capitalizing each word
    subDivHeading.textContent = category;

    // Clear previous content
    subDivContent.innerHTML = '';

    // Populate subDivContent with new sub-divs
    subDivs.forEach(subDiv => {
        const div = document.createElement('div');
        div.classList.add('sub-location');
        div.textContent = subDiv;
        subDivContent.appendChild(div);
    });

    // Hide main categories and show sub-divs
    document.getElementById('controlspart2').style.display = 'none';
    subDivContainer.style.display = 'block';
}

// Function to load locations data from locations.json
async function loadLocationsData() {
    const response = await fetch('locations.json');
    const data = await response.json();
    return data;
}

// Event listener for main categories
document.querySelectorAll('.location-category').forEach(div => {
    div.addEventListener('click', async (e) => {
        const category = e.target.id.charAt(0).toUpperCase() + e.target.id.slice(1);
        
        // Load the locations data
        const locationsData = await loadLocationsData();
        
        // Check if the clicked category has sub-divs in the data
        if (locationsData[category]) {
            displaySubDivs(category, locationsData[category]);
        } else {
            console.log(`No sub-divs found for ${category}`);
        }
    });
});

// Function for Back Button to show main categories again
function goBack() {
    showMainCategories();
}

// Function to display sub3 view with details
async function displaySub3Details(subDivName) {
    const sub3DivContainer = document.getElementById('sub3DivContainer');
    const sub3DivHeading = document.getElementById('sub3DivHeading');
    const directionsBtn = document.getElementById('directionsBtn');
    const sub3Image = document.getElementById('sub3Image');

    // Fetch the data from subdivs.json
    const response = await fetch('subdivs.json');
    const data = await response.json();

    // Get the details for the clicked subDiv
    const details = data[subDivName];

    if (details) {
        // Update the sub3Div with the fetched details
        sub3DivHeading.textContent = subDivName;
        sub3Image.src = details.image;

        // Fill table with details
        document.getElementById('locationDetail').textContent = details.details.Location;
        document.getElementById('phoneNumberDetail').textContent = details.details["Phone Number"];
        document.getElementById('emailAddressDetail').textContent = details.details["Email Address"];
        document.getElementById('otherDetail').textContent = details.details.Other;

        // Hide subDivContainer and show sub3DivContainer
        document.getElementById('subDivContainer').style.display = 'none';
        sub3DivContainer.style.display = 'block';

        // Reset scroll position to top
        sub3DivContainer.scrollTop = 0;
    } else {
        console.log(`No details found for ${subDivName}`);
    }

}

// Event listener for sub-divs to open sub3 view
document.getElementById('subDivContent').addEventListener('click', function (e) {
    if (e.target.classList.contains('sub-location')) {
        const subDivName = e.target.textContent;
        displaySub3Details(subDivName);
    }
});

// Back button functionality for sub3
function goBackToSubDiv() {
    document.getElementById('sub3DivContainer').style.display = 'none';
    document.getElementById('subDivContainer').style.display = 'block';
}

// Function to display sub4 view when Directions button is clicked on sub3DivContainer
document.getElementById('directionsBtn').addEventListener('click', function() {
    const sub3Heading = document.getElementById('sub3DivHeading').textContent;
    const sub4DestinationHeading = document.getElementById('sub4DestinationHeading');
    
    // Set the destination heading with the text from sub3DivHeading
    sub4DestinationHeading.textContent = `Destination: ${sub3Heading}`;
    
    // Hide sub3DivContainer and show sub4DivContainer
    document.getElementById('sub3DivContainer').style.display = 'none';
    document.getElementById('sub4DivContainer').style.display = 'block';
});

// Back button functionality for sub4DivContainer
function goBackToSub3() {
    document.getElementById('sub4DivContainer').style.display = 'none';
    document.getElementById('sub3DivContainer').style.display = 'block';
}


// Event listener for the searchAreaBtn to open sub5DivContainer
document.getElementById('searchAreaBtn').addEventListener('click', async function () {
    // Hide sub4DivContainer and show sub5DivContainer
    document.getElementById('sub4DivContainer').style.display = 'none';
    document.getElementById('sub5DivContainer').style.display = 'block';

    // Load and display source divs from destination.json
    await displaySub5Content();
});

// Function to load and display sub5 content from destination.json
async function displaySub5Content() {
    const sub5Content = document.getElementById('sub5Content');
    sub5Content.innerHTML = ''; // Clear previous content

    try {
        const response = await fetch('destination.json');
        const data = await response.json();

        console.log("Loaded data:", data); // Log data structure for debugging

        // Check if categories exists in the data and if it’s an array
        if (data.categories && Array.isArray(data.categories)) {
            // Populate sub5Content with divs for each category item in destination.json
            data.categories.forEach(category => {
                const div = document.createElement('div');
                div.classList.add('sub-location'); // You can reuse this class from previous divs
                div.textContent = category; // Display each category
                sub5Content.appendChild(div);
            });
        } else {
            console.error("No 'categories' array found in destination.json");
        }
    } catch (error) {
        console.error('Error loading destination.json:', error);
    }
}

// Back button functionality for sub5DivContainer
function goBackToSub4() {
    document.getElementById('sub5DivContainer').style.display = 'none';
    document.getElementById('sub4DivContainer').style.display = 'block';
}


// Event listener for sub5Content divs to open sub6DivContainer
document.getElementById('sub5Content').addEventListener('click', function (e) {
    if (e.target.classList.contains('sub-location')) {
        const selectedCategory = e.target.textContent; // Get the category name from the clicked div
        displaySub6Content(selectedCategory);
    }
});

// Function to load and display sub6 content from locations.json based on selected category
async function displaySub6Content(category) {
    const sub6Content = document.getElementById('sub6Content');
    sub6Content.innerHTML = ''; // Clear previous content

    try {
        const response = await fetch('locations.json');
        const data = await response.json();

        // Set the heading for sub6DivContainer with the selected category name
        document.getElementById('sub6Heading').textContent = category;

        // Check if the category exists in locations.json and is an array
        if (data[category] && Array.isArray(data[category])) {
            // Populate sub6Content with divs for each item in the selected category
            data[category].forEach(location => {
                const div = document.createElement('div');
                div.classList.add('sub-location'); // Reusing the sub-location class for consistency
                div.textContent = location; // Display each location name
                sub6Content.appendChild(div);
            });
        } else {
            console.error(`No entries found for category: ${category}`);
        }

        // Hide sub5DivContainer and show sub6DivContainer
        document.getElementById('sub5DivContainer').style.display = 'none';
        document.getElementById('sub6DivContainer').style.display = 'block';
    } catch (error) {
        console.error('Error loading locations.json:', error);
    }
}

// Back button functionality for sub6DivContainer
function goBackToSub5() {
    document.getElementById('sub6DivContainer').style.display = 'none';
    document.getElementById('sub5DivContainer').style.display = 'block';
}


let selectedSource = ''; // To store the selected source from sub6
let selectedDestination = ''; // To store the selected destination from sub3

// Capture the destination from sub3DivContainer when navigating to sub4DivContainer
document.getElementById('directionsBtn').addEventListener('click', function() {
    const sub3Heading = document.getElementById('sub3DivHeading').textContent;
    selectedDestination = sub3Heading; // Store the heading as the destination

    // Set the destination heading in sub4DivContainer
    const sub4DestinationHeading = document.getElementById('sub4DestinationHeading');
    sub4DestinationHeading.textContent = `Destination: ${selectedDestination}`;
    
    // Hide sub3DivContainer and show sub4DivContainer
    document.getElementById('sub3DivContainer').style.display = 'none';
    document.getElementById('sub4DivContainer').style.display = 'block';
});

// Event listener for sub6Content divs to open sub7DivContainer
document.getElementById('sub6Content').addEventListener('click', function (e) {
    if (e.target.classList.contains('sub-location')) {
        selectedSource = e.target.textContent; // Set the selected source when an item is clicked in sub6
        displaySub7Content(); // Show sub7DivContainer with selected source and destination
    }
});

// Function to display sub7 content with source and destination details
function displaySub7Content() {
    // Set the source and destination headings
    document.getElementById('sourceHeading').textContent = `Source: ${selectedSource}`;
    document.getElementById('destinationHeading').textContent = `Destination: ${selectedDestination}`;

    // Hide sub6DivContainer and show sub7DivContainer
    document.getElementById('sub6DivContainer').style.display = 'none';
    document.getElementById('sub7DivContainer').style.display = 'block';
}

function goBackToSub6() {
    // Reset controls2 elements
    resetControls2();

    // Show sub6DivContainer and hide sub7DivContainer
    document.getElementById('sub7DivContainer').style.display = 'none';
    document.getElementById('sub6DivContainer').style.display = 'block';
}

// Capture the selected destination from sub4DivContainer when navigating to sub8 or sub9
function setDestinationForSub8AndSub9() {
    const sub4DestinationHeading = document.getElementById('sub4DestinationHeading').textContent;
    document.getElementById('sub8DestinationHeading').textContent = sub4DestinationHeading;
    document.getElementById('sub9DestinationHeading').textContent = sub4DestinationHeading;
}

// Event listener for selectAreaBtn to open sub8DivContainer
document.getElementById('selectAreaBtn').addEventListener('click', function() {
    setDestinationForSub8AndSub9(); // Set the destination heading
    document.getElementById('sub4DivContainer').style.display = 'none';
    document.getElementById('sub8DivContainer').style.display = 'block';
});

// Event listener for useLiveLocationBtn to open sub9DivContainer
document.getElementById('useLiveLocationBtn').addEventListener('click', function() {
    setDestinationForSub8AndSub9(); // Set the destination heading
    document.getElementById('sub4DivContainer').style.display = 'none';
    document.getElementById('sub9DivContainer').style.display = 'block';
});

// Back button functionality for sub8DivContainer
function goBackToSub4FromSub8() {
    resetSub8();

    document.getElementById('sub8DivContainer').style.display = 'none';
    document.getElementById('sub4DivContainer').style.display = 'block';
}

// Back button functionality for sub9DivContainer
function goBackToSub4FromSub9() {
    resetSub9();

    document.getElementById('sub9DivContainer').style.display = 'none';
    document.getElementById('sub4DivContainer').style.display = 'block';
}





document.addEventListener("DOMContentLoaded", () => {
    fetch('dropdownpoints.json')
        .then(response => response.json())
        .then(data => populateDropdowns(data))
        .catch(error => console.error("Error loading dropdownpoints.json:", error));

        function populateDropdowns(data) {
    const sourceDropdown = document.getElementById('source');
    const destinationDropdown = document.getElementById('destination');

    data.forEach(item => {
        const optionSource = document.createElement('option');
        optionSource.value = item.point;
        optionSource.text = item.name;
        sourceDropdown.add(optionSource);

        const optionDestination = document.createElement('option');
        optionDestination.value = item.point;
        optionDestination.text = item.name;
        destinationDropdown.add(optionDestination);
    });
}

function showModeValidationModal() {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        z-index: 1000;
        text-align: center;
    `;
    
    modal.innerHTML = `
        <h3 style="margin-bottom: 15px; color: #dc3545;">Mode Required</h3>
        <p style="margin-bottom: 20px;">Please choose a mode before getting directions.</p>
        <button style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
            Cancel
        </button>
    `;
    
    document.body.appendChild(modal);
    
    // Handle close button
    const closeButton = modal.querySelector('button');
    closeButton.onclick = () => {
        document.body.removeChild(modal);
    };
}

// Function to check if a mode is selected
function isModeSelected(containerId) {
    const modeButtonSelectors = {
        'sub7DivContainer': '#modeButtons .mode-btn.active',
        'sub8DivContainer': '#modeButtonsSub8 .mode-btn.active',
        'sub9DivContainer': '#modeButtonsSub9 .mode-btn.active'
    };

    const selector = modeButtonSelectors[containerId];
    return document.querySelector(selector) !== null;
}

    document.getElementById("getDirectionsBtn").addEventListener("click", () => {
        if (!isModeSelected('sub7DivContainer')) {
        showModeValidationModal();
        return;
    }
        showLoadingOverlay();
        const sourceText = capitalizeWords(document.getElementById("sourceHeading").textContent.replace('Source: ', ''));
        const destinationText = capitalizeWords(document.getElementById("destinationHeading").textContent.replace('Destination: ', ''));

        selectDropdownOption("source", sourceText);
        selectDropdownOption("destination", destinationText);

        const selectedMode = document.querySelector("#modeButtons .active")?.id || "walkingMode";
        selectMode(selectedMode);
        
        document.getElementById("searchBtn1").click();
    });

    function capitalizeWords(text) {
        return text.replace(/\b\w/g, char => char.toUpperCase());
    }

    function selectDropdownOption(dropdownId, optionText) {
    const dropdown = document.getElementById(dropdownId);
    const optionFound = [...dropdown.options].some(option => {
        if (option.text === optionText) {
            option.selected = true;
            return true;
        }
        return false;
    });

    // Handle case where option is not found
    if (!optionFound) {
        console.warn(`Option "${optionText}" not found in dropdownpoints.json`);
        document.getElementById(dropdownId === 'source' ? 'sourceHeading' : 'destinationHeading').textContent = `Not Available`;
    }
}

    function selectMode(modeId) {
        const modeDropdown = document.getElementById("mode");
        const modeValue = { walkingMode: "walking", vehicleMode: "driving", disabledMode: "disabled" }[modeId];
        [...modeDropdown.options].forEach(option => {
            if (option.value === modeValue) option.selected = true;
        });
    }

    document.querySelectorAll("#modeButtons .mode-btn").forEach(button => {
        button.addEventListener("click", () => {
            document.querySelectorAll("#modeButtons .mode-btn").forEach(btn => btn.classList.remove("active"));
            button.classList.add("active");
        });
    });
});

function resetControls2() {
    // Reset the source, destination, and mode dropdowns
    document.getElementById('source').selectedIndex = 0; // Reset to "Select Source"
    document.getElementById('destination').selectedIndex = 0; // Reset to "Select Destination"
    document.getElementById('mode').selectedIndex = 0; // Reset to "Select Mode"

    // Clear result text and hide the path table
    document.getElementById('result').textContent = '';
    const pathTable = document.getElementById('pathTable');
    pathTable.style.display = 'none';

    // Clear the table rows
    const tbody = pathTable.querySelector('tbody');
    tbody.innerHTML = '';

    // Hide the directions display div
    document.getElementById('directionsDisplay').style.display = 'none';
    document.getElementById('directionsList').innerHTML = ''; // Clear directions list
}


function resetSub8() {
    // Reset source type and mode dropdowns
    document.getElementById('sourceType').selectedIndex = 0; // Reset to "Select Source Type"
    document.getElementById('coordMode').selectedIndex = 0; // Reset to "Select Mode"
    document.getElementById('coordDestination').selectedIndex = 0; // Reset to "Select Destination"
    document.getElementById('coordSource2').value = '';
    document.getElementById('coordSource4').value = '';
    document.getElementById('coordSource1').value = '';
    document.getElementById('coordSource').value = '';

    // Clear result text and hide the path table in controls3
    document.getElementById('coordResult').textContent = '';
    const coordPathTable = document.getElementById('coordPathTable');
    coordPathTable.style.display = 'none';

    // Clear the table rows
    const tbody = coordPathTable.querySelector('tbody');
    tbody.innerHTML = '';

    // Hide the directions display div
    document.getElementById('directionsDisplay').style.display = 'none';
    document.getElementById('directionsList').innerHTML = ''; // Clear directions list

    // Hide sub8DivContainer and show the previous div (e.g., controls3 or main container)
    document.getElementById('sub8DivContainer').style.display = 'none';
    document.getElementById('controls3').style.display = 'block';

    document.getElementById('directionsDisplay1').style.display = 'none';
    document.getElementById('directionsList1').innerHTML = ''; // Clear directions list
}

function resetSub9() {
    // Reset source type and mode dropdowns
    document.getElementById('sourceType').selectedIndex = 1; // Set to "Live Location" for sourceType
    document.getElementById('coordMode').selectedIndex = 0; // Reset to "Select Mode"
    document.getElementById('coordDestination').selectedIndex = 0; // Reset to "Select Destination"
    document.getElementById('coordSource2').value = '';
    document.getElementById('coordSource4').value = '';
    document.getElementById('coordSource1').value = '';
    document.getElementById('coordSource').value = '';

    // Clear result text and hide the path table in controls3
    document.getElementById('coordResult').textContent = '';
    const coordPathTable = document.getElementById('coordPathTable');
    coordPathTable.style.display = 'none';

    // Clear the table rows
    const tbody = coordPathTable.querySelector('tbody');
    tbody.innerHTML = '';

    // Hide the directions display div
    document.getElementById('directionsDisplay').style.display = 'none';
    document.getElementById('directionsList').innerHTML = ''; // Clear directions list

    // Hide sub9DivContainer and show the previous div (e.g., controls3 or main container)
    document.getElementById('sub9DivContainer').style.display = 'none';
    document.getElementById('controls3').style.display = 'block';

    document.getElementById('directionsDisplay2').style.display = 'none';
    document.getElementById('directionsList2').innerHTML = ''; // Clear directions list
}



document.addEventListener("DOMContentLoaded", () => {
    fetch('dropdownpoints.json')
        .then(response => response.json())
        .then(data => populateDropdowns(data))
        .catch(error => console.error("Error loading dropdownpoints.json:", error));

    function populateDropdowns(data) {
        const coordDestinationDropdown = document.getElementById('coordDestination');
        data.forEach(item => {
            const optionCoordDestination = document.createElement('option');
            optionCoordDestination.value = item.point;
            optionCoordDestination.text = item.name;
            coordDestinationDropdown.add(optionCoordDestination);
        });
    }

    function isModeSelected(containerId) {
    const modeButtonSelectors = {
        'sub7DivContainer': '#modeButtons .mode-btn.active',
        'sub8DivContainer': '#modeButtonsSub8 .mode-btn.active',
        'sub9DivContainer': '#modeButtonsSub9 .mode-btn.active'
    };

    const selector = modeButtonSelectors[containerId];
    const activeMode = document.querySelector(selector);
    console.log('Active mode found:', activeMode); // Debug log
    return activeMode !== null;
}

function showModeValidationModal() {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        z-index: 1000;
        text-align: center;
    `;
    
    modal.innerHTML = `
        <h3 style="margin-bottom: 15px; color: #dc3545;">Mode Required</h3>
        <p style="margin-bottom: 20px;">Please choose a mode before getting directions.</p>
        <button style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
            Cancel
        </button>
    `;
    
    document.body.appendChild(modal);
    
    // Handle close button
    const closeButton = modal.querySelector('button');
    closeButton.onclick = () => {
        document.body.removeChild(modal);
    };
}
    // Sub8 Get Directions functionality
    document.getElementById("getDirectionsBtnSub8").addEventListener("click", async () => {
        if (!isModeSelected('sub8DivContainer')) {
        showModeValidationModal();
        return;
    }
        showLoadingOverlay();
    document.getElementById("sourceType").value = "clickOnMap"; 
    const destinationText = capitalizeWords(
        document.getElementById("sub8DestinationHeading").textContent.trim().replace('Destination: ', '')
    );
    selectDropdownOption("coordDestination", destinationText);

    const selectedMode = document.querySelector("#modeButtonsSub8 .active")?.id || "walkingModeSub8";
    selectMode("coordMode", selectedMode);

    // Show directions display immediately
    document.getElementById("directionsDisplay1").style.display = "block";
    document.getElementById("directionsList1").innerHTML = ''; // Clear previous directions
    
    // Trigger search and force update
    await document.getElementById("coordSearchBtn").click();
});

document.getElementById("getDirectionsBtnSub9").addEventListener("click", async () => {
    showLoadingOverlay();
    document.getElementById("sourceType").value = "liveLoc";
    const destinationText = capitalizeWords(
        document.getElementById("sub9DestinationHeading").textContent.trim().replace('Destination: ', '')
    );
    selectDropdownOption("coordDestination", destinationText);

    const selectedMode = document.querySelector("#modeButtonsSub9 .active")?.id || "walkingModeSub9";
    selectMode("coordMode", selectedMode);

    // Show directions display immediately
    document.getElementById("directionsDisplay2").style.display = "block";
    document.getElementById("directionsList2").innerHTML = ''; // Clear previous directions
    
    // Trigger search and force update
    await document.getElementById("liveSearchBtn").click();
});

    function capitalizeWords(text) {
        return text.replace(/\b\w/g, char => char.toUpperCase());
    }

    function selectDropdownOption(dropdownId, optionText) {
        const dropdown = document.getElementById(dropdownId);
        let optionFound = false;

        [...dropdown.options].forEach(option => {
            if (option.text.trim().toLowerCase() === optionText.toLowerCase()) {
                option.selected = true;
                optionFound = true;
                console.log(`Found and selected option: ${option.text}`); 
            }
        });

        if (!optionFound) {
            console.warn(`Option "${optionText}" not found in dropdownpoints.json`);
            document.getElementById(dropdownId === 'coordDestination' ? 'sub9DestinationHeading' : 'sourceHeading').textContent = `Not Available`;
        }
    }

    function selectMode(modeDropdownId, modeId) {
        const modeDropdown = document.getElementById(modeDropdownId);
        const modeValue = { 
            walkingModeSub8: "walking", 
            vehicleModeSub8: "driving", 
            disabledModeSub8: "disabled",
            walkingModeSub9: "walking", 
            vehicleModeSub9: "driving", 
            disabledModeSub9: "disabled" 
        }[modeId];
        [...modeDropdown.options].forEach(option => {
            if (option.value === modeValue) option.selected = true;
        });
    }

    document.querySelectorAll("#modeButtonsSub8 .mode-btn, #modeButtonsSub9 .mode-btn").forEach(button => {
        button.addEventListener("click", () => {
            const parentDiv = button.parentElement;
            parentDiv.querySelectorAll(".mode-btn").forEach(btn => btn.classList.remove("active"));
            button.classList.add("active");
        });
    });
});


// Store all data globally for search
let allLocationsData = {};
let allCategories = [];
let originalCategoryDivs = [];
let subDivsData = {};
let currentCategory = ''; // Add currentCategory tracking

// Function to load all data needed for search
async function loadAllSearchData() {
    try {
        // Load all necessary data
        const [destResponse, locResponse, subDivsResponse] = await Promise.all([
            fetch('destination.json'),
            fetch('locations.json'),
            fetch('subdivs.json')
        ]);

        const destData = await destResponse.json();
        allCategories = destData.categories;
        allLocationsData = await locResponse.json();
        subDivsData = await subDivsResponse.json();
    } catch (error) {
        console.error('Error loading search data:', error);
    }
}

// Function to show no results message
function showNoResultsMessage(container) {
    const noResults = document.createElement('div');
    noResults.classList.add('location-category');
    noResults.textContent = 'No locations found';
    noResults.style.opacity = '0.7';
    noResults.style.cursor = 'default';
    container.appendChild(noR2esults);
}

// Function to check if a sub-location has details
function hasSubDivDetails(location) {
    return subDivsData.hasOwnProperty(location);
}

// Store original categories
function storeOriginalCategories() {
    const categoryContainer = document.getElementById('categoryContainer');
    originalCategoryDivs = Array.from(categoryContainer.getElementsByClassName('location-category'));
}

// Restore original categories without reloading
function restoreOriginalCategories() {
    const categoryContainer = document.getElementById('categoryContainer');
    if (categoryContainer) {
        categoryContainer.innerHTML = '';
        originalCategoryDivs.forEach(div => {
            const newDiv = div.cloneNode(true);
            newDiv.addEventListener('click', async (e) => {
                const category = e.target.id.charAt(0).toUpperCase() + e.target.id.slice(1);
                if (allLocationsData[category]) {
                    displaySubDivs(category, allLocationsData[category]);
                }
            });
            categoryContainer.appendChild(newDiv);
        });
    }
}

// Function to perform combined search
function performCombinedSearch(searchTerm) {
    searchTerm = searchTerm.toLowerCase();
    const categoryContainer = document.getElementById('categoryContainer');
    
    if (!categoryContainer) return;

    if (!searchTerm) {
        restoreOriginalCategories();
        return;
    }

    categoryContainer.innerHTML = '';

    const matchingCategories = allCategories.filter(category => 
        category.toLowerCase().includes(searchTerm)
    );

    let matchingSubLocations = [];
    Object.entries(allLocationsData).forEach(([category, locations]) => {
        locations.forEach(location => {
            if (location.toLowerCase().includes(searchTerm)) {
                matchingSubLocations.push({
                    category: category,
                    location: location
                });
            }
        });
    });

    // Show no results message if nothing found
    if (matchingCategories.length === 0 && matchingSubLocations.length === 0) {
        showNoResultsMessage(categoryContainer);
        return;
    }

    matchingCategories.forEach(category => {
        const div = document.createElement('div');
        div.classList.add('location-category');
        div.id = category.toLowerCase();
        div.textContent = category;
        
        div.addEventListener('click', () => {
            if (allLocationsData[category]) {
                displaySubDivs(category, allLocationsData[category]);
            }
        });
        
        categoryContainer.appendChild(div);
    });

    matchingSubLocations.forEach(match => {
        const div = document.createElement('div');
        div.classList.add('location-category');
        div.textContent = match.location;
        
        if (hasSubDivDetails(match.location)) {
            div.addEventListener('click', () => {
                displaySubDivs(match.category, allLocationsData[match.category]);
                displaySub3Details(match.location);
            });
        } else {
            div.style.cursor = 'default';
            div.style.opacity = '0.7';
            div.title = 'No detailed information available';
        }
        
        categoryContainer.appendChild(div);
    });
}

// Function to restore all sub-divs
function restoreAllSubDivs() {
    if (currentCategory && allLocationsData[currentCategory]) {
        const subDivContent = document.getElementById('subDivContent');
        const subSearchBar = document.getElementById('subSearchBar');
        
        // Clear search bar
        if (subSearchBar) {
            subSearchBar.value = '';
        }

        // Clear and repopulate content
        subDivContent.innerHTML = '';
        allLocationsData[currentCategory].forEach(subDiv => {
            const div = document.createElement('div');
            div.classList.add('location-category');
            div.textContent = subDiv;
            
            if (hasSubDivDetails(subDiv)) {
                div.addEventListener('click', () => {
                    displaySub3Details(subDiv);
                });
            } else {
                div.style.cursor = 'default';
                div.style.opacity = '0.7';
                div.title = 'No detailed information available';
            }
            
            subDivContent.appendChild(div);
        });
    }
}

// Function to display sub-divs
function displaySubDivs(category, subDivs) {
    const subDivContainer = document.getElementById('subDivContainer');
    const subDivContent = document.getElementById('subDivContent');
    const subDivHeading = document.getElementById('subDivHeading');
    const controlspart2 = document.getElementById('controlspart2');

    // Store current category
    currentCategory = category;

    subDivHeading.textContent = category;
    subDivContent.innerHTML = '';

    subDivs.forEach(subDiv => {
        const div = document.createElement('div');
        div.classList.add('location-category');
        div.textContent = subDiv;
        
        if (hasSubDivDetails(subDiv)) {
            div.addEventListener('click', () => {
                displaySub3Details(subDiv);
            });
        } else {
            div.style.cursor = 'default';
            div.style.opacity = '0.7';
            div.title = 'No detailed information available';
        }
        
        subDivContent.appendChild(div);
    });

    controlspart2.style.display = 'none';
    subDivContainer.style.display = 'block';

    // Clear search bars
    document.getElementById('searchBar').value = '';
    document.getElementById('subSearchBar').value = '';
}

// Initialize search functionality
document.addEventListener('DOMContentLoaded', async () => {
    await loadAllSearchData();
    setTimeout(storeOriginalCategories, 100);

    // Main search bar setup
    const searchBar = document.getElementById('searchBar');
    const newSearchBar = searchBar.cloneNode(true);
    searchBar.parentNode.replaceChild(newSearchBar, searchBar);
    newSearchBar.addEventListener('input', (e) => {
        performCombinedSearch(e.target.value.trim());
    });

    // Sub-location search bar setup
    const subSearchBar = document.getElementById('subSearchBar');
    if (subSearchBar) {
        const newSubSearchBar = subSearchBar.cloneNode(true);
        subSearchBar.parentNode.replaceChild(newSubSearchBar, subSearchBar);

        newSubSearchBar.addEventListener('input', (e) => {
            const searchTerm = e.target.value.trim().toLowerCase();
            const subDivContent = document.getElementById('subDivContent');
            
            if (!searchTerm) {
                restoreAllSubDivs();
                return;
            }

            subDivContent.innerHTML = '';
            if (allLocationsData[currentCategory]) {
                const matchingLocations = allLocationsData[currentCategory].filter(location =>
                    location.toLowerCase().includes(searchTerm)
                );

                if (matchingLocations.length === 0) {
                    showNoResultsMessage(subDivContent);
                    return;
                }

                matchingLocations.forEach(location => {
                    const div = document.createElement('div');
                    div.classList.add('location-category');
                    div.textContent = location;
                    
                    if (hasSubDivDetails(location)) {
                        div.addEventListener('click', () => {
                            displaySub3Details(location);
                        });
                    } else {
                        div.style.cursor = 'default';
                        div.style.opacity = '0.7';
                        div.title = 'No detailed information available';
                    }
                    
                    subDivContent.appendChild(div);
                });
            }
        });
    }

    // Add event listener for sub3 back button
    const backButtonSub3 = document.getElementById('backButtonSub3');
    if (backButtonSub3) {
        backButtonSub3.onclick = function() {
            document.getElementById('sub3DivContainer').style.display = 'none';
            document.getElementById('subDivContainer').style.display = 'block';
            restoreAllSubDivs(); // Restore all sub-divs when going back
        };
    }

    // Back button functionality
    window.goBack = function() {
        const subDivContainer = document.getElementById('subDivContainer');
        const controlspart2 = document.getElementById('controlspart2');
        const searchBar = document.getElementById('searchBar');
        const subSearchBar = document.getElementById('subSearchBar');

        if (subDivContainer) subDivContainer.style.display = 'none';
        if (controlspart2) controlspart2.style.display = 'block';
        if (searchBar) searchBar.value = '';
        if (subSearchBar) subSearchBar.value = '';
        
        currentCategory = ''; // Clear current category
        restoreOriginalCategories();
    };
});

// Additional CSS for styling







// Add these event listeners in your main DOMContentLoaded event:

// Sub5 search bar setup (Combined search)
const sub5SearchBar = document.getElementById('sub5SearchBar');
if (sub5SearchBar) {
    const newSub5SearchBar = sub5SearchBar.cloneNode(true);
    sub5SearchBar.parentNode.replaceChild(newSub5SearchBar, sub5SearchBar);

    newSub5SearchBar.addEventListener('input', (e) => {
        const searchTerm = e.target.value.trim().toLowerCase();
        const sub5Content = document.getElementById('sub5Content');
        
        if (!searchTerm) {
            if (allCategories) {
                displaySub5Content();
            }
            return;
        }

        sub5Content.innerHTML = '';

        // Search in categories
        const matchingCategories = allCategories.filter(category => 
            category.toLowerCase().includes(searchTerm)
        );

        // Search in all sub-locations
        let matchingSubLocations = [];
        Object.entries(allLocationsData).forEach(([category, locations]) => {
            locations.forEach(location => {
                if (location.toLowerCase().includes(searchTerm)) {
                    matchingSubLocations.push({
                        category: category,
                        location: location
                    });
                }
            });
        });

        // Show no results message if nothing found
        if (matchingCategories.length === 0 && matchingSubLocations.length === 0) {
            const noResults = document.createElement('div');
            noResults.classList.add('location-category');
            noResults.textContent = 'No locations found';
            sub5Content.appendChild(noResults);
            return;
        }

        // Display matching categories
        matchingCategories.forEach(category => {
            const div = document.createElement('div');
            div.classList.add('location-category');
            div.textContent = category;
            
            div.addEventListener('click', () => {
                displaySub6Content(category);
            });
            
            sub5Content.appendChild(div);
        });

        // Display matching sub-locations
        matchingSubLocations.forEach(match => {
            const div = document.createElement('div');
            div.classList.add('location-category');
            div.textContent = match.location;
            
            if (hasSubDivDetails(match.location)) {
                div.addEventListener('click', () => {
                    displaySub6Content(match.category);
                    // Change to open sub7 instead of sub3
                    openSub7(match.location, document.getElementById('sub4DestinationHeading').textContent);
                });
            } else {
                div.title = 'No detailed information available';
            }
            
            sub5Content.appendChild(div);
        });
    });
}

// Sub6 search bar setup (Single category search)
const sub6SearchBar = document.getElementById('sub6SearchBar');
if (sub6SearchBar) {
    const newSub6SearchBar = sub6SearchBar.cloneNode(true);
    sub6SearchBar.parentNode.replaceChild(newSub6SearchBar, sub6SearchBar);

    newSub6SearchBar.addEventListener('input', (e) => {
        const searchTerm = e.target.value.trim().toLowerCase();
        const sub6Content = document.getElementById('sub6Content');
        const currentCategory = document.getElementById('sub6Heading').textContent;
        
        if (!searchTerm) {
            if (allLocationsData[currentCategory]) {
                displaySub6Content(currentCategory);
            }
            return;
        }

        sub6Content.innerHTML = '';

        if (allLocationsData[currentCategory]) {
            const matchingLocations = allLocationsData[currentCategory].filter(location =>
                location.toLowerCase().includes(searchTerm)
            );

            if (matchingLocations.length === 0) {
                const noResults = document.createElement('div');
                noResults.classList.add('location-category');
                noResults.textContent = 'No locations found';
                sub6Content.appendChild(noResults);
                return;
            }

            matchingLocations.forEach(location => {
                const div = document.createElement('div');
                div.classList.add('location-category');
                div.textContent = location;
                
                if (hasSubDivDetails(location)) {
                    div.addEventListener('click', () => {
                        // Get destination from sub4
                        const destination = document.getElementById('sub4DestinationHeading').textContent;
                        openSub7(location, destination);
                    });
                } else {
                    div.title = 'No detailed information available';
                }
                
                sub6Content.appendChild(div);
            });
        }
    });
}

async function displaySub5Content() {
    const sub5Content = document.getElementById('sub5Content');
    sub5Content.innerHTML = '';

    allCategories.forEach(category => {
        const div = document.createElement('div');
        div.classList.add('location-category');
        div.textContent = category;
        
        div.addEventListener('click', () => {
            displaySub6Content(category);
        });
        
        sub5Content.appendChild(div);
    });

    // Clear search bar
    document.getElementById('sub5SearchBar').value = '';
}

function displaySub6Content(category) {
    const sub6Container = document.getElementById('sub6DivContainer');
    const sub6Content = document.getElementById('sub6Content');
    const sub6Heading = document.getElementById('sub6Heading');
    const sub5Container = document.getElementById('sub5DivContainer');

    sub6Heading.textContent = category;
    sub6Content.innerHTML = '';

    if (allLocationsData[category]) {
        allLocationsData[category].forEach(location => {
            const div = document.createElement('div');
            div.classList.add('location-category');
            div.textContent = location;
            
            if (hasSubDivDetails(location)) {
                div.addEventListener('click', () => {
                    // Get destination from sub4
                    const destination = document.getElementById('sub4DestinationHeading').textContent;
                    openSub7(location, destination);
                });
            } else {
                div.title = 'No detailed information available';
            }
            
            sub6Content.appendChild(div);
        });
    }

    // Update display
    sub5Container.style.display = 'none';
    sub6Container.style.display = 'block';

    // Clear search bars
    document.getElementById('sub5SearchBar').value = '';
    document.getElementById('sub6SearchBar').value = '';
}

// Function to open sub7 with source and destination
function openSub7(source, destination) {
    const sub7Container = document.getElementById('sub7DivContainer');
    const sub6Container = document.getElementById('sub6DivContainer');
    const sourceHeading = document.getElementById('sourceHeading');
    const destinationHeading = document.getElementById('destinationHeading');

    // Clean up the destination text (remove "Destination: " if present)
    const cleanDestination = destination.replace('Destination: ', '');

    // Set the headings
    sourceHeading.textContent = `Source: ${source}`;
    destinationHeading.textContent = `Destination: ${cleanDestination}`;

    // Update display
    sub6Container.style.display = 'none';
    sub7Container.style.display = 'block';
}

// Add these to your existing back button functions
function goBackToSub5() {
    document.getElementById('sub6DivContainer').style.display = 'none';
    document.getElementById('sub5DivContainer').style.display = 'block';
    document.getElementById('sub6SearchBar').value = '';
}

function goBackToSub6() {
    document.getElementById('sub7DivContainer').style.display = 'none';
    document.getElementById('sub6DivContainer').style.display = 'block';
}




function openSub3DivContainer() {
    const container = document.getElementById('sub3DivContainer');
    container.scrollTop = 0; // Reset scroll position to the top
    container.style.display = 'block'; // Show the container
}

function closeSub3DivContainer() {
    document.getElementById('sub3DivContainer').style.display = 'none'; // Hide the container
}

document.addEventListener('DOMContentLoaded', function() {
    if (window.innerWidth > 768) return;

    const controls = document.getElementById('controls');
    const categoryContainer = document.getElementById('categoryContainer');
    const subDivContainer = document.getElementById('subDivContainer');
    const subDivContent = document.getElementById('subDivContent');
    const sub3DivContainer = document.getElementById('sub3DivContainer');
    const sub3Content = document.querySelector('.sub3-content');
    
    let startY = 0;
    let startHeight = 0;
    let isExpanded = false;
    let isDragging = false;
    let lastScrollTop = 0;

    function isAtTop(element) {
        return Math.abs(element.scrollTop) < 1;
    }

    function initializePanelHandlers(container, scrollableContent) {
        container.addEventListener('touchstart', (e) => {
            if (container.style.display !== 'none') {
                startY = e.touches[0].clientY;
                startHeight = controls.offsetHeight;
                isDragging = true;
                lastScrollTop = scrollableContent.scrollTop;
            }
        });

        container.addEventListener('touchmove', (e) => {
            if (!isDragging || container.style.display === 'none') return;

            if (isExpanded && !isAtTop(scrollableContent)) {
                isDragging = false;
                return;
            }

            const deltaY = e.touches[0].clientY - startY;
            const newHeight = startHeight - deltaY;
            const minHeight = window.innerHeight * 0.4;
            const maxHeight = window.innerHeight * 0.7;

            if (newHeight >= minHeight && newHeight <= maxHeight) {
                controls.style.height = `${newHeight}px`;
                e.preventDefault();
            }
        });

        container.addEventListener('touchend', () => {
            if (!isDragging || container.style.display === 'none') return;
            isDragging = false;

            const currentHeight = controls.offsetHeight;
            const threshold = window.innerHeight * 0.55;

            if (currentHeight > threshold) {
                expandPanel();
            } else {
                collapsePanel();
            }
        });

        container.addEventListener('wheel', (e) => {
            if (container.style.display === 'none') return;

            if (!isExpanded && e.deltaY > 0) {
                expandPanel();
                e.preventDefault();
                return;
            }

            if (isExpanded && isAtTop(scrollableContent) && e.deltaY < 0) {
                collapsePanel();
                e.preventDefault();
                return;
            }

            if (!isExpanded) {
                e.preventDefault();
            }

            lastScrollTop = scrollableContent.scrollTop;
        });

        scrollableContent.addEventListener('scroll', () => {
            lastScrollTop = scrollableContent.scrollTop;
        });

        scrollableContent.addEventListener('touchmove', (e) => {
            if (!isExpanded) {
                e.preventDefault();
            }
        }, { passive: false });
    }

    function expandPanel() {
        controls.style.height = '70vh';
        controls.classList.add('expanded');
        isExpanded = true;

        if (categoryContainer) categoryContainer.style.overflowY = 'auto';
        if (subDivContainer && subDivContainer.style.display !== 'none') {
            subDivContent.style.overflowY = 'auto';
        }
        if (sub3DivContainer && sub3DivContainer.style.display !== 'none') {
            sub3Content.style.overflowY = 'auto';
        }
    }

    function collapsePanel() {
        if (isExpanded) {
            const activeContent = sub3DivContainer.style.display !== 'none' ? sub3Content :
                                subDivContainer.style.display !== 'none' ? subDivContent :
                                categoryContainer;
            
            if (isAtTop(activeContent)) {
                controls.style.height = '40vh';
                controls.classList.remove('expanded');
                isExpanded = false;

                if (categoryContainer) categoryContainer.style.overflowY = 'hidden';
                if (subDivContent) subDivContent.style.overflowY = 'hidden';
                if (sub3Content) sub3Content.style.overflowY = 'hidden';
            }
        }
    }

    initializePanelHandlers(document.getElementById('controlspart2'), categoryContainer);
    initializePanelHandlers(subDivContainer, subDivContent);
});
document.addEventListener('DOMContentLoaded', function() {
    if (window.innerWidth > 768) return;

    const controlsSub3 = document.getElementById('controls');
    const sub3DivContainer = document.getElementById('sub3DivContainer');
    const scrollTriggerSub3 = document.getElementById('scrollTrigger');
    const sub3Content = document.querySelector('.sub3-content');

    let startYSub3 = 0;
    let startHeightSub3 = 0;
    let isExpandedSub3 = false;
    let isDraggingSub3 = false;
    let touchStartTimeSub3 = 0;
    let initialTouchYSub3 = 0;
    let wheelDelayTimeoutSub3 = null;

    function isAtTriggerSub3() {
        return sub3DivContainer.scrollTop <= scrollTriggerSub3.offsetTop;
    }

    function expandPanelSub3() {
        controlsSub3.style.height = '70vh';
        controlsSub3.classList.add('expanded');
        isExpandedSub3 = true;
        sub3DivContainer.style.overflowY = 'auto';
    }

    function collapsePanelSub3() {
        if (isExpandedSub3 && isAtTriggerSub3()) {
            controlsSub3.style.height = '40vh';
            controlsSub3.classList.remove('expanded');
            isExpandedSub3 = false;
            sub3DivContainer.style.overflowY = 'hidden';
        }
    }

    function initializeSub3PanelHandlers() {
        sub3DivContainer.addEventListener('touchstart', (e) => {
            if (sub3DivContainer.style.display !== 'none') {
                startYSub3 = e.touches[0].clientY;
                initialTouchYSub3 = startYSub3;
                startHeightSub3 = controlsSub3.offsetHeight;
                touchStartTimeSub3 = Date.now();
                isDraggingSub3 = true;
            }
        });

        sub3DivContainer.addEventListener('touchmove', (e) => {
            if (!isDraggingSub3 || sub3DivContainer.style.display === 'none') return;

            const currentY = e.touches[0].clientY;
            const deltaY = currentY - startYSub3;
            const newHeight = startHeightSub3 - deltaY;
            const minHeight = window.innerHeight * 0.4;
            const maxHeight = window.innerHeight * 0.7;

            if (isExpandedSub3 && deltaY > 0 && !isAtTriggerSub3()) return;

            if (newHeight >= minHeight && newHeight <= maxHeight) {
                controlsSub3.style.height = `${newHeight}px`;
                e.preventDefault();
            }
        });

        sub3DivContainer.addEventListener('touchend', (e) => {
            if (!isDraggingSub3 || sub3DivContainer.style.display === 'none') return;

            const currentHeight = controlsSub3.offsetHeight;
            const threshold = window.innerHeight * 0.55;

            if (currentHeight > threshold) {
                expandPanelSub3();
            } else if (isAtTriggerSub3()) {
                collapsePanelSub3();
            }

            isDraggingSub3 = false;
        });

        sub3DivContainer.addEventListener('wheel', (e) => {
            if (sub3DivContainer.style.display === 'none') return;

            if (!isExpandedSub3 && e.deltaY > 0) {
                expandPanelSub3();
                e.preventDefault();
                return;
            }

            if (isExpandedSub3 && isAtTriggerSub3() && e.deltaY < 0) {
                if (wheelDelayTimeoutSub3) clearTimeout(wheelDelayTimeoutSub3);
                wheelDelayTimeoutSub3 = setTimeout(() => {
                    if (isAtTriggerSub3()) collapsePanelSub3();
                }, 150);
                e.preventDefault();
            } else if (!isExpandedSub3) {
                e.preventDefault();
            }
        });
    }

    initializeSub3PanelHandlers();
});
document.addEventListener('DOMContentLoaded', function() {
    if (window.innerWidth > 768) return;

    const controlsSub4 = document.getElementById('controls'); // Assuming 'controls' is used for height adjustments
    const sub4DivContainer = document.getElementById('sub4DivContainer');

    let startYSub4 = 0;
    let startHeightSub4 = 0;
    let isExpandedSub4 = false;
    let isDraggingSub4 = false;
    let initialTouchYSub4 = 0;
    let touchStartTimeSub4 = 0;

    function expandPanelSub4() {
        controlsSub4.style.height = '70vh';
        controlsSub4.classList.add('expanded');
        isExpandedSub4 = true;
        sub4DivContainer.style.overflowY = 'auto';
    }

    function collapsePanelSub4() {
        controlsSub4.style.height = '40vh';
        controlsSub4.classList.remove('expanded');
        isExpandedSub4 = false;
        sub4DivContainer.style.overflowY = 'hidden';
    }

    function initializeSub4PanelHandlers() {
        sub4DivContainer.addEventListener('touchstart', (e) => {
            if (sub4DivContainer.style.display !== 'none') {
                startYSub4 = e.touches[0].clientY;
                initialTouchYSub4 = startYSub4;
                startHeightSub4 = controlsSub4.offsetHeight;
                touchStartTimeSub4 = Date.now();
                isDraggingSub4 = true;
            }
        });

        sub4DivContainer.addEventListener('touchmove', (e) => {
            if (!isDraggingSub4 || sub4DivContainer.style.display === 'none') return;

            const currentY = e.touches[0].clientY;
            const deltaY = currentY - startYSub4;
            const newHeight = startHeightSub4 - deltaY;
            const minHeight = window.innerHeight * 0.4;
            const maxHeight = window.innerHeight * 0.7;

            if (newHeight >= minHeight && newHeight <= maxHeight) {
                // Adjust the panel height based on the touch movement
                controlsSub4.style.height = `${newHeight}px`;
                e.preventDefault();
            }
        });

        sub4DivContainer.addEventListener('touchend', (e) => {
            if (!isDraggingSub4 || sub4DivContainer.style.display === 'none') return;

            const currentHeight = controlsSub4.offsetHeight;
            const threshold = window.innerHeight * 0.55;

            // Determine if the panel should expand or collapse based on the final height
            if (currentHeight > threshold) {
                expandPanelSub4();
            } else {
                collapsePanelSub4();
            }

            isDraggingSub4 = false;
        });

        // Allow expanding or collapsing with the mouse wheel
        sub4DivContainer.addEventListener('wheel', (e) => {
            if (sub4DivContainer.style.display === 'none') return;

            if (!isExpandedSub4 && e.deltaY > 0) {
                expandPanelSub4();
                e.preventDefault();
                return;
            }

            if (isExpandedSub4 && e.deltaY < 0) {
                collapsePanelSub4();
                e.preventDefault();
            } else if (!isExpandedSub4) {
                e.preventDefault();
            }
        });
    }

    initializeSub4PanelHandlers();
});

document.addEventListener('DOMContentLoaded', function() {
    if (window.innerWidth > 768) return;

    const controls = document.getElementById('controls');
    const sub5DivContainer = document.getElementById('sub5DivContainer');
    const sub5Content = document.getElementById('sub5Content');
    const sub6DivContainer = document.getElementById('sub6DivContainer');
    const sub6Content = document.getElementById('sub6Content');
    
    let startY = 0;
    let startHeight = 0;
    let isExpanded = false;
    let isDragging = false;
    let lastScrollTop = 0;

    // Create and setup fixed header containers
    function setupFixedHeaders() {
        // Setup for Sub5
        const sub5HeaderContainer = document.createElement('div');
        sub5HeaderContainer.className = 'fixed-header-container';
        sub5HeaderContainer.style.position = 'sticky';
        sub5HeaderContainer.style.top = '0';
        sub5HeaderContainer.style.left = '0';
        sub5HeaderContainer.style.right = '0';
        sub5HeaderContainer.style.zIndex = '1001';
        sub5HeaderContainer.style.backgroundColor = '#000';
        sub5HeaderContainer.style.height = '120px';

        // Move Sub5 header elements
        const sub5BackButton = document.getElementById('backButtonSub5');
        const sub5Heading = document.getElementById('sub5Heading');
        const sub5SearchContainer = document.querySelector('#sub5DivContainer #subSearchContainer');

        sub5HeaderContainer.appendChild(sub5BackButton);
        sub5HeaderContainer.appendChild(sub5Heading);
        sub5HeaderContainer.appendChild(sub5SearchContainer);

        sub5DivContainer.insertBefore(sub5HeaderContainer, sub5DivContainer.firstChild);

        // Style Sub5 header elements
        sub5BackButton.style.position = 'absolute';
        sub5BackButton.style.top = '10px';
        sub5BackButton.style.right = '10px';
        sub5BackButton.style.zIndex = '1002';

        sub5Heading.style.position = 'absolute';
        sub5Heading.style.top = '40px';
        sub5Heading.style.width = '100%';
        sub5Heading.style.zIndex = '1002';

        sub5SearchContainer.style.position = 'absolute';
        sub5SearchContainer.style.top = '80px';
        sub5SearchContainer.style.width = '100%';
        sub5SearchContainer.style.zIndex = '1002';

        // Setup for Sub6
        const sub6HeaderContainer = document.createElement('div');
        sub6HeaderContainer.className = 'fixed-header-container';
        sub6HeaderContainer.style.cssText = sub5HeaderContainer.style.cssText;

        const sub6BackButton = document.getElementById('backButtonSub6');
        const sub6Heading = document.getElementById('sub6Heading');
        const sub6SearchContainer = document.querySelector('#sub6DivContainer #subSearchContainer');

        sub6HeaderContainer.appendChild(sub6BackButton);
        sub6HeaderContainer.appendChild(sub6Heading);
        sub6HeaderContainer.appendChild(sub6SearchContainer);

        sub6DivContainer.insertBefore(sub6HeaderContainer, sub6DivContainer.firstChild);

        sub6BackButton.style.cssText = sub5BackButton.style.cssText;
        sub6Heading.style.cssText = sub5Heading.style.cssText;
        sub6SearchContainer.style.cssText = sub5SearchContainer.style.cssText;
    }

    setupFixedHeaders();

    function isAtTop(element) {
        return Math.abs(element.scrollTop) < 1;
    }

    function initializeSub5PanelHandlers() {
        sub5Content.style.marginTop = '120px';
        sub5Content.style.height = 'calc(40vh - 120px)';
        sub5Content.style.overflowY = 'hidden';

        sub5DivContainer.addEventListener('touchstart', (e) => {
            if (sub5DivContainer.style.display !== 'none') {
                startY = e.touches[0].clientY;
                startHeight = controls.offsetHeight;
                isDragging = true;
                lastScrollTop = sub5Content.scrollTop;
            }
        });

        sub5DivContainer.addEventListener('touchmove', (e) => {
            if (!isDragging || sub5DivContainer.style.display === 'none') return;

            if (isExpanded && !isAtTop(sub5Content)) {
                isDragging = false;
                return;
            }

            const deltaY = e.touches[0].clientY - startY;
            const newHeight = startHeight - deltaY;
            const minHeight = window.innerHeight * 0.4;
            const maxHeight = window.innerHeight * 0.7;

            if (newHeight >= minHeight && newHeight <= maxHeight) {
                controls.style.height = `${newHeight}px`;
                if (!isExpanded) {
                    e.preventDefault();
                }
            }
        });

        sub5DivContainer.addEventListener('touchend', () => {
            if (!isDragging || sub5DivContainer.style.display === 'none') return;
            isDragging = false;

            const currentHeight = controls.offsetHeight;
            const threshold = window.innerHeight * 0.55;

            if (currentHeight > threshold) {
                expandSub5Panel();
            } else {
                collapseSub5Panel();
            }
        });

        sub5Content.addEventListener('scroll', () => {
            lastScrollTop = sub5Content.scrollTop;
        });

        sub5Content.addEventListener('touchmove', (e) => {
            if (isExpanded) {
                e.stopPropagation();
            } else {
                e.preventDefault();
            }
        }, { passive: false });

        sub5DivContainer.addEventListener('wheel', (e) => {
            if (sub5DivContainer.style.display === 'none') return;

            if (!isExpanded && e.deltaY > 0) {
                expandSub5Panel();
                e.preventDefault();
                return;
            }

            if (isExpanded && isAtTop(sub5Content) && e.deltaY < 0) {
                collapseSub5Panel();
                e.preventDefault();
                return;
            }

            if (!isExpanded) {
                e.preventDefault();
            }
        });
    }

    function expandSub5Panel() {
        controls.style.height = '70vh';
        controls.classList.add('expanded');
        isExpanded = true;
        sub5Content.style.overflowY = 'auto';
        sub5Content.style.height = 'calc(70vh - 120px)';
    }

    function collapseSub5Panel() {
        if (isExpanded && isAtTop(sub5Content)) {
            controls.style.height = '40vh';
            controls.classList.remove('expanded');
            isExpanded = false;
            sub5Content.style.overflowY = 'hidden';
            sub5Content.style.height = 'calc(40vh - 120px)';
        }
    }

    function initializeSub6PanelHandlers() {
        sub6Content.style.marginTop = '120px';
        sub6Content.style.height = 'calc(40vh - 120px)';
        sub6Content.style.overflowY = 'hidden';

        sub6DivContainer.addEventListener('touchstart', (e) => {
            if (sub6DivContainer.style.display !== 'none') {
                startY = e.touches[0].clientY;
                startHeight = controls.offsetHeight;
                isDragging = true;
                lastScrollTop = sub6Content.scrollTop;
            }
        });

        sub6DivContainer.addEventListener('touchmove', (e) => {
            if (!isDragging || sub6DivContainer.style.display === 'none') return;

            if (isExpanded && !isAtTop(sub6Content)) {
                isDragging = false;
                return;
            }

            const deltaY = e.touches[0].clientY - startY;
            const newHeight = startHeight - deltaY;
            const minHeight = window.innerHeight * 0.4;
            const maxHeight = window.innerHeight * 0.7;

            if (newHeight >= minHeight && newHeight <= maxHeight) {
                controls.style.height = `${newHeight}px`;
                if (!isExpanded) {
                    e.preventDefault();
                }
            }
        });

        sub6DivContainer.addEventListener('touchend', () => {
            if (!isDragging || sub6DivContainer.style.display === 'none') return;
            isDragging = false;

            const currentHeight = controls.offsetHeight;
            const threshold = window.innerHeight * 0.55;

            if (currentHeight > threshold) {
                expandSub6Panel();
            } else {
                collapseSub6Panel();
            }
        });

        sub6Content.addEventListener('scroll', () => {
            lastScrollTop = sub6Content.scrollTop;
        });

        sub6Content.addEventListener('touchmove', (e) => {
            if (isExpanded) {
                e.stopPropagation();
            } else {
                e.preventDefault();
            }
        }, { passive: false });

        sub6DivContainer.addEventListener('wheel', (e) => {
            if (sub6DivContainer.style.display === 'none') return;

            if (!isExpanded && e.deltaY > 0) {
                expandSub6Panel();
                e.preventDefault();
                return;
            }

            if (isExpanded && isAtTop(sub6Content) && e.deltaY < 0) {
                collapseSub6Panel();
                e.preventDefault();
                return;
            }

            if (!isExpanded) {
                e.preventDefault();
            }
        });
    }

    function expandSub6Panel() {
        controls.style.height = '70vh';
        controls.classList.add('expanded');
        isExpanded = true;
        sub6Content.style.overflowY = 'auto';
        sub6Content.style.height = 'calc(70vh - 120px)';
    }

    function collapseSub6Panel() {
        if (isExpanded && isAtTop(sub6Content)) {
            controls.style.height = '40vh';
            controls.classList.remove('expanded');
            isExpanded = false;
            sub6Content.style.overflowY = 'hidden';
            sub6Content.style.height = 'calc(40vh - 120px)';
        }
    }

    function resetPanelState() {
        isExpanded = false;
        isDragging = false;
        controls.style.height = '40vh';
        controls.classList.remove('expanded');
    }

    document.getElementById('backButtonSub5').addEventListener('click', resetPanelState);
    document.getElementById('backButtonSub6').addEventListener('click', resetPanelState);

    initializeSub5PanelHandlers();
    initializeSub6PanelHandlers();
});

document.addEventListener('DOMContentLoaded', function() {
    if (window.innerWidth > 768) return;

    const controls = document.getElementById('controls');
    const sub7DivContainer = document.getElementById('sub7DivContainer');
    const sub8DivContainer = document.getElementById('sub8DivContainer');
    const sub9DivContainer = document.getElementById('sub9DivContainer');

    // Get scrollable content elements
    const sub7Content = sub7DivContainer.querySelector('.scrollable-content');
    const sub8Content = sub8DivContainer.querySelector('.scrollable-content');
    const sub9Content = sub9DivContainer.querySelector('.scrollable-content');

    // Shared state variables
    let startY = 0;
    let startHeight = 0;
    let isExpanded = false;
    let isDragging = false;
    let lastScrollTop = 0;

    function isAtTop(element) {
        return Math.abs(element.scrollTop) < 1;
    }

    // Generic panel handler initialization
    function initializePanelHandlers(container, scrollableContent) {
        // Reset initial styles
        scrollableContent.style.overflowY = 'auto';
        scrollableContent.style.height = 'calc(100% - 200px)'; // Adjusted for header heights

        container.addEventListener('touchstart', (e) => {
            if (container.style.display !== 'none') {
                startY = e.touches[0].clientY;
                startHeight = controls.offsetHeight;
                isDragging = true;
                lastScrollTop = scrollableContent.scrollTop;
            }
        });

        container.addEventListener('touchmove', (e) => {
            if (!isDragging || container.style.display === 'none') return;

            if (isExpanded && !isAtTop(scrollableContent)) {
                isDragging = false;
                return;
            }

            const deltaY = e.touches[0].clientY - startY;
            const newHeight = startHeight - deltaY;
            const minHeight = window.innerHeight * 0.4;
            const maxHeight = window.innerHeight * 0.7;

            if (newHeight >= minHeight && newHeight <= maxHeight) {
                controls.style.height = `${newHeight}px`;
                if (!isExpanded) {
                    e.preventDefault();
                }
            }
        });

        container.addEventListener('touchend', () => {
            if (!isDragging || container.style.display === 'none') return;
            isDragging = false;

            const currentHeight = controls.offsetHeight;
            const threshold = window.innerHeight * 0.55;

            if (currentHeight > threshold) {
                expandPanel(container, scrollableContent);
            } else {
                collapsePanel(container, scrollableContent);
            }
        });

        // Enable smooth scrolling
        scrollableContent.addEventListener('scroll', () => {
            lastScrollTop = scrollableContent.scrollTop;
        });

        // Handle touch events on scrollable content
        scrollableContent.addEventListener('touchmove', (e) => {
            if (isExpanded) {
                e.stopPropagation();
            } else {
                e.preventDefault();
            }
        }, { passive: false });

        // Mouse wheel handling
        container.addEventListener('wheel', (e) => {
            if (container.style.display === 'none') return;

            if (!isExpanded && e.deltaY > 0) {
                expandPanel(container, scrollableContent);
                e.preventDefault();
                return;
            }

            if (isExpanded && isAtTop(scrollableContent) && e.deltaY < 0) {
                collapsePanel(container, scrollableContent);
                e.preventDefault();
                return;
            }

            if (!isExpanded) {
                e.preventDefault();
            }
        });
    }

    function expandPanel(container, scrollableContent) {
        controls.style.height = '70vh';
        controls.classList.add('expanded');
        isExpanded = true;
        scrollableContent.style.overflowY = 'auto';

        // Calculate content height considering headers
        const headerBackground = container.querySelector('.header-background1');
        const headerHeight = headerBackground ? headerBackground.offsetHeight : 200;
        scrollableContent.style.height = `calc(70vh - ${headerHeight}px)`;

        // Show directions display if it exists
        const directionsDisplay = container.querySelector('[id^="directionsDisplay"]');
        if (directionsDisplay) {
            directionsDisplay.style.display = 'block';
        }
    }

    function collapsePanel(container, scrollableContent) {
        if (isExpanded && isAtTop(scrollableContent)) {
            controls.style.height = '40vh';
            controls.classList.remove('expanded');
            isExpanded = false;

            // Calculate content height considering headers
            const headerBackground = container.querySelector('.header-background1');
            const headerHeight = headerBackground ? headerBackground.offsetHeight : 200;
            scrollableContent.style.height = `calc(40vh - ${headerHeight}px)`;
        }
    }

    // Reset panel state when switching between containers
    function resetPanelState() {
        isExpanded = false;
        isDragging = false;
        controls.style.height = '40vh';
        controls.classList.remove('expanded');
    }

    // Add reset handlers for back buttons
    document.getElementById('backButtonSub7').addEventListener('click', resetPanelState);
    document.getElementById('backButtonSub8').addEventListener('click', resetPanelState);
    document.getElementById('backButtonSub9').addEventListener('click', resetPanelState);

    // Initialize handlers for all containers
    initializePanelHandlers(sub7DivContainer, sub7Content);
    initializePanelHandlers(sub8DivContainer, sub8Content);
    initializePanelHandlers(sub9DivContainer, sub9Content);

    // Additional event listeners for mode buttons
    function initializeModeButtons(container) {
        const modeButtons = container.querySelectorAll('.mode-btn');
        modeButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons in the same container
                modeButtons.forEach(btn => btn.classList.remove('active'));
                // Add active class to clicked button
                button.classList.add('active');
            });
        });
    }

    // Initialize mode buttons for all containers
    initializeModeButtons(sub7DivContainer);
    initializeModeButtons(sub8DivContainer);
    initializeModeButtons(sub9DivContainer);

    // Update content display when directions are shown
    const directionButtons = [
        document.getElementById('getDirectionsBtn'),
        document.getElementById('getDirectionsBtnSub8'),
        document.getElementById('getDirectionsBtnSub9')
    ];

    directionButtons.forEach(button => {
        if (button) {
            button.addEventListener('click', () => {
                const container = button.closest('[id$="DivContainer"]');
                if (container) {
                    expandPanel(container, container.querySelector('.scrollable-content'));
                }
            });
        }
    });
});





// Exit navigation functions
function exitNavigationSub7() {
    document.getElementById('subnav7Container').style.display = 'none';
    document.getElementById('sub7DivContainer').style.display = 'block';
    
    // Preserve the active mode and directions state
    const activeMode = document.querySelector('#modeButtons .mode-btn.active');
    if (activeMode) {
        activeMode.classList.add('active');
    }
    document.getElementById('directionsDisplay').style.display = 'block';
}

function exitNavigationSub8() {
    document.getElementById('subnav8Container').style.display = 'none';
    document.getElementById('sub8DivContainer').style.display = 'block';
    
    // Preserve the active mode and directions state
    const activeMode = document.querySelector('#modeButtonsSub8 .mode-btn.active');
    if (activeMode) {
        activeMode.classList.add('active');
    }
    document.getElementById('directionsDisplay1').style.display = 'block';
}

function exitNavigationSub9() {
    // Cache the directions content before switching containers
    const navDirectionsList = document.querySelector('#subnav9Container #directionsList2');
    const navDirectionsContent = navDirectionsList ? navDirectionsList.innerHTML : '';

    // Switch containers
    document.getElementById('subnav9Container').style.display = 'none';
    document.getElementById('sub9DivContainer').style.display = 'block';
    
    // Preserve the active mode
    const activeMode = document.querySelector('#modeButtonsSub9 .mode-btn.active');
    if (activeMode) {
        // Remove active class from all mode buttons first
        document.querySelectorAll('#modeButtonsSub9 .mode-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        // Add active class to the previously active mode
        activeMode.classList.add('active');
    }

    // Ensure directions containers exist in sub9
    const sub9DirectionsList = document.querySelector('#sub9DivContainer #directionsList2');
    const sub9DirectionsDisplay = document.querySelector('#sub9DivContainer #directionsDisplay2');

    // Create containers if they don't exist
    if (!sub9DirectionsDisplay) {
        const display = document.createElement('div');
        display.id = 'directionsDisplay2';
        display.style.cssText = `
            display: none;
            background-color: #222;
            border-radius: 8px;
            margin-top: 20px;
            margin-bottom: 40px;
            width: 100%;
            box-sizing: border-box;
        `;

        const heading = document.createElement('h2');
        heading.textContent = 'Directions';
        heading.style.cssText = `
            padding: 15px 20px;
            margin: 0;
            color: #ff6600;
            border-bottom: 2px solid #444;
            background-color: #222;
        `;
        display.appendChild(heading);

        const list = document.createElement('div');
        list.id = 'directionsList2';
        list.style.cssText = 'padding: 10px 20px 30px;';
        display.appendChild(list);

        const scrollableContent = document.querySelector('#sub9DivContainer .scrollable-content');
        if (scrollableContent) {
            scrollableContent.appendChild(display);
        }
    }

    // Copy the directions content back
    if (navDirectionsContent) {
        // Update the content in sub9 directions list
        if (sub9DirectionsList) {
            sub9DirectionsList.innerHTML = navDirectionsContent;
        }
        // Show the directions display
        if (sub9DirectionsDisplay) {
            sub9DirectionsDisplay.style.display = 'block';
        }
    }

    // Double-check display settings after a brief delay
    setTimeout(() => {
        const finalDisplay = document.querySelector('#sub9DivContainer #directionsDisplay2');
        if (finalDisplay && navDirectionsContent) {
            finalDisplay.style.display = 'block';
        }
    }, 100);
}
// Add mobile support for the navigation containers
document.addEventListener('DOMContentLoaded', function() {
    if (window.innerWidth > 768) return;

    const controls = document.getElementById('controls');
    const navigationContainers = [
        {
            container: document.getElementById('subnav7Container'),
            content: document.querySelector('#subnav7Container .scrollable-content')
        },
        {
            container: document.getElementById('subnav8Container'),
            content: document.querySelector('#subnav8Container .scrollable-content')
        },
        {
            container: document.getElementById('subnav9Container'),
            content: document.querySelector('#subnav9Container .scrollable-content')
        }
    ];

    navigationContainers.forEach(({ container, content }) => {
        if (!container || !content) return;

        let startY = 0;
        let startHeight = 0;
        let isExpanded = false;
        let isDragging = false;

        function isAtTop() {
            return content.scrollTop <= 0;
        }

        container.addEventListener('touchstart', (e) => {
            if (container.style.display !== 'none') {
                startY = e.touches[0].clientY;
                startHeight = controls.offsetHeight;
                isDragging = true;
            }
        });

        container.addEventListener('touchmove', (e) => {
            if (!isDragging || container.style.display === 'none') return;

            if (isExpanded && !isAtTop()) {
                isDragging = false;
                return;
            }

            const deltaY = e.touches[0].clientY - startY;
            const newHeight = startHeight - deltaY;
            const minHeight = window.innerHeight * 0.4;
            const maxHeight = window.innerHeight * 0.7;

            if (newHeight >= minHeight && newHeight <= maxHeight) {
                controls.style.height = `${newHeight}px`;
                e.preventDefault();
            }
        });

        container.addEventListener('touchend', () => {
            if (!isDragging || container.style.display === 'none') return;
            isDragging = false;

            const currentHeight = controls.offsetHeight;
            const threshold = window.innerHeight * 0.55;

            if (currentHeight > threshold) {
                expandPanel();
            } else {
                collapsePanel();
            }
        });

        function expandPanel() {
            controls.style.height = '70vh';
            controls.classList.add('expanded');
            isExpanded = true;
            content.style.overflowY = 'auto';
        }

        function collapsePanel() {
            if (isExpanded && isAtTop()) {
                controls.style.height = '40vh';
                controls.classList.remove('expanded');
                isExpanded = false;
                content.style.overflowY = 'hidden';
            }
        }
    });
});
























document.addEventListener('DOMContentLoaded', function() {
    const centerCoordinates = [-1.2133067398143993, 36.879474707493756];
    const WARNING_DISTANCE = 40; // Distance threshold in meters
    
    document.getElementById('startJourneyBtn').addEventListener('click', async function(e) {
        e.preventDefault(); // Prevent default action initially
        
        // 1. Check if marker is within USIU borders
        const markerLatLng = window.liveMarker.getLatLng();
        const point = [markerLatLng.lng, markerLatLng.lat];
        
        if (!isPointInPolygon(point, usiuBorderCoordinates)) {
            showErrorModal('Outside USIU Campus', 
                'You are outside the USIU campus. You cannot use this feature.',
                'Cancel');
            return;
        }

        // 2. Check distance to red circle if it exists
        if (redCircleMarker) {
            const distanceToRedCircle = markerLatLng.distanceTo(redCircleMarker.getLatLng());
            
            if (distanceToRedCircle > WARNING_DISTANCE) {
                // Show warning modal with options
                const userChoice = await showWarningModal('Distance Warning',
                    'You are far away from the starting point. Do you want to start from your current location?',
                    ['Yes', 'Cancel']);
                
                if (userChoice === 'Cancel') {
                    return;
                }
                
                if (userChoice === 'Yes') {
                    // Transfer settings to sub9
                   

                    // Show loading animation and handle navigation sequence
                    showLoadingWithCountdown(4, () => {


                        const activeButton = document.querySelector("#modeButtons .mode-btn.active");
                    const destinationText = document.getElementById("destinationHeading")
                        .textContent.replace('Destination: ', '');
                    
                    // Hide sub7 and show sub9
                    document.getElementById('sub7DivContainer').style.display = 'none';
                    document.getElementById('sub9DivContainer').style.display = 'block';
                    
                    // Set destination in sub9
                    document.getElementById('sub9DestinationHeading').textContent = 
                        `Destination: ${destinationText}`;
                    
                    // Set the corresponding mode button in sub9 active
                    if (activeButton) {
                        const sub9ModeId = activeButton.id.replace('Mode', 'ModeSub9');
                        const sub9Button = document.getElementById(sub9ModeId);
                        if (sub9Button) {
                            document.querySelectorAll('#modeButtonsSub9 .mode-btn')
                                .forEach(btn => btn.classList.remove('active'));
                            sub9Button.classList.add('active');
                        }
                    }
                        // Click get directions first
                        const getDirectionsBtn = document.getElementById('getDirectionsBtnSub9');
                        if (getDirectionsBtn) {
                            getDirectionsBtn.click();
                            
                            // Give time for directions to load
                            setTimeout(() => {
                                const startJourneyBtn = document.getElementById('startJourneyBtnSub9');
                                if (startJourneyBtn) {
                                    startJourneyBtn.click();
                                }
                            }, 50);
                        }
                    });
                    
                    return;
                }
            }
        }

        // If we get here, conditions are met to proceed with normal sub7 navigation
        
        // Get source and destination text
        const sourceText = document.getElementById('sourceHeading').textContent;
        const destText = document.getElementById('destinationHeading').textContent;
        
        // Set text in navigation container
        document.getElementById('sourceHeadingNav7').textContent = sourceText;
        document.getElementById('destinationHeadingNav7').textContent = destText;
        
        // Copy directions if they exist
        const directionsList = document.getElementById('directionsList');
        if (directionsList.innerHTML) {
            document.querySelector('#subnav7Container #directionsList').innerHTML = 
                directionsList.innerHTML;
            document.querySelector('#subnav7Container #directionsDisplay').style.display = 'block';
        }
        
        // Hide sub7 and show navigation container
        document.getElementById('sub7DivContainer').style.display = 'none';
        document.getElementById('subnav7Container').style.display = 'block';
        
       

        // Update dropdowns
        const sourceTextClean = sourceText.replace('Source: ', '');
        const destTextClean = destText.replace('Destination: ', '');
        selectDropdownOption("source", capitalizeWords(sourceTextClean));
        selectDropdownOption("destination", capitalizeWords(destTextClean));

        // Get and set mode
        const activeButton = document.querySelector("#modeButtons .mode-btn.active");
        let modeValue = "walking"; // default value
        if (activeButton) {
            switch (activeButton.id) {
                case "walkingMode": modeValue = "walking"; break;
                case "vehicleMode": modeValue = "driving"; break;
                case "disabledMode": modeValue = "disabled"; break;
            }
        }
        
        // Set the mode in the dropdown
        const modeDropdown = document.getElementById("mode");
        if (modeDropdown) {
            Array.from(modeDropdown.options).forEach(option => {
                option.selected = option.value === modeValue;
            });
        }

        // Trigger the journey
        setTimeout(() => {
            document.getElementById("startjourney1").click();
        }, 100);
    });

    // Helper function to show error modal
    function showErrorModal(title, message, buttonText) {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            text-align: center;
        `;
        
        modal.innerHTML = `
            <h3 style="margin-bottom: 15px; color: #dc3545;">${title}</h3>
            <p style="margin-bottom: 20px;">${message}</p>
            <button style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                ${buttonText}
            </button>
        `;
        
        document.body.appendChild(modal);
        
        return new Promise(resolve => {
            modal.querySelector('button').onclick = () => {
                document.body.removeChild(modal);
                resolve('Cancel');
            };
        });
    }

    // Helper function to show warning modal with options
    function showWarningModal(title, message, buttons) {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            text-align: center;
        `;
        
        const buttonHtml = buttons.map(btn => `
            <button style="padding: 8px 16px; margin: 0 5px; background: ${btn === 'Cancel' ? '#6c757d' : '#4CAF50'}; 
                    color: white; border: none; border-radius: 4px; cursor: pointer;">
                ${btn}
            </button>
        `).join('');
        
        modal.innerHTML = `
            <h3 style="margin-bottom: 15px;">${title}</h3>
            <p style="margin-bottom: 20px;">${message}</p>
            <div style="display: flex; justify-content: center; gap: 10px;">
                ${buttonHtml}
            </div>
        `;
        
        document.body.appendChild(modal);
        
        return new Promise(resolve => {
            modal.querySelectorAll('button').forEach(button => {
                button.onclick = () => {
                    document.body.removeChild(modal);
                    resolve(button.textContent.trim());
                };
            });
        });
    }
});



document.addEventListener('DOMContentLoaded', function() {
    const centerCoordinates = [-1.2133067398143993, 36.879474707493756];
    const WARNING_DISTANCE = 40; // Distance threshold in meters
    
    document.getElementById('startJourneyBtnSub8').addEventListener('click', async function(e) {
        e.preventDefault();
        
        const markerLatLng = window.liveMarker.getLatLng();
        const point = [markerLatLng.lng, markerLatLng.lat];
        
        if (!isPointInPolygon(point, usiuBorderCoordinates)) {
            showErrorModal('Outside USIU Campus', 
                'You are outside the USIU campus. You cannot use this feature.',
                'Cancel');
            return;
        }

        if (redCircleMarker) {
            const distanceToRedCircle = markerLatLng.distanceTo(redCircleMarker.getLatLng());
            
            if (distanceToRedCircle > WARNING_DISTANCE) {
                const userChoice = await showWarningModal('Distance Warning',
                    'You are far away from the starting point. Do you want to start from your current location?',
                    ['Yes', 'Cancel']);
                
                if (userChoice === 'Cancel') {
                    return;
                }
                
                if (userChoice === 'Yes') {
                   

                    // Show loading animation and handle navigation sequence
                    showLoadingWithCountdown(4, () => {


                        const activeButton = document.querySelector("#modeButtonsSub8 .mode-btn.active");
                    const destinationText = document.getElementById("sub8DestinationHeading")
                        .textContent.replace('Destination: ', '');
                    
                    // Hide sub8 and show sub9
                    document.getElementById('sub8DivContainer').style.display = 'none';
                    document.getElementById('sub9DivContainer').style.display = 'block';
                    
                    // Set destination in sub9
                    document.getElementById('sub9DestinationHeading').textContent = 
                        `Destination: ${destinationText}`;
                    
                    if (activeButton) {
                        const sub9ModeId = activeButton.id.replace('Sub8', 'Sub9');
                        const sub9Button = document.getElementById(sub9ModeId);
                        if (sub9Button) {
                            document.querySelectorAll('#modeButtonsSub9 .mode-btn')
                                .forEach(btn => btn.classList.remove('active'));
                            sub9Button.classList.add('active');
                        }
                    }


                        // Click get directions first
                        const getDirectionsBtn = document.getElementById('getDirectionsBtnSub9');
                        if (getDirectionsBtn) {
                            getDirectionsBtn.click();
                            
                            // Give time for directions to load
                            setTimeout(() => {
                                const startJourneyBtn = document.getElementById('startJourneyBtnSub9');
                                if (startJourneyBtn) {
                                    startJourneyBtn.click();
                                }
                            }, 500);
                        }
                    });
                    return;
                }
            }
        }

        // Normal sub8 navigation
        const sourceText = document.getElementById('sub8SourceHeading').textContent;
        const destText = document.getElementById('sub8DestinationHeading').textContent;
        
        document.getElementById('sourceHeadingNav8').textContent = sourceText;
        document.getElementById('destinationHeadingNav8').textContent = destText;
        
        const directionsList = document.getElementById('directionsList1');
        if (directionsList.innerHTML) {
            document.querySelector('#subnav8Container #directionsList1').innerHTML = 
                directionsList.innerHTML;
            document.querySelector('#subnav8Container #directionsDisplay1').style.display = 'block';
        }
        
        document.getElementById('sub8DivContainer').style.display = 'none';
        document.getElementById('subnav8Container').style.display = 'block';
        
       

        // Update dropdowns
        const destinationText = capitalizeWords(
            destText.trim().replace('Destination: ', '')
        );
        document.getElementById("sourceType").value = "clickOnMap";
        selectDropdownOption("coordDestination", destinationText);

        const activeButton = document.querySelector("#modeButtonsSub8 .mode-btn.active");
        let modeValue = "walking";
        if (activeButton) {
            switch (activeButton.id) {
                case "walkingModeSub8": modeValue = "walking"; break;
                case "vehicleModeSub8": modeValue = "driving"; break;
                case "disabledModeSub8": modeValue = "disabled"; break;
            }
        }
        
        const coordModeDropdown = document.getElementById("coordMode");
        if (coordModeDropdown) {
            Array.from(coordModeDropdown.options).forEach(option => {
                option.selected = option.value === modeValue;
            });
        }

        setTimeout(() => {
            document.getElementById("startjourney2").click();
        }, 100);
    });


    // Helper function to show error modal
    function showErrorModal(title, message, buttonText) {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            text-align: center;
        `;
        
        modal.innerHTML = `
            <h3 style="margin-bottom: 15px; color: #dc3545;">${title}</h3>
            <p style="margin-bottom: 20px;">${message}</p>
            <button style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                ${buttonText}
            </button>
        `;
        
        document.body.appendChild(modal);
        
        return new Promise(resolve => {
            modal.querySelector('button').onclick = () => {
                document.body.removeChild(modal);
                resolve('Cancel');
            };
        });
    }

    // Helper function to show warning modal with options
    function showWarningModal(title, message, buttons) {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            text-align: center;
        `;
        
        const buttonHtml = buttons.map(btn => `
            <button style="padding: 8px 16px; margin: 0 5px; background: ${btn === 'Cancel' ? '#6c757d' : '#4CAF50'}; 
                    color: white; border: none; border-radius: 4px; cursor: pointer;">
                ${btn}
            </button>
        `).join('');
        
        modal.innerHTML = `
            <h3 style="margin-bottom: 15px;">${title}</h3>
            <p style="margin-bottom: 20px;">${message}</p>
            <div style="display: flex; justify-content: center; gap: 10px;">
                ${buttonHtml}
            </div>
        `;
        
        document.body.appendChild(modal);
        
        return new Promise(resolve => {
            modal.querySelectorAll('button').forEach(button => {
                button.onclick = () => {
                    document.body.removeChild(modal);
                    resolve(button.textContent.trim());
                };
            });
        });
    }
});

// Add a global flag to track if we're coming from a warning modal
let comingFromWarningModal = false;

document.addEventListener('DOMContentLoaded', function() {
    const centerCoordinates = [-1.2133067398143993, 36.879474707493756];
    const WARNING_DISTANCE = 40;

    // Common function to handle journey start logic
    async function handleJourneyStart(config) {
        const {
            markerLatLng,
            sourceElement,
            destElement,
            modeButtonsSelector,
            currentContainer,
            navContainer,
            directionsListId,
            displayId,
            sourceHeadingNav,
            destHeadingNav,
            isSubNine = false
        } = config;

        const point = [markerLatLng.lng, markerLatLng.lat];
        
        // Check if marker is within USIU borders
        if (!isPointInPolygon(point, usiuBorderCoordinates)) {
            await showErrorModal('Outside USIU Campus', 
                'You are outside the USIU campus. You cannot use this feature.',
                'Cancel');
            return false;
        }

        // Check distance to red circle only if not coming from warning modal
        // and not in sub9 or if in sub9 but not coming from warning
        if (redCircleMarker && !comingFromWarningModal && (!isSubNine || (isSubNine && !comingFromWarningModal))) {
            const distanceToRedCircle = markerLatLng.distanceTo(redCircleMarker.getLatLng());
            
            if (distanceToRedCircle > WARNING_DISTANCE) {
                const userChoice = await showWarningModal('Distance Warning',
                    'You are far away from the starting point. Do you want to start from your current location?',
                    ['Yes', 'Cancel']);
                
                if (userChoice === 'Cancel') return false;
                
                if (userChoice === 'Yes') {
                    comingFromWarningModal = true;
                    const destinationText = destElement.textContent.replace('Destination: ', '');
                    const activeButton = document.querySelector(modeButtonsSelector + ' .active');

                    // Hide current container and show sub9
                    document.getElementById(currentContainer).style.display = 'none';
                    document.getElementById('sub9DivContainer').style.display = 'block';
                    
                    // Set destination in sub9
                    document.getElementById('sub9DestinationHeading').textContent = 
                        `Destination: ${destinationText}`;
                    
                    // Transfer mode selection
                    if (activeButton) {
                        const sub9ModeId = activeButton.id.replace(/Mode(?:Sub\d+)?$/, 'ModeSub9');
                        const sub9Button = document.getElementById(sub9ModeId);
                        if (sub9Button) {
                            document.querySelectorAll('#modeButtonsSub9 .mode-btn')
                                .forEach(btn => btn.classList.remove('active'));
                            sub9Button.classList.add('active');
                        }
                    }
                    
                    // Automatically trigger start journey in sub9
                    setTimeout(() => {
                        const startJourneyBtn = document.getElementById('startJourneyBtnSub9');
                        if (startJourneyBtn) startJourneyBtn.click();
                    }, 100);
                    
                    return false;
                }
            }
        }

        // Normal navigation flow
        const sourceText = sourceElement.textContent;
        const destText = destElement.textContent;

        // Set navigation container headings
        document.getElementById(sourceHeadingNav).textContent = sourceText;
        document.getElementById(destHeadingNav).textContent = destText;

        // Copy directions if they exist
        const directionsList = document.getElementById(directionsListId);
        if (directionsList?.innerHTML) {
            document.querySelector(`#${navContainer} #${directionsListId}`).innerHTML = 
                directionsList.innerHTML;
            document.querySelector(`#${navContainer} #${displayId}`).style.display = 'block';
        }

        // Switch containers
        document.getElementById(currentContainer).style.display = 'none';
        document.getElementById(navContainer).style.display = 'block';

        // Center map
        if (window.map) {
            window.map.setView(centerCoordinates, 16, {
                animate: true,
                duration: 1
            });
        }

        return true;
    }

   

 

   // Combined comprehensive startJourneyBtnSub9 click handler
document.getElementById('startJourneyBtnSub9').addEventListener('click', async function(e) {
    e.preventDefault();

    // Initial checks and setup
    const markerLatLng = window.liveMarker.getLatLng();
    const point = [markerLatLng.lng, markerLatLng.lat];

    // Check if within USIU borders
    if (!isPointInPolygon(point, usiuBorderCoordinates)) {
        await showErrorModal('Outside USIU Campus',
            'You are outside the USIU campus. You cannot use this feature.',
            'Cancel');
        return;
    }

    // Check distance to red circle if it exists
    if (redCircleMarker && !comingFromWarningModal) {
        const distanceToRedCircle = markerLatLng.distanceTo(redCircleMarker.getLatLng());
        
        if (distanceToRedCircle > WARNING_DISTANCE) {
            const userChoice = await showWarningModal('Distance Warning',
                'You are far away from the starting point. Do you want to start from your current location?',
                ['Yes', 'Cancel']);
            
            if (userChoice === 'Cancel') return;
            
            if (userChoice === 'Yes') {
                comingFromWarningModal = true;
            }
        }
    }

    // Start the journey process
    const success = await handleJourneyStart({
        markerLatLng: markerLatLng,
        sourceElement: document.getElementById('sub9SourceHeading'),
        destElement: document.getElementById('sub9DestinationHeading'),
        modeButtonsSelector: '#modeButtonsSub9',
        currentContainer: 'sub9DivContainer',
        navContainer: 'subnav9Container',
        directionsListId: 'directionsList2',
        displayId: 'directionsDisplay2',
        sourceHeadingNav: 'sourceHeadingNav9',
        destHeadingNav: 'destinationHeadingNav9',
        isSubNine: true
    });

    if (success) {
       
        
        // Primary navigation setup
        await executeNavigationSetup();
    }

    async function executeNavigationSetup() {
        try {
            // Setup live search values
            document.getElementById("sourceType").value = "liveLoc";
            document.getElementById('coordSource4').value = `${markerLatLng.lat}, ${markerLatLng.lng}`;

            // Set destination
            const destText = document.getElementById('sub9DestinationHeading')
                .textContent.replace('Destination: ', '');
            selectDropdownOption("coordDestination", capitalizeWords(destText));

            // Set mode from active button
            const activeButton = document.querySelector("#modeButtonsSub9 .mode-btn.active");
            let modeValue = "walking";
            if (activeButton) {
                switch (activeButton.id) {
                    case "walkingModeSub9": modeValue = "walking"; break;
                    case "vehicleModeSub9": modeValue = "driving"; break;
                    case "disabledModeSub9": modeValue = "disabled"; break;
                }
            }

            // Update mode dropdown
            const coordModeDropdown = document.getElementById("coordMode");
            if (coordModeDropdown) {
                Array.from(coordModeDropdown.options).forEach(option => {
                    option.selected = option.value === modeValue;
                });
            }

            // Trigger live search and wait for results
            await document.getElementById("liveSearchBtn").click();
            
            // Final container and display setup
            setTimeout(() => {
                ensureAndUpdateContainers();
                switchToNavigationView();
            }, 500);
        } catch (error) {
            console.error('Error during navigation setup:', error);
        }
    }

    function ensureAndUpdateContainers() {
        // Get texts for headings
        const sourceText = document.getElementById('sub9SourceHeading').textContent;
        const destText = document.getElementById('sub9DestinationHeading').textContent;
        
        // Update navigation container headings
        document.getElementById('sourceHeadingNav9').textContent = sourceText;
        document.getElementById('destinationHeadingNav9').textContent = destText;

        // Ensure directions containers exist and copy content
        ensureDirectionsContainers();
        
        // Copy directions content
        const directionsList = document.getElementById('directionsList2');
        const navDirectionsList = document.querySelector('#subnav9Container #directionsList2');
        const navDirectionsDisplay = document.querySelector('#subnav9Container #directionsDisplay2');
        
        if (directionsList?.innerHTML && navDirectionsList && navDirectionsDisplay) {
            navDirectionsList.innerHTML = directionsList.innerHTML;
            navDirectionsDisplay.style.display = 'block';
        }
    }

    function switchToNavigationView() {
        // Switch containers
        document.getElementById('sub9DivContainer').style.display = 'none';
        document.getElementById('subnav9Container').style.display = 'block';
        
       

        // Reset warning modal flag
        comingFromWarningModal = false;
    }
});

// Helper function to ensure directions containers exist
function ensureDirectionsContainers() {
    const containers = {
        'directionsDisplay2': {
            type: 'div',
            parent: '#subnav9Container .scrollable-content',
            styles: { display: 'none' },
            children: [
                { type: 'h2', text: 'Directions' },
                { type: 'div', id: 'directionsList2' }
            ]
        }
    };

    Object.entries(containers).forEach(([id, config]) => {
        if (!document.getElementById(id)) {
            const container = document.createElement(config.type);
            container.id = id;
            
            if (config.styles) {
                Object.assign(container.style, config.styles);
            }

            if (config.children) {
                config.children.forEach(child => {
                    const element = document.createElement(child.type);
                    if (child.id) element.id = child.id;
                    if (child.text) element.textContent = child.text;
                    container.appendChild(element);
                });
            }

            const parent = document.querySelector(config.parent);
            if (parent) parent.appendChild(container);
        }
    });
}

// Call this when the page loads
document.addEventListener('DOMContentLoaded', ensureDirectionsContainers);
    


    // Update Get Directions handlers
    document.getElementById("getDirectionsBtnSub9").addEventListener("click", async () => {
        const liveLatLng = window.liveMarker.getLatLng();
        document.getElementById('coordSource4').value = `${liveLatLng.lat}, ${liveLatLng.lng}`;

        document.getElementById("sourceType").value = "liveLoc";
        const destinationText = capitalizeWords(
            document.getElementById("sub9DestinationHeading").textContent.trim().replace('Destination: ', '')
        );
        selectDropdownOption("coordDestination", destinationText);

        const selectedMode = document.querySelector("#modeButtonsSub9 .active")?.id || "walkingModeSub9";
        let modeValue = "walking";
        switch (selectedMode) {
            case "walkingModeSub9": modeValue = "walking"; break;
            case "vehicleModeSub9": modeValue = "driving"; break;
            case "disabledModeSub9": modeValue = "disabled"; break;
        }

        const coordModeDropdown = document.getElementById("coordMode");
        if (coordModeDropdown) {
            Array.from(coordModeDropdown.options).forEach(option => {
                option.selected = option.value === modeValue;
            });
        }

        document.getElementById("directionsDisplay2").style.display = "block";
        document.getElementById("directionsList2").innerHTML = '';

        await document.getElementById("liveSearchBtn").click();
    });

    // Modal Helpers
    function showErrorModal(title, message, buttonText) {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            text-align: center;
        `;
        
        modal.innerHTML = `
            <h3 style="margin-bottom: 15px; color: #dc3545;">${title}</h3>
            <p style="margin-bottom: 20px;">${message}</p>
            <button style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                ${buttonText}
            </button>
        `;
        
        document.body.appendChild(modal);
        
        return new Promise(resolve => {
            modal.querySelector('button').onclick = () => {
                document.body.removeChild(modal);
                resolve('Cancel');
            };
        });
    }

    function showWarningModal(title, message, buttons) {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            text-align: center;
        `;
        
        const buttonHtml = buttons.map(btn => `
            <button style="padding: 8px 16px; margin: 0 5px; background: ${btn === 'Cancel' ? '#6c757d' : '#4CAF50'}; 
                    color: white; border: none; border-radius: 4px; cursor: pointer;">
                ${btn}
            </button>
        `).join('');
        
        modal.innerHTML = `
            <h3 style="margin-bottom: 15px;">${title}</h3>
            <p style="margin-bottom: 20px;">${message}</p>
            <div style="display: flex; justify-content: center; gap: 10px;">
                ${buttonHtml}
            </div>
        `;
        
        document.body.appendChild(modal);
        
        return new Promise(resolve => {
            modal.querySelectorAll('button').forEach(button => {
                button.onclick = () => {
                    document.body.removeChild(modal);
                    resolve(button.textContent.trim());
                };
            });
        });
    }
});
































// First add the CSS styles to the document head
const mapControlStyles = document.createElement('style');
mapControlStyles.textContent = `
.custom-controls-container {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.map-control {
    width: 34px;
    height: 34px;
    background: white;
    border-radius: 50%;
    border: 2px solid rgba(0,0,0,0.2);
    cursor: pointer;
    box-shadow: 0 1px 5px rgba(0,0,0,0.4);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s;
    margin-bottom: 10px;
    position: relative;
}

.map-control:hover {
    background: #f4f4f4;
}

.map-control img {
    width: 20px;
    height: 20px;
    object-fit: contain;
}

[data-tooltip] {
    position: relative;
}

[data-tooltip]:before {
    content: attr(data-tooltip);
    position: absolute;
    right: 100%;
    top: 50%;
    transform: translateY(-50%);
    padding: 5px 10px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    font-size: 12px;
    white-space: nowrap;
    border-radius: 4px;
    margin-right: 10px;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s;
}

[data-tooltip]:hover:before {
    opacity: 1;
    visibility: visible;
}

.layers-menu {
    position: absolute;
    right: 45px;
    top: 0;
    background: white;
    border-radius: 4px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.4);
    display: none;
    width: 200px;
    z-index: 1000;
    padding: 10px 0;
}

.layer-option {
    padding: 8px 15px;
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex;
    align-items: center;
    color: #333;
    font-size: 13px;
}

.layer-option:hover {
    background-color: #f4f4f4;
}

.layer-option.active {
    background-color: #e6e6e6;
}

.layer-radio {
    width: 16px;
    height: 16px;
    margin-right: 10px;
    border: 2px solid #999;
    border-radius: 50%;
    position: relative;
}

.layer-option.active .layer-radio::after {
    content: '';
    position: absolute;
    width: 8px;
    height: 8px;
    background: #ff6600;
    border-radius: 50%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}`;

document.head.appendChild(mapControlStyles);

const mapStyles = {
    light: {
        name: 'Light',
        url: 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png',
    },
    dark: {
        name: 'Dark',
        url: 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png',
    },
    satellite: {
        name: 'Satellite',
        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    },
    osm: {
        name: 'OpenStreetMap',
        url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    },
    worldStreet: {
        name: 'Esri World Street',
        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
    },
    cartoVoyager: {
        name: 'Carto Voyager',
        url: 'https://basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
    },
    openTopo: {
        name: 'OpenTopoMap',
        url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
    },
    worldGray: {
        name: 'Esri World Gray',
        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',
    }
};
// Define the viewport bounds
const mapConfig = {
    mobile: {
        center: [-1.2133067398143993, 36.879474707493756],
        zoom: 16,
        bounds: [
            [-1.2243618055135954, 36.864871289220616],
            [-1.2038858452725378, 36.89613868534187]
        ]
    },
    desktop: {
        center: [-1.2133067398143993, 36.879474707493756],
        zoom: 16,
        bounds: [
            [-1.2243618055135954, 36.864871289220616],
            [-1.2038858452725378, 36.89613868534187]
        ]
    }
};

// Create custom control class
L.Control.CustomControls = L.Control.extend({
    onAdd: function(map) {
        const container = L.DomUtil.create('div', 'custom-controls-container leaflet-bar');
        
        // Create recenter button
        const recenterBtn = L.DomUtil.create('div', 'map-control', container);
        recenterBtn.setAttribute('data-tooltip', 'Recenter map');
        const recenterImg = L.DomUtil.create('img', '', recenterBtn);
        recenterImg.src = 'africa.png';
        recenterImg.alt = 'Recenter';

        // Create my location button
        const locationBtn = L.DomUtil.create('div', 'map-control', container);
        locationBtn.setAttribute('data-tooltip', 'My location');
        const locationImg = L.DomUtil.create('img', '', locationBtn);
        locationImg.src = 'location.png';
        locationImg.alt = 'Location';

        // Create layers button
        const layersBtn = L.DomUtil.create('div', 'map-control', container);
        layersBtn.setAttribute('data-tooltip', 'Change map style');
        const layersImg = L.DomUtil.create('img', '', layersBtn);
        layersImg.src = 'layers.png';
        layersImg.alt = 'Layers';

        // Create layers menu
        const layersMenu = L.DomUtil.create('div', 'layers-menu', container);

        // Create layer options
        Object.entries(mapStyles).forEach(([key, style]) => {
            const option = L.DomUtil.create('div', 'layer-option', layersMenu);
            const radio = L.DomUtil.create('div', 'layer-radio', option);
            const text = L.DomUtil.create('span', '', option);
            text.textContent = style.name;

            if (key === 'light') option.classList.add('active');

            option.onclick = function(e) {
                e.stopPropagation();
                // Remove active class from all options
                layersMenu.querySelectorAll('.layer-option').forEach(opt => 
                    opt.classList.remove('active'));
                // Add active class to clicked option
                option.classList.add('active');
                
                // Change map layer
                if (window.currentBaseLayer) {
                    map.removeLayer(window.currentBaseLayer);
                }
                window.currentBaseLayer = L.tileLayer(style.url, {
                    maxZoom: 18,
                    maxBounds: [
                        [-1.2243618055135954, 36.864871289220616],
                        [-1.2038858452725378, 36.89613868534187]
                    ],
                    maxBoundsViscosity: 1.0,
                    minZoom: 15
                }).addTo(map);
            };
        });

        // Button handlers
        recenterBtn.onclick = function() {
            const isMobile = window.innerWidth <= 768;
            const config = isMobile ? mapConfig.mobile : mapConfig.desktop;
            map.setView(config.center, config.zoom);
        }

        locationBtn.onclick = async function() {
            if (window.liveMarker) {
                const markerLatLng = window.liveMarker.getLatLng();
                const point = [markerLatLng.lng, markerLatLng.lat];

                if (isPointInPolygon(point, usiuBorderCoordinates)) {
                    window.liveMarker.unbindTooltip();
                    window.liveMarker.bindTooltip("Your live location marker", {
                        permanent: true,
                        direction: 'top',
                        offset: [0, -10]
                    }).openTooltip();
                    
                    map.setView(markerLatLng, 16, {
                        animate: true,
                        duration: 1
                    });
                } else {
                    showErrorModal('Outside USIU Campus', 
                        'You are outside the USIU campus. You cannot use this feature.',
                        'Cancel');
                }
            }
        }

        layersBtn.onclick = function(e) {
            e.stopPropagation();
            const isVisible = layersMenu.style.display === 'block';
            layersMenu.style.display = isVisible ? 'none' : 'block';
        };

        // Close layers menu when clicking outside
        document.addEventListener('click', function() {
            layersMenu.style.display = 'none';
        });
        function showErrorModal(title, message, buttonText) {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        z-index: 1000;
        text-align: center;
    `;
    
    modal.innerHTML = `
        <h3 style="margin-bottom: 15px; color: #dc3545;">${title}</h3>
        <p style="margin-bottom: 20px;">${message}</p>
        <button style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
            ${buttonText}
        </button>
    `;
    
    document.body.appendChild(modal);
    
    return new Promise(resolve => {
        modal.querySelector('button').onclick = () => {
            document.body.removeChild(modal);
            resolve('Cancel');
        };
    });
}
        // Prevent map click events when clicking controls
        L.DomEvent.disableClickPropagation(container);
        
        return container;
    }
});

// Handle window resize
function handleResize(map) {
    const isMobile = window.innerWidth <= 768;
    const config = isMobile ? mapConfig.mobile : mapConfig.desktop;
    
    map.setView(config.center, config.zoom);
    map.setMaxBounds(config.bounds);
}

// Add the controls to the map and initialize bounds
window.initializeMapControls = function(map) {
    const isMobile = window.innerWidth <= 768;
    const config = isMobile ? mapConfig.mobile : mapConfig.desktop;
    
    map.setMaxBounds(config.bounds);
    map.setMinZoom(config.zoom - 1);
    map.setMaxZoom( 20);
    map.options.maxBoundsViscosity = 1.0;

    const customControls = new L.Control.CustomControls({ position: 'topright' });
    map.addControl(customControls);

    window.addEventListener('resize', () => handleResize(map));
}

// Initialize controls when document is ready
document.addEventListener('DOMContentLoaded', function() {
    if (window.map) {
        window.initializeMapControls(window.map);
    }
});



















// Add styles for direction hover
const hoverStyles = document.createElement('style');
hoverStyles.textContent = `
.direction-item {
    padding: 12px 0;
    border-bottom: 1px solid #444;
    color: white;
    transition: background-color 0.3s ease;
}

.direction-item.active {
    background-color: #ff6600;
    color: white;
    padding-left: 10px;
    border-radius: 4px;
}
`;
document.head.appendChild(hoverStyles);
function updateDirectionHighlight(containerId, stepIndex) {
    let directionsList;
    let directionFromTable;
    let nextDirectionContainer;

    // Select the correct elements based on container
    if (containerId === 'subnav7Container') {
        directionsList = document.querySelector('#subnav7Container #directionsList');
        directionFromTable = document.getElementById('directionFromTable7');
        nextDirectionContainer = document.getElementById('nextDirectionContainer7');
    } else if (containerId === 'subnav8Container') {
        directionsList = document.querySelector('#subnav8Container #directionsList1');
        directionFromTable = document.getElementById('directionFromTable8');
        nextDirectionContainer = document.getElementById('nextDirectionContainer8');
    } else if (containerId === 'subnav9Container') {
        directionsList = document.querySelector('#subnav9Container #directionsList2');
        directionFromTable = document.getElementById('directionFromTable9');
        nextDirectionContainer = document.getElementById('nextDirectionContainer9');
    }

    if (!directionsList || !directionFromTable || !nextDirectionContainer) return;

    // Remove active class from all directions
    Array.from(directionsList.children).forEach(dir => dir.classList.remove('active'));

    // Add active class to the current direction and update the directionFromTable div
    if (stepIndex >= 0 && stepIndex < directionsList.children.length) {
        const currentStep = directionsList.children[stepIndex];
        currentStep.classList.add('active');

        // Create a new direction item with image for the directionFromTable
        const directionText = currentStep.querySelector('span')?.textContent || currentStep.textContent;
        const directionItem = createDirectionItem(directionText);
        directionItem.classList.add('direction-item');
        
        // Clear and update directionFromTable content
        directionFromTable.innerHTML = '';
        directionFromTable.appendChild(directionItem);

        // Update next direction with image
        const nextStep = directionsList.children[stepIndex + 1];
        if (nextStep) {
            const nextDirectionText = nextStep.querySelector('span')?.textContent || nextStep.textContent;
            const nextImage = getDirectionImage(nextDirectionText);
            nextDirectionContainer.innerHTML = `
                <span class="next-direction-prefix">Then:</span>
                <div style="display: flex; align-items: center;">
                    <img src="${nextImage}" style="width: 20px; height: 20px; margin-right: 8px; object-fit: contain;">
                    <span class="next-direction-text">${nextDirectionText}</span>
                </div>
            `;
            nextDirectionContainer.style.display = 'block';
        } else {
            nextDirectionContainer.style.display = 'none';
        }

        // Scroll the direction into view if needed
        currentStep.scrollIntoView({
            behavior: 'smooth',
            block: 'nearest'
        });
    }
}
function initializeDirectionItems(container) {
    const lists = {
        'subnav7Container': '#directionsList',
        'subnav8Container': '#directionsList1',
        'subnav9Container': '#directionsList2'
    };

    const directionTables = {
        'subnav7Container': 'directionFromTable7',
        'subnav8Container': 'directionFromTable8',
        'subnav9Container': 'directionFromTable9'
    };

    const nextContainers = {
        'subnav7Container': 'nextDirectionContainer7',
        'subnav8Container': 'nextDirectionContainer8',
        'subnav9Container': 'nextDirectionContainer9'
    };

    const listSelector = lists[container];
    const directionTableId = directionTables[container];
    const nextContainerId = nextContainers[container];

    if (!listSelector || !directionTableId) return;

    const directionsList = document.querySelector(`#${container} ${listSelector}`);
    const directionTable = document.getElementById(directionTableId);
    const nextDirectionContainer = document.getElementById(nextContainerId);

    if (!directionsList || !directionTable || !nextDirectionContainer) return;

    // Convert existing direction text nodes to div elements
    const directions = Array.from(directionsList.childNodes);
    directionsList.innerHTML = '';

    directions.forEach((direction, index) => {
        if (direction.nodeType === Node.TEXT_NODE || direction.nodeType === Node.ELEMENT_NODE) {
            const directionText = direction.textContent || direction.innerText;
            const directionItem = createDirectionItem(directionText);
            directionItem.className = 'direction-item';

            // Set the initial active direction
            if (index === 0) {
                directionItem.classList.add('active');
                // Create a new direction item with image for the directionFromTable
                const directionTableItem = createDirectionItem(directionText);
                directionTable.innerHTML = '';
                directionTable.appendChild(directionTableItem);

                // Show the next (second) direction in the "Then" container immediately
                if (directions[1]) {
                    const nextDirectionText = directions[1].textContent || directions[1].innerText;
                    const nextImage = getDirectionImage(nextDirectionText);
                    nextDirectionContainer.innerHTML = `
                        <span class="next-direction-prefix">Then:</span>
                        <div style="display: flex; align-items: center;">
                            <img src="${nextImage}" style="width: 20px; height: 20px; margin-right: 8px; object-fit: contain;">
                            <span class="next-direction-text">${nextDirectionText}</span>
                        </div>
                    `;
                    nextDirectionContainer.style.display = 'block';
                }
            }

            directionsList.appendChild(directionItem);
        }
    });
}
// Add additional CSS styles for better image alignment
const additionalStyles = document.createElement('style');
additionalStyles.textContent = `
    .direction-from-table .direction-item {
        background-color: transparent;
        border: none;
        margin: 0;
    }

    .direction-from-table img {
        width: 24px;
        height: 24px;
        margin-right: 10px;
        vertical-align: middle;
    }

    .direction-item.active img {
        filter: brightness(1.2);
    }

    .direction-item {
        display: flex;
        align-items: center;
        gap: 10px;
        transition: all 0.3s ease;
    }

    .direction-item img {
        width: 24px;
        height: 24px;
        object-fit: contain;
    }

    .direction-item span {
        flex: 1;
    }
`;
document.head.appendChild(additionalStyles);

function extendMarkerDragHandlers() {
    const containers = ['subnav7Container', 'subnav8Container', 'subnav9Container'];
    
    containers.forEach(container => {
        if (document.getElementById(container).style.display === 'block') {
            const currentContainer = container;
            
            if (redCircleMarker) {
                redCircleMarker.on('drag', function(e) {
                    const closestPoint = findClosestPathPoint(e.latlng);
                    if (closestPoint) {
                        redCircleMarker.setLatLng(closestPoint);
                        
                        endpointMarkers.forEach((endpointObj, index) => {
                            const endpointLatLng = endpointObj.marker.getLatLng();
                            const distance = map.distance(closestPoint, endpointLatLng);
                            
                            if (distance < 5) {
                                let directionIndex = Math.floor(index / 2);
                                updateDirectionHighlight(currentContainer, directionIndex);
                                // Add this line to update next direction
                                updateNextDirection(currentContainer, directionIndex);
                            }
                        });
                    }
                });
            }
        }
    });
}

// Initialize event listeners
document.addEventListener('DOMContentLoaded', function() {
    // Initialize direction items for each container
    ['subnav7Container', 'subnav8Container', 'subnav9Container'].forEach(container => {
        const elem = document.getElementById(container);
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                if (mutation.type === 'attributes' && 
                    mutation.attributeName === 'style' && 
                    elem.style.display === 'block') {
                    initializeDirectionItems(container);
                    extendMarkerDragHandlers();
                }
            });
        });

        observer.observe(elem, { attributes: true });
    });
});

// Update the start journey handlers to initialize directions
function updateStartJourneyHandlers() {
    ['startJourneyBtn', 'startJourneyBtnSub8', 'startJourneyBtnSub9'].forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
            const originalClick = btn.onclick;
            btn.onclick = async function(e) {
                if (originalClick) await originalClick.call(this, e);
                
                // Initialize direction items after journey starts
                setTimeout(() => {
                    const containers = {
                        'startJourneyBtn': 'subnav7Container',
                        'startJourneyBtnSub8': 'subnav8Container',
                        'startJourneyBtnSub9': 'subnav9Container'
                    };
                    const container = containers[btnId];
                    if (container) {
                        initializeDirectionItems(container);
                        extendMarkerDragHandlers();
                    }
                }, 500);
            };
        }
    });
}

// Initialize the start journey handlers when document is ready
document.addEventListener('DOMContentLoaded', updateStartJourneyHandlers);

















function updateNextDirection(containerId, currentIndex) {
    // Get the correct lists and containers based on container ID
    const containerMap = {
        'subnav7Container': {
            list: '#directionsList',
            nextContainer: '#nextDirectionContainer7'
        },
        'subnav8Container': {
            list: '#directionsList1',
            nextContainer: '#nextDirectionContainer8'
        },
        'subnav9Container': {
            list: '#directionsList2',
            nextContainer: '#nextDirectionContainer9'
        }
    };

    const config = containerMap[containerId];
    if (!config) return;

    const directionsList = document.querySelector(`#${containerId} ${config.list}`);
    const nextDirectionContainer = document.querySelector(`#${containerId} ${config.nextContainer}`);
    
    if (!directionsList || !nextDirectionContainer) return;

    // Get next direction
    const directions = Array.from(directionsList.children);
    const nextIndex = currentIndex + 1;

    if (nextIndex < directions.length) {
        // There is a next direction, show it
        const nextDirection = directions[nextIndex].textContent;
        const nextDirectionText = nextDirectionContainer.querySelector('.next-direction-text');
        if (nextDirectionText) {
            nextDirectionText.textContent = nextDirection;
        }
        nextDirectionContainer.classList.add('visible');
    } else {
        // No next direction, hide the container
        nextDirectionContainer.classList.remove('visible');
    }
}
// First, add the CSS for the sound toggle button
const soundStyles = document.createElement('style');
soundStyles.textContent = `
.sound-toggle {
    position: fixed;
    top: 70px;
    right: 20px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: #dc3545;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s ease;
    z-index: 1002;
}

.sound-toggle img {
    width: 24px;
    height: 24px;
    filter: invert(1);
}

.sound-toggle.active {
    background-color: #28a745;
}

.sound-toggle::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 2px solid transparent;
    transition: all 0.3s ease;
}

.sound-toggle.active::after {
    border-color: #28a745;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.2); opacity: 0.5; }
    100% { transform: scale(1); opacity: 1; }
}
`;
document.head.appendChild(soundStyles);

class SpeechManager {
    constructor() {
        this.synthesis = window.speechSynthesis;
        this.isActive = false;
        this.currentUtterance = null;
        this.isInitialized = false;
        this.previousValues = new Map();
        this.observers = new Map();
    }

    initialize() {
        if (this.isInitialized) return;
        
        const containerConfig = {
            'subnav7Container': 'currentDirection7',
            'subnav8Container': 'currentDirection8',
            'subnav9Container': 'currentDirection9'
        };

        Object.entries(containerConfig).forEach(([containerId, inputId]) => {
            const container = document.getElementById(containerId);
            if (!container) return;

            const soundToggle = document.createElement('button');
            soundToggle.className = 'sound-toggle';
            soundToggle.innerHTML = '<img src="sound.png" alt="Toggle sound">';
            soundToggle.setAttribute('data-container', containerId);
            
            soundToggle.addEventListener('click', () => this.toggleSound(soundToggle, inputId));
            container.appendChild(soundToggle);

            this.previousValues.set(containerId, '');
            this.setupDirectionMonitoring(containerId, inputId);
        });

        this.isInitialized = true;
    }

    toggleSound(button, inputId) {
        if (!button.classList.contains('active')) {
            button.classList.add('active');
            this.isActive = true;
            
            const currentDirection = document.getElementById(inputId);
            if (currentDirection && currentDirection.value) {
                this.speak(currentDirection.value);
            }
        } else {
            button.classList.remove('active');
            this.isActive = false;
            this.stopSpeaking();
        }
    }

    speak(text) {
        if (!this.isActive || !text) return;

        this.stopSpeaking();
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1;
        utterance.pitch = 1;
        utterance.volume = 1;
        
        utterance.onend = () => {
            this.currentUtterance = null;
        };
        
        this.currentUtterance = utterance;
        this.synthesis.speak(utterance);
    }

    stopSpeaking() {
        this.synthesis.cancel();
        this.currentUtterance = null;
    }

    setupDirectionMonitoring(containerId, inputId) {
        if (this.observers.has(containerId)) {
            this.observers.get(containerId).disconnect();
        }

        const checkInterval = setInterval(() => {
            const currentDirection = document.getElementById(inputId);
            if (!currentDirection) return;

            const currentValue = currentDirection.value;
            const previousValue = this.previousValues.get(containerId);

            if (currentValue !== previousValue && currentValue) {
                const container = document.getElementById(containerId);
                const soundToggle = container.querySelector('.sound-toggle');
                if (soundToggle && soundToggle.classList.contains('active')) {
                    this.speak(currentValue);
                }
                this.previousValues.set(containerId, currentValue);
            }
        }, 100);

        this.observers.set(containerId, {
            disconnect: () => clearInterval(checkInterval)
        });
    }
}

// Create and initialize the speech manager
const speechManager = new SpeechManager();

// Initialize when the document is ready
document.addEventListener('DOMContentLoaded', () => {
    speechManager.initialize();
});

// Update direction handling
const directionConfig = {
    'subnav7Container': 'currentDirection7',
    'subnav8Container': 'currentDirection8',
    'subnav9Container': 'currentDirection9'
};

['updateDirectionHighlight', 'getDirectionFromTable', 'getDirectionFromTable1', 'getDirectionFromTable2'].forEach(functionName => {
    if (window[functionName]) {
        const originalFunction = window[functionName];
        window[functionName] = function(...args) {
            const result = originalFunction.apply(this, args);
            
            Object.entries(directionConfig).forEach(([containerId, inputId]) => {
                const currentDirection = document.getElementById(inputId);
                if (currentDirection) {
                    const currentValue = currentDirection.value;
                    if (currentValue) {
                        currentDirection.value = '';
                        currentDirection.value = currentValue;
                    }
                }
            });
            
            return result;
        };
    }
});




// Updated loading overlay function
function showLoadingOverlay() {
    const overlay = document.createElement('div');
    overlay.className = 'loading-overlay';
    
    const spinner = document.createElement('div');
    spinner.className = 'loading-spinner';
    
    const text = document.createElement('div');
    text.className = 'loading-text';
    text.textContent = 'Getting the shortest route';
    
    overlay.appendChild(spinner);
    overlay.appendChild(text);
    document.body.appendChild(overlay);

    // Create observer to watch for interpolated points
    const observer = new MutationObserver((mutations) => {
        if (interpolatedMarkers.length > 0) {
            overlay.remove();
            observer.disconnect();
        }
    });

    // Observe the map container for changes
    const mapContainer = document.getElementById('map');
    observer.observe(mapContainer, {
        childList: true,
        subtree: true
    });

    return overlay;
}


    </script>
</body>
</html>
